# Research Summary: Sublarr Phase 2+3 Stack

**Domain:** Subtitle management platform with LLM translation
**Researched:** 2026-02-15
**Overall confidence:** HIGH

## Executive Summary

Sublarr's Phase 2+3 requires adding approximately 15 new Python dependencies and 4 new npm packages to support plugin extensibility, multi-backend translation, Whisper speech-to-text, media server abstraction, standalone operation, event-driven hooks, i18n, database migration, and a subtitle editor. The research confirms that well-maintained, production-quality libraries exist for every planned feature -- no custom implementations of solved problems are needed.

The most critical stack decision is the approach to OpenAPI documentation. Flask-smorest and APIFlask both require rewriting all API routes, which is impractical for a 2600-line monolithic server.py. Instead, `apispec` (the library both frameworks use internally) can be applied directly to existing routes via docstrings and decorators, avoiding architectural disruption. This is the single biggest deviation from what a naive approach would suggest.

The translation multi-backend architecture maps cleanly to the existing provider ABC pattern. The `openai` library alone covers all OpenAI-compatible endpoints (Ollama compat mode, LM Studio, vLLM, text-generation-webui), making `litellm` unnecessary. Combined with `deepl` (official), `libretranslatepy`, and optionally `google-cloud-translate`, this covers the full spectrum from free/self-hosted to commercial cloud services.

For the database migration to SQLAlchemy, the research confirms that Flask-SQLAlchemy 3.1.x supports SQLAlchemy 2.0+ natively, and Alembic 1.18.x provides autogenerated migrations. The migration from raw sqlite3 to SQLAlchemy is the highest-effort change in the roadmap but is well-documented. Psycopg 3.3 (not psycopg2) is the correct PostgreSQL adapter -- it was released December 2025 and is the official successor.

## Key Findings

**Stack:** 15 Python packages + 4 npm packages. All actively maintained as of Feb 2026. No risky or unmaintained dependencies. heaviest optional deps are faster-whisper (GPU image) and google-cloud-translate (large dep tree).

**Architecture:** Event-driven + ABC pattern replication. blinker (already a Flask dep) for events. pluggy for plugin hooks. New ABCs for TranslationBackend and MediaServerClient mirroring existing SubtitleProvider.

**Critical pitfall:** server.py monolith must be split into Blueprints before adding Phase 2 features. Module-level singletons (`_manager`, `_client`, `settings = get_settings()` at import time) break Flask Application Factory pattern. This refactoring is prerequisite work, not a feature milestone.

## Implications for Roadmap

Based on research, suggested phase structure:

1. **Architecture Refactoring (pre-M13)** - Convert singletons to extensions, Flask Application Factory, Blueprint decomposition
   - Addresses: Technical debt in server.py (2618 lines), database.py (2153 lines)
   - Avoids: Singleton breakage pitfall (most critical)

2. **Plugin System + Translation Backends (M13-M14)** - pluggy-based discovery, TranslationBackend ABC, DeepL/OpenAI/Libre backends
   - Addresses: Table stakes features (multi-backend, extensibility)
   - Avoids: Cost explosion (ship cost tracking WITH first paid backend)

3. **Whisper + Media Servers (M15-M16)** - faster-whisper/Subgen integration, PlexAPI, Kodi JSON-RPC
   - Addresses: Key differentiator (Whisper STT), table stakes (Plex support)
   - Avoids: GPU OOM (external Subgen API as default, embedded GPU as opt-in)

4. **Standalone + Forced Subs (M17-M18)** - watchdog folder-watch, TMDB/AniList metadata, forced subtitle data model
   - Addresses: Non-*arr user base expansion
   - Avoids: Wanted queue spam from forced subs (model as separate dimension)

5. **Events + i18n + OpenAPI (M19-M21)** - blinker events, react-i18next, apispec documentation
   - Addresses: Extensibility, internationalization, API discoverability
   - Avoids: Multiple event system anti-pattern

6. **Performance + Scalability (M23)** - SQLAlchemy + Alembic + psycopg3, Redis + RQ, Flask-Caching
   - Addresses: Scale beyond SQLite, persistent job queue
   - Avoids: Big-bang database migration (incremental: repository interface first, then ORM, then migrations)

7. **Advanced UI (M24+)** - @uiw/react-codemirror subtitle editor, batch operations, comparison tools
   - Addresses: Phase 3 UX differentiators

**Phase ordering rationale:**
- Architecture refactoring MUST come first -- plugins, backends, and media servers all need the Application Factory pattern
- i18n should be done early (before M22 community launch) so new UI features are born i18n-ready
- PostgreSQL/Redis deferred to late Phase 2 because SQLite handles the homelab use case fine
- Whisper before standalone mode because Whisper provides more unique value

**Research flags for phases:**
- M13 (Plugin System): Needs deeper research on plugin manifest format, version compatibility protocol
- M15 (Whisper): Needs deeper research on Docker CUDA image sizing, GPU memory management
- M17 (Standalone): Needs deeper research on filename parsing library (guessit vs custom regex)
- M23 (Database): Needs deeper research on SQLite-to-PostgreSQL data migration tooling

## Confidence Assessment

| Area | Confidence | Notes |
|------|------------|-------|
| Stack | HIGH | All library versions verified against PyPI/npm. All actively maintained. |
| Features | HIGH | Feature landscape based on Bazarr competitive analysis + existing roadmap. |
| Architecture | HIGH | Patterns (ABC, registry, events) already proven in codebase. Extensions are natural. |
| Pitfalls | HIGH | Based on Bazarr issue tracker (specific issue numbers), Flask-SocketIO docs, official library docs. |

## Gaps to Address

- **Filename parsing for standalone mode (M17):** guessit is the standard library but has known regex issues (Medusa #7743). Need to evaluate whether a custom parser is more reliable for anime naming conventions.
- **Plugin UI components (M13):** How plugins register frontend UI components is unresearched. Options: (a) plugins are backend-only, (b) plugins provide custom settings via JSON schema rendered by generic form components, (c) plugins ship frontend JS bundles loaded dynamically.
- **Alembic + SQLite batch mode (M23):** SQLite does not support ALTER TABLE for column modifications. Alembic's batch mode recreates the table. This needs testing with Sublarr's 17-table schema to ensure migrations work correctly.
- **Socket.IO Redis adapter (M23):** The current `--workers 2` gunicorn config breaks WebSocket. The fix (single worker + Redis adapter for multi-process) needs validation.
- **Google Cloud Translate dependency size:** google-cloud-translate pulls in grpc and google-auth, adding ~100MB. Should be a strict optional extra, not included in default image.

---

*Research summary: 2026-02-15*
