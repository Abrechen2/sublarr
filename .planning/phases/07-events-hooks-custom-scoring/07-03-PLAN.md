---
phase: 07-events-hooks-custom-scoring
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - backend/routes/hooks.py
  - backend/routes/__init__.py
  - frontend/src/lib/types.ts
  - frontend/src/api/client.ts
  - frontend/src/hooks/useApi.ts
  - frontend/src/pages/Settings.tsx
autonomous: true

must_haves:
  truths:
    - "User can create, edit, enable/disable, and delete shell script hooks from Settings UI"
    - "User can create, edit, enable/disable, and delete outgoing webhooks from Settings UI"
    - "User can view the event catalog (all available event types) in the UI"
    - "User can test a hook or webhook with a sample event payload"
    - "User can view hook/webhook execution logs with success/failure status"
    - "User can adjust scoring weights for episode and movie score types from Settings UI"
    - "User can set per-provider score modifiers (bonus/malus) from Settings UI"
    - "User can reset scoring weights to defaults"
  artifacts:
    - path: "backend/routes/hooks.py"
      provides: "Blueprint with CRUD endpoints for hooks, webhooks, scoring, event catalog"
      exports: ["hooks_bp"]
    - path: "frontend/src/lib/types.ts"
      provides: "TypeScript interfaces for HookConfig, WebhookConfig, ScoringWeight, ProviderModifier, EventCatalogItem, HookLog"
      contains: "HookConfig"
    - path: "frontend/src/pages/Settings.tsx"
      provides: "Events & Hooks tab and Scoring tab in Settings page"
      contains: "Events & Hooks"
  key_links:
    - from: "backend/routes/hooks.py"
      to: "backend/db/hooks.py"
      via: "CRUD operations"
      pattern: "from db\\.hooks import"
    - from: "backend/routes/hooks.py"
      to: "backend/db/scoring.py"
      via: "scoring weight CRUD"
      pattern: "from db\\.scoring import"
    - from: "frontend/src/api/client.ts"
      to: "backend/routes/hooks.py"
      via: "HTTP API calls"
      pattern: "/api/v1/hooks"
    - from: "frontend/src/pages/Settings.tsx"
      to: "frontend/src/hooks/useApi.ts"
      via: "React Query hooks"
      pattern: "useHookConfigs|useWebhookConfigs|useScoringWeights"
---

<objective>
Create the API blueprint for hooks, webhooks, and scoring CRUD, then build the frontend Settings tabs for event/hook management and scoring configuration.

Purpose: This is the user-facing layer. Without it, hooks/webhooks/scoring are only configurable via direct DB manipulation. This plan delivers the Settings UI where users can configure shell hooks, outgoing webhooks, browse the event catalog, view execution logs, and tune scoring weights -- completing all 6 requirements (EVNT-01 through EVNT-04, SCOR-01, SCOR-02).

Output: routes/hooks.py Blueprint, TypeScript types/hooks/API client, Settings tabs for Events & Hooks and Scoring
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-events-hooks-custom-scoring/07-RESEARCH.md
@.planning/phases/07-events-hooks-custom-scoring/07-01-SUMMARY.md
@.planning/phases/07-events-hooks-custom-scoring/07-02-SUMMARY.md

@backend/routes/__init__.py
@backend/routes/whisper.py
@backend/db/hooks.py
@backend/db/scoring.py
@backend/events/catalog.py
@backend/providers/base.py
@frontend/src/pages/Settings.tsx
@frontend/src/lib/types.ts
@frontend/src/api/client.ts
@frontend/src/hooks/useApi.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hooks Blueprint with CRUD + event catalog + scoring API endpoints</name>
  <files>backend/routes/hooks.py, backend/routes/__init__.py</files>
  <action>
**routes/hooks.py** — Create a new Flask Blueprint `hooks_bp` with prefix `/api/v1`:

**Event Catalog endpoints:**
- `GET /events/catalog` — Return the EVENT_CATALOG dict from events.catalog as JSON list: `[{name, label, description, payload_keys}]` for each event. This powers the event dropdown in the UI.

**Hook Config CRUD:**
- `GET /hooks` — List all hook configs. Optional query param `event_name` to filter. Returns JSON array of hook config dicts.
- `POST /hooks` — Create hook config. Body: `{name, event_name, script_path, timeout_seconds?}`. Validate: name required, event_name must exist in EVENT_CATALOG, script_path required. Returns 201 with created config.
- `GET /hooks/<int:hook_id>` — Get single hook config.
- `PUT /hooks/<int:hook_id>` — Update hook config. Body: partial dict of fields to update. Returns updated config.
- `DELETE /hooks/<int:hook_id>` — Delete hook config. Returns 204.
- `POST /hooks/<int:hook_id>/test` — Test-fire a hook with sample event data. Builds a sample payload from EVENT_CATALOG payload_keys (all set to "test_value"), calls HookEngine.execute_hook synchronously (not via thread pool), returns the result dict with stdout/stderr/exit_code. This is a blocking call for immediate UI feedback.

**Webhook Config CRUD:**
- `GET /webhooks` — List all webhook configs. Optional query param `event_name` to filter. Returns JSON array.
- `POST /webhooks` — Create webhook config. Body: `{name, event_name, url, secret?, retry_count?, timeout_seconds?}`. Validate: name required, event_name must be in EVENT_CATALOG or "*", url required and must start with http:// or https://. Returns 201.
- `GET /webhooks/<int:webhook_id>` — Get single webhook config.
- `PUT /webhooks/<int:webhook_id>` — Update webhook config. Body: partial dict. Returns updated config.
- `DELETE /webhooks/<int:webhook_id>` — Delete webhook config. Returns 204.
- `POST /webhooks/<int:webhook_id>/test` — Test-fire webhook with sample payload. Calls WebhookDispatcher.send_webhook synchronously, returns result with status_code/success. Blocking for UI feedback.

**Hook Log endpoints:**
- `GET /hooks/logs` — List hook execution logs. Optional query params: hook_id, webhook_id, limit (default 50). Returns JSON array of log entries.
- `DELETE /hooks/logs` — Clear all hook logs. Returns 204.

**Scoring Weight endpoints:**
- `GET /scoring/weights` — Return all scoring weights for both episode and movie types, merged with defaults. Format: `{episode: {hash: 359, series: 180, ...}, movie: {hash: 119, title: 60, ...}, defaults: {episode: {...}, movie: {...}}}`. Include defaults so UI can show "reset to default" per field.
- `PUT /scoring/weights` — Update scoring weights. Body: `{episode?: {key: value, ...}, movie?: {key: value, ...}}`. Calls set_scoring_weights for each type. Calls invalidate_scoring_cache. Returns updated weights.
- `DELETE /scoring/weights` — Reset all scoring weights to defaults. Calls reset_scoring_weights. Calls invalidate_scoring_cache. Returns 204.

**Provider Modifier endpoints:**
- `GET /scoring/modifiers` — Return all provider modifiers as dict. Format: `{provider_name: modifier, ...}`.
- `PUT /scoring/modifiers` — Update provider modifiers. Body: `{provider_name: modifier, ...}`. Calls set_provider_modifier for each. Calls invalidate_scoring_cache. Returns updated modifiers.
- `DELETE /scoring/modifiers/<provider_name>` — Delete a single provider modifier. Returns 204.

**routes/__init__.py** — Add `from routes.hooks import hooks_bp` and register it in `register_blueprints()`.
  </action>
  <verify>
```bash
cd backend && python -c "
from app import create_app
app = create_app(testing=True)
client = app.test_client()

# Event catalog
r = client.get('/api/v1/events/catalog')
assert r.status_code == 200
events = r.get_json()
assert len(events) >= 14, f'Expected 14+ events, got {len(events)}'
print(f'OK: Event catalog returns {len(events)} events')

# Hook CRUD
r = client.post('/api/v1/hooks', json={'name': 'test', 'event_name': 'subtitle_downloaded', 'script_path': '/tmp/test.sh'})
assert r.status_code == 201
hook = r.get_json()
hook_id = hook['id']
print(f'OK: Hook created with id={hook_id}')

r = client.get('/api/v1/hooks')
assert r.status_code == 200
assert len(r.get_json()) >= 1

r = client.delete(f'/api/v1/hooks/{hook_id}')
assert r.status_code == 204

# Webhook CRUD
r = client.post('/api/v1/webhooks', json={'name': 'test-wh', 'event_name': 'translation_complete', 'url': 'https://example.com/hook'})
assert r.status_code == 201
wh = r.get_json()
print(f'OK: Webhook created with id={wh[\"id\"]}')
client.delete(f'/api/v1/webhooks/{wh[\"id\"]}')

# Scoring
r = client.get('/api/v1/scoring/weights')
assert r.status_code == 200
data = r.get_json()
assert 'episode' in data and 'movie' in data
print(f'OK: Scoring weights returned')

r = client.put('/api/v1/scoring/weights', json={'episode': {'hash': 500}})
assert r.status_code == 200
assert r.get_json()['episode']['hash'] == 500
print('OK: Scoring weight updated')

print('ALL API TESTS PASSED')
"
```
  </verify>
  <done>hooks_bp Blueprint registered with full CRUD for hooks, webhooks, hook logs, scoring weights, and provider modifiers; all endpoints return correct status codes and JSON</done>
</task>

<task type="auto">
  <name>Task 2: Frontend Settings tabs for Events/Hooks and Scoring</name>
  <files>frontend/src/lib/types.ts, frontend/src/api/client.ts, frontend/src/hooks/useApi.ts, frontend/src/pages/Settings.tsx</files>
  <action>
**types.ts** — Add TypeScript interfaces at end of file:

```typescript
// Events & Hooks
export interface EventCatalogItem {
  name: string
  label: string
  description: string
  payload_keys: string[]
}

export interface HookConfig {
  id: number
  name: string
  event_name: string
  hook_type: string
  enabled: boolean
  script_path: string
  timeout_seconds: number
  last_triggered_at: string
  last_status: string
  trigger_count: number
  created_at: string
  updated_at: string
}

export interface WebhookConfig {
  id: number
  name: string
  event_name: string
  url: string
  secret: string
  enabled: boolean
  retry_count: number
  timeout_seconds: number
  last_triggered_at: string
  last_status_code: number
  last_error: string
  consecutive_failures: number
  trigger_count: number
  created_at: string
  updated_at: string
}

export interface HookLog {
  id: number
  hook_id: number | null
  webhook_id: number | null
  event_name: string
  hook_type: string
  success: boolean
  exit_code: number | null
  status_code: number | null
  stdout: string
  stderr: string
  error: string
  duration_ms: number
  triggered_at: string
}

export interface HookTestResult {
  success: boolean
  exit_code?: number
  stdout?: string
  stderr?: string
  status_code?: number
  error?: string
  duration_ms: number
}

export interface ScoringWeights {
  episode: Record<string, number>
  movie: Record<string, number>
  defaults: {
    episode: Record<string, number>
    movie: Record<string, number>
  }
}

export interface ProviderModifiers {
  [provider_name: string]: number
}
```

**client.ts** — Add API functions:

```typescript
// Events & Hooks
export const getEventCatalog = () => api.get('/events/catalog').then(r => r.data)
export const getHookConfigs = (eventName?: string) => api.get('/hooks', { params: eventName ? { event_name: eventName } : {} }).then(r => r.data)
export const createHookConfig = (data: Partial<HookConfig>) => api.post('/hooks', data).then(r => r.data)
export const updateHookConfig = (id: number, data: Partial<HookConfig>) => api.put(`/hooks/${id}`, data).then(r => r.data)
export const deleteHookConfig = (id: number) => api.delete(`/hooks/${id}`)
export const testHook = (id: number) => api.post(`/hooks/${id}/test`).then(r => r.data)
export const getWebhookConfigs = (eventName?: string) => api.get('/webhooks', { params: eventName ? { event_name: eventName } : {} }).then(r => r.data)
export const createWebhookConfig = (data: Partial<WebhookConfig>) => api.post('/webhooks', data).then(r => r.data)
export const updateWebhookConfig = (id: number, data: Partial<WebhookConfig>) => api.put(`/webhooks/${id}`, data).then(r => r.data)
export const deleteWebhookConfig = (id: number) => api.delete(`/webhooks/${id}`)
export const testWebhook = (id: number) => api.post(`/webhooks/${id}/test`).then(r => r.data)
export const getHookLogs = (params?: { hook_id?: number; webhook_id?: number; limit?: number }) => api.get('/hooks/logs', { params }).then(r => r.data)
export const clearHookLogs = () => api.delete('/hooks/logs')
export const getScoringWeights = () => api.get('/scoring/weights').then(r => r.data)
export const updateScoringWeights = (data: { episode?: Record<string, number>; movie?: Record<string, number> }) => api.put('/scoring/weights', data).then(r => r.data)
export const resetScoringWeights = () => api.delete('/scoring/weights')
export const getProviderModifiers = () => api.get('/scoring/modifiers').then(r => r.data)
export const updateProviderModifiers = (data: Record<string, number>) => api.put('/scoring/modifiers', data).then(r => r.data)
export const deleteProviderModifier = (name: string) => api.delete(`/scoring/modifiers/${name}`)
```

**useApi.ts** — Add React Query hooks at end of file:

```typescript
// Events & Hooks
export function useEventCatalog() { return useQuery({ queryKey: ['eventCatalog'], queryFn: getEventCatalog }) }
export function useHookConfigs() { return useQuery({ queryKey: ['hookConfigs'], queryFn: () => getHookConfigs() }) }
export function useCreateHook() { const qc = useQueryClient(); return useMutation({ mutationFn: createHookConfig, onSuccess: () => qc.invalidateQueries({ queryKey: ['hookConfigs'] }) }) }
export function useUpdateHook() { const qc = useQueryClient(); return useMutation({ mutationFn: ({ id, data }: { id: number; data: Partial<HookConfig> }) => updateHookConfig(id, data), onSuccess: () => qc.invalidateQueries({ queryKey: ['hookConfigs'] }) }) }
export function useDeleteHook() { const qc = useQueryClient(); return useMutation({ mutationFn: deleteHookConfig, onSuccess: () => qc.invalidateQueries({ queryKey: ['hookConfigs'] }) }) }
export function useTestHook() { return useMutation({ mutationFn: testHook }) }
export function useWebhookConfigs() { return useQuery({ queryKey: ['webhookConfigs'], queryFn: () => getWebhookConfigs() }) }
export function useCreateWebhook() { const qc = useQueryClient(); return useMutation({ mutationFn: createWebhookConfig, onSuccess: () => qc.invalidateQueries({ queryKey: ['webhookConfigs'] }) }) }
export function useUpdateWebhook() { const qc = useQueryClient(); return useMutation({ mutationFn: ({ id, data }: { id: number; data: Partial<WebhookConfig> }) => updateWebhookConfig(id, data), onSuccess: () => qc.invalidateQueries({ queryKey: ['webhookConfigs'] }) }) }
export function useDeleteWebhook() { const qc = useQueryClient(); return useMutation({ mutationFn: deleteWebhookConfig, onSuccess: () => qc.invalidateQueries({ queryKey: ['webhookConfigs'] }) }) }
export function useTestWebhook() { return useMutation({ mutationFn: testWebhook }) }
export function useHookLogs(params?: { hook_id?: number; webhook_id?: number; limit?: number }) { return useQuery({ queryKey: ['hookLogs', params], queryFn: () => getHookLogs(params) }) }
export function useScoringWeights() { return useQuery({ queryKey: ['scoringWeights'], queryFn: getScoringWeights }) }
export function useUpdateScoringWeights() { const qc = useQueryClient(); return useMutation({ mutationFn: updateScoringWeights, onSuccess: () => qc.invalidateQueries({ queryKey: ['scoringWeights'] }) }) }
export function useResetScoringWeights() { const qc = useQueryClient(); return useMutation({ mutationFn: resetScoringWeights, onSuccess: () => qc.invalidateQueries({ queryKey: ['scoringWeights'] }) }) }
export function useProviderModifiers() { return useQuery({ queryKey: ['providerModifiers'], queryFn: getProviderModifiers }) }
export function useUpdateProviderModifiers() { const qc = useQueryClient(); return useMutation({ mutationFn: updateProviderModifiers, onSuccess: () => qc.invalidateQueries({ queryKey: ['providerModifiers'] }) }) }
```

**Settings.tsx** — Add two new tabs to the TABS array and implement their content:

1. Add `'Events & Hooks'` and `'Scoring'` to the TABS array (after 'Whisper', before 'Notifications').

2. **Events & Hooks tab** — Three collapsible sections:

   **Shell Hooks section:**
   - List of configured hooks as cards showing: name, event_name (badge), script_path, enabled toggle, last triggered, trigger count
   - Each card has: Edit (pencil icon), Test (TestTube icon), Delete (Trash2 icon) buttons
   - "Add Hook" button opens inline form: name (text input), event_name (select dropdown populated from useEventCatalog), script_path (text input with placeholder "/config/hooks/my-script.sh"), timeout_seconds (number input, default 30)
   - Test button calls useTestHook and shows result in a toast (success: green with stdout preview, failure: red with stderr/error)
   - Enabled toggle calls useUpdateHook with {enabled: !current}

   **Outgoing Webhooks section:**
   - List of configured webhooks as cards showing: name, event_name (badge, show "*" as "All Events"), url (truncated), enabled toggle, last status code (green/red badge), consecutive failures, trigger count
   - Each card has: Edit, Test, Delete buttons
   - "Add Webhook" button opens inline form: name, event_name (select dropdown with additional "*" option for all events), url (text input), secret (password input with show/hide toggle), retry_count (number, default 3), timeout_seconds (number, default 10)
   - Test button calls useTestWebhook and shows status_code in toast

   **Execution Log section:**
   - Table showing recent hook/webhook executions: triggered_at, event_name, hook_type badge (script/webhook), success (checkmark/X icon), duration_ms, expand row for stdout/stderr/error details
   - "Clear Logs" button with confirmation
   - Default limit: 50 entries

   Follow the collapsible card pattern from TranslationBackendsTab and MediaServersTab for UI consistency.

3. **Scoring tab** — Two sections:

   **Scoring Weights section:**
   - Two side-by-side tables (or stacked on mobile): Episode Weights and Movie Weights
   - Each table row: weight_key (label), current value (editable number input), default value (grey text for reference)
   - "Save" button to persist changes (calls useUpdateScoringWeights)
   - "Reset to Defaults" button per table (calls useResetScoringWeights)
   - Show ASS format bonus as its own row labeled "ASS Format Bonus"

   **Provider Modifiers section:**
   - List of providers from useProviders hook (already exists)
   - Each provider row: provider name, modifier input (number, range -100 to +100), current modifier value
   - Positive values shown in green (bonus), negative in red (malus), zero in grey (neutral)
   - "Save All" button to persist (calls useUpdateProviderModifiers with all values)

   Visual guide: small info text explaining "Higher weights = more important match criteria. Provider modifiers add bonus (positive) or penalty (negative) to all results from that provider."
  </action>
  <verify>
```bash
cd frontend && npx tsc --noEmit 2>&1 | head -20
cd frontend && npm run lint 2>&1 | tail -5
```
  </verify>
  <done>Settings page has "Events & Hooks" tab (hook CRUD, webhook CRUD, event catalog dropdown, test buttons, execution log) and "Scoring" tab (episode/movie weight editors with defaults, provider modifier sliders, reset buttons); all TypeScript types compile; API client functions work</done>
</task>

</tasks>

<verification>
1. `GET /api/v1/events/catalog` returns 14+ events with labels and descriptions
2. Hook CRUD cycle: create -> list -> update -> test -> delete all return correct status codes
3. Webhook CRUD cycle: create -> list -> update -> test -> delete all return correct status codes
4. `GET /api/v1/scoring/weights` returns episode and movie weights with defaults
5. `PUT /api/v1/scoring/weights` updates weights and invalidates cache
6. Frontend TypeScript compiles without errors
7. Settings page renders Events & Hooks tab with hook/webhook management
8. Settings page renders Scoring tab with weight editors and provider modifiers
</verification>

<success_criteria>
- routes/hooks.py Blueprint with 18+ endpoints for events catalog, hooks, webhooks, logs, scoring
- Blueprint registered in routes/__init__.py
- TypeScript interfaces for all hook/webhook/scoring types
- API client functions for all endpoints
- React Query hooks for all CRUD operations
- Settings "Events & Hooks" tab: hook cards, webhook cards, event dropdown, test buttons, execution log
- Settings "Scoring" tab: episode/movie weight tables with editable inputs, provider modifier list, reset buttons
- All TypeScript compiles, lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/07-events-hooks-custom-scoring/07-03-SUMMARY.md`
</output>
