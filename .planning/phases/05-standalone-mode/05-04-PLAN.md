---
phase: 05-standalone-mode
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - backend/routes/standalone.py
  - backend/routes/__init__.py
  - backend/wanted_search.py
autonomous: true

must_haves:
  truths:
    - "API endpoints exist to CRUD watched folders, list standalone series/movies, trigger scans, and get standalone status"
    - "Standalone wanted items get rich VideoQuery metadata from standalone_series/standalone_movies tables (not Sonarr/Radarr)"
    - "Provider search for standalone items uses TMDB/TVDB/AniList IDs from standalone metadata"
  artifacts:
    - path: "backend/routes/standalone.py"
      provides: "Blueprint with /api/v1/standalone/* endpoints"
      exports: ["bp"]
    - path: "backend/routes/__init__.py"
      provides: "Registration of standalone blueprint"
      contains: "standalone"
    - path: "backend/wanted_search.py"
      provides: "Extended build_query_from_wanted for standalone items"
      contains: "standalone_series_id"
  key_links:
    - from: "backend/routes/standalone.py"
      to: "backend/db/standalone.py"
      via: "DB operations for watched folders and standalone entries"
      pattern: "from db.standalone import"
    - from: "backend/routes/standalone.py"
      to: "backend/standalone/__init__.py"
      via: "StandaloneManager for status and control"
      pattern: "get_standalone_manager"
    - from: "backend/wanted_search.py"
      to: "backend/db/standalone.py"
      via: "get_standalone_series for metadata enrichment"
      pattern: "get_standalone_series|get_standalone_movies"
---

<objective>
Create the standalone API Blueprint and extend wanted_search to enrich standalone items with metadata.

Purpose: Provide the REST API for managing watched folders and standalone entries, and ensure provider searches for standalone items get proper metadata (TMDB/TVDB/AniList IDs, series title, season/episode) for scoring.
Output: `backend/routes/standalone.py` (new Blueprint), modified `backend/routes/__init__.py`, modified `backend/wanted_search.py`.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-standalone-mode/05-RESEARCH.md
@.planning/phases/05-standalone-mode/05-01-SUMMARY.md
@.planning/phases/05-standalone-mode/05-02-SUMMARY.md
@backend/routes/__init__.py
@backend/routes/wanted.py
@backend/wanted_search.py
@backend/db/standalone.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Standalone API Blueprint</name>
  <files>backend/routes/standalone.py, backend/routes/__init__.py</files>
  <action>
  1. Create `backend/routes/standalone.py` -- new Blueprint following the exact pattern of existing route files (e.g., routes/wanted.py, routes/mediaservers.py):

  ```python
  """Standalone mode API endpoints.

  Manages watched folders, standalone series/movies, metadata refresh,
  and scanner control for folder-watch mode without Sonarr/Radarr.
  """
  from flask import Blueprint, request, jsonify
  ```

  Blueprint: `bp = Blueprint("standalone", __name__, url_prefix="/api/v1/standalone")`

  Endpoints to implement:

  **Watched Folders:**
  - `GET /api/v1/standalone/folders` -- list all watched folders (get_watched_folders with enabled_only=False for settings display)
  - `POST /api/v1/standalone/folders` -- add a new watched folder. Body: {path, label?, media_type?}. Validate path is a directory that exists. Return 201 + folder dict.
  - `PUT /api/v1/standalone/folders/<int:folder_id>` -- update folder. Body: {path?, label?, media_type?, enabled?}. Return 200 + folder dict.
  - `DELETE /api/v1/standalone/folders/<int:folder_id>` -- delete folder. Return 200 + {success: true}.

  **Standalone Series:**
  - `GET /api/v1/standalone/series` -- list all standalone series with episode counts. Join with wanted_items to get wanted count per series.
  - `GET /api/v1/standalone/series/<int:series_id>` -- get single series with its files and wanted status.
  - `DELETE /api/v1/standalone/series/<int:series_id>` -- delete series and its wanted items.

  **Standalone Movies:**
  - `GET /api/v1/standalone/movies` -- list all standalone movies with wanted status.
  - `DELETE /api/v1/standalone/movies/<int:movie_id>` -- delete movie and its wanted items.

  **Scanner Control:**
  - `POST /api/v1/standalone/scan` -- trigger a full scan of all watched folders. Returns 202 + {message: "Scan started"}. Runs in background thread.
  - `POST /api/v1/standalone/scan/<int:folder_id>` -- scan a single folder.
  - `GET /api/v1/standalone/status` -- get standalone status from StandaloneManager.get_status().

  **Metadata:**
  - `POST /api/v1/standalone/series/<int:series_id>/refresh-metadata` -- re-resolve metadata for a series (clears cache, re-fetches from TMDB/AniList/TVDB).

  Error handling: Use try/except with logger.error and return appropriate HTTP status codes (400 for bad input, 404 for not found, 500 for internal errors). Follow the same pattern as routes/wanted.py.

  For scan endpoints: Import StandaloneScanner and run scan in a daemon thread (same pattern as wanted scan in routes/wanted.py):
  ```python
  import threading
  def _run_scan():
      from standalone.scanner import StandaloneScanner
      scanner = StandaloneScanner()
      scanner.scan_all_folders()
  threading.Thread(target=_run_scan, daemon=True).start()
  ```

  2. Modify `backend/routes/__init__.py` -- register the new standalone blueprint:

  Add after the whisper_bp import:
  ```python
  from routes.standalone import bp as standalone_bp
  ```

  Add `standalone_bp` to the blueprint list in the for loop.
  </action>
  <verify>
  ```bash
  cd backend && python -c "
# Verify blueprint imports
from routes.standalone import bp
assert bp.name == 'standalone'
assert bp.url_prefix == '/api/v1/standalone'
print(f'Blueprint: {bp.name}, prefix: {bp.url_prefix}')

# Verify registration
from routes import register_blueprints
import inspect
source = inspect.getsource(register_blueprints)
assert 'standalone' in source, 'standalone not in register_blueprints'
print('Blueprint registered in routes/__init__.py')

# Verify routes exist
rules = [rule.rule for rule in bp.deferred_functions] if hasattr(bp, 'deferred_functions') else []
print(f'Blueprint has deferred functions: {len(bp.deferred_functions)}')
print('Standalone routes module loads correctly')
"
  ```
  </verify>
  <done>Standalone Blueprint registered at /api/v1/standalone with CRUD endpoints for watched folders, series, movies, scanner control, and metadata refresh. Blueprint registered in routes/__init__.py.</done>
</task>

<task type="auto">
  <name>Task 2: Extend wanted_search for standalone metadata</name>
  <files>backend/wanted_search.py</files>
  <action>
  Modify `backend/wanted_search.py` `build_query_from_wanted()` function to handle standalone items.

  Currently the function checks for `sonarr_series_id` (episodes) and `radarr_movie_id` (movies). Add a THIRD path for standalone items, BEFORE the filename fallback.

  In the episode branch (after the Sonarr metadata block, around line 118), add:

  ```python
  # Try standalone metadata if no Sonarr metadata
  if not metadata_available:
      standalone_sid = wanted_item.get("standalone_series_id")
      if standalone_sid:
          try:
              from db.standalone import get_standalone_series
              series = get_standalone_series(standalone_sid)
              if series:
                  query.series_title = series.get("title", "")
                  query.year = series.get("year")
                  query.imdb_id = series.get("imdb_id", "")
                  query.tvdb_id = series.get("tvdb_id")
                  query.tmdb_id = series.get("tmdb_id")
                  query.anilist_id = series.get("anilist_id")
                  # Parse season/episode from wanted item's season_episode field
                  se = wanted_item.get("season_episode", "")
                  if se:
                      import re
                      se_match = re.match(r'S(\d+)E(\d+)', se, re.IGNORECASE)
                      if se_match:
                          query.season = int(se_match.group(1))
                          query.episode = int(se_match.group(2))
                  metadata_available = True
                  logger.debug("Built query from standalone series metadata: %s",
                             query.series_title)
          except Exception as e:
              logger.warning("Failed to get standalone series metadata for wanted %d: %s",
                           wanted_item["id"], e)
  ```

  In the movie branch (after the Radarr metadata block, around line 140), add:

  ```python
  # Try standalone metadata if no Radarr metadata
  if not metadata_available:
      standalone_mid = wanted_item.get("standalone_movie_id")
      if standalone_mid:
          try:
              from db.standalone import get_standalone_movies
              movie = get_standalone_movies(standalone_mid)
              if movie and isinstance(movie, dict):
                  query.title = movie.get("title", "")
                  query.year = movie.get("year")
                  query.imdb_id = movie.get("imdb_id", "")
                  query.tmdb_id = movie.get("tmdb_id")
                  metadata_available = True
                  logger.debug("Built query from standalone movie metadata: %s (%s)",
                             query.title, query.year)
          except Exception as e:
              logger.warning("Failed to get standalone movie metadata for wanted %d: %s",
                           wanted_item["id"], e)
  ```

  The existing filename fallback at the end of the function will still work as the final fallback if standalone metadata is also unavailable.

  Also modify `_parse_filename_for_metadata()` to use guessit when available (the existing function uses regex patterns, but guessit is already a dependency and more robust). Add a comment noting that standalone items typically have metadata from DB, so this fallback is rarely exercised for them:

  At the top of the function, add:
  ```python
  # Try guessit first if available (more robust than regex patterns)
  try:
      from standalone.parser import parse_media_file
      parsed = parse_media_file(file_path)
      if parsed.get("title"):
          return {
              "series_title": parsed["title"] if parsed["type"] == "episode" else "",
              "title": parsed["title"] if parsed["type"] == "movie" else "",
              "season": parsed.get("season"),
              "episode": parsed.get("episode"),
              "year": parsed.get("year"),
          }
  except ImportError:
      pass  # standalone.parser not available, fall through to regex
  ```

  This ensures the existing regex fallback still works if standalone package isn't present, but prefers guessit when available.
  </action>
  <verify>
  ```bash
  cd backend && python -c "
from wanted_search import build_query_from_wanted

# Test with standalone episode item (mocked)
item = {
    'id': 1,
    'item_type': 'episode',
    'file_path': '/media/Show/Show.S01E05.mkv',
    'sonarr_series_id': None,
    'sonarr_episode_id': None,
    'standalone_series_id': None,  # No standalone metadata either
    'target_language': 'de',
    'instance_name': 'standalone',
    'season_episode': 'S01E05',
}
query = build_query_from_wanted(item)
# Should fall back to filename parsing
print(f'Episode query: title={query.series_title or query.title}, S{query.season}E{query.episode}')
assert query.season == 1 or query.episode == 5, f'Season/ep not parsed: S{query.season}E{query.episode}'

# Test with standalone movie item
movie_item = {
    'id': 2,
    'item_type': 'movie',
    'file_path': '/media/The.Matrix.1999.1080p.mkv',
    'radarr_movie_id': None,
    'standalone_movie_id': None,
    'target_language': 'de',
    'instance_name': 'standalone',
}
query2 = build_query_from_wanted(movie_item)
print(f'Movie query: title={query2.title}, year={query2.year}')
print('wanted_search handles standalone items correctly')
"
  ```
  </verify>
  <done>build_query_from_wanted() has three metadata paths: Sonarr/Radarr first, then standalone DB metadata (via standalone_series_id/standalone_movie_id), then filename parsing as final fallback. Filename parsing now uses guessit when available for better accuracy.</done>
</task>

</tasks>

<verification>
- `python -c "from routes.standalone import bp; print(bp.url_prefix)"` prints `/api/v1/standalone`
- `python -c "from routes import register_blueprints; print('includes standalone')"` -- source contains "standalone"
- `python -c "from wanted_search import build_query_from_wanted; print('builds queries')"` -- function exists and handles standalone items
- Standalone items without Sonarr/Radarr IDs still get parsed metadata via standalone DB or filename fallback
</verification>

<success_criteria>
1. Standalone Blueprint at /api/v1/standalone provides full CRUD for watched folders, series listing, movie listing, scan triggers, and status
2. Blueprint is registered in routes/__init__.py alongside other blueprints
3. build_query_from_wanted() enriches standalone items with TMDB/TVDB/AniList IDs from standalone_series/standalone_movies tables
4. Filename fallback uses guessit when available for better parsing accuracy
5. Provider searches for standalone items get the same quality metadata as Sonarr/Radarr items
</success_criteria>

<output>
After completion, create `.planning/phases/05-standalone-mode/05-04-SUMMARY.md`
</output>
