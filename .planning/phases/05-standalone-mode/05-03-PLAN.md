---
phase: 05-standalone-mode
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - backend/standalone/__init__.py
  - backend/standalone/watcher.py
  - backend/standalone/scanner.py
  - backend/wanted_scanner.py
  - backend/app.py
autonomous: true

must_haves:
  truths:
    - "Filesystem watcher detects new video files in configured folders and triggers processing with debounce"
    - "Full directory scanner finds all video files in watched folders and populates standalone_series/standalone_movies tables"
    - "Standalone items appear in wanted_items table with instance_name='standalone' and correct standalone_series_id/standalone_movie_id"
    - "Wanted scanner scan_all() includes standalone items alongside Sonarr/Radarr items"
    - "StandaloneManager starts watcher and initial scan when standalone_enabled=True"
  artifacts:
    - path: "backend/standalone/__init__.py"
      provides: "StandaloneManager singleton with start/stop lifecycle"
      exports: ["StandaloneManager", "get_standalone_manager", "invalidate_standalone_manager"]
    - path: "backend/standalone/watcher.py"
      provides: "MediaFileWatcher with debounce using watchdog Observer"
      exports: ["MediaFileWatcher", "start_watcher", "stop_watcher"]
    - path: "backend/standalone/scanner.py"
      provides: "StandaloneScanner for full directory scans and wanted population"
      exports: ["StandaloneScanner"]
    - path: "backend/wanted_scanner.py"
      provides: "Extended scan_all() that includes _scan_standalone()"
      contains: "_scan_standalone"
    - path: "backend/app.py"
      provides: "StandaloneManager initialization in create_app and _start_schedulers"
      contains: "standalone"
  key_links:
    - from: "backend/standalone/__init__.py"
      to: "backend/standalone/watcher.py"
      via: "MediaFileWatcher instantiation"
      pattern: "MediaFileWatcher"
    - from: "backend/standalone/__init__.py"
      to: "backend/standalone/scanner.py"
      via: "StandaloneScanner instantiation"
      pattern: "StandaloneScanner"
    - from: "backend/standalone/scanner.py"
      to: "backend/db/standalone.py"
      via: "upsert_standalone_series and upsert_wanted_item calls"
      pattern: "upsert_standalone_series|upsert_wanted_item"
    - from: "backend/standalone/scanner.py"
      to: "backend/metadata/__init__.py"
      via: "MetadataResolver for enrichment"
      pattern: "MetadataResolver"
    - from: "backend/wanted_scanner.py"
      to: "backend/standalone/scanner.py"
      via: "_scan_standalone calling scanner.scan_all_folders"
      pattern: "_scan_standalone"
---

<objective>
Build the StandaloneManager, filesystem watcher, directory scanner, and integrate standalone items into the wanted pipeline.

Purpose: This is the core runtime engine of standalone mode -- detecting files, parsing them, resolving metadata, creating standalone series/movies, and feeding them into the existing wanted_items table so they flow through the same search/download/translate pipeline as Sonarr/Radarr items.
Output: `backend/standalone/` package (manager, watcher, scanner), modified `wanted_scanner.py` and `app.py`.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-standalone-mode/05-RESEARCH.md
@.planning/phases/05-standalone-mode/05-01-SUMMARY.md
@backend/standalone/parser.py
@backend/wanted_scanner.py
@backend/app.py
@backend/providers/plugins/watcher.py
@backend/db/standalone.py
@backend/db/wanted.py
@backend/metadata/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: MediaFileWatcher and StandaloneScanner</name>
  <files>backend/standalone/watcher.py, backend/standalone/scanner.py</files>
  <action>
  1. Create `backend/standalone/watcher.py` following the existing plugin watcher pattern (`providers/plugins/watcher.py`) with debounce:

  ```python
  """Filesystem watcher for media directories using watchdog.

  Monitors configured watched folders for new/moved video files.
  Uses debounce (default 10s) and file stability check to handle
  incomplete copies and rapid filesystem events.
  """
  ```

  Class `MediaFileWatcher(PatternMatchingEventHandler)`:
  - Import from `watchdog.observers import Observer` and `watchdog.events import PatternMatchingEventHandler`
  - VIDEO_PATTERNS = ['*.mkv', '*.mp4', '*.avi', '*.m4v', '*.wmv', '*.flv', '*.webm', '*.ts']
  - `__init__(self, on_new_file: callable, debounce_seconds: float = 10.0)`:
    * Call super().__init__ with patterns=VIDEO_PATTERNS, ignore_directories=True, case_sensitive=False
    * Store callback, debounce_seconds
    * `self._pending = {}` -- path -> threading.Timer
    * `self._lock = threading.Lock()`
  - `on_created(self, event)` -- call `_schedule_process(event.src_path)`
  - `on_moved(self, event)` -- call `_schedule_process(event.dest_path)`
  - `_schedule_process(self, path)`:
    * With lock, cancel existing timer for path if any
    * Create new daemon Timer with debounce_seconds, calling `_check_and_process`
    * Store timer in _pending
  - `_check_and_process(self, path)`:
    * Remove from _pending (with lock)
    * File stability check: get file size, sleep 2s, check again. If different, reschedule (file still being written).
    * If stable and file exists, call self.on_new_file(path)
    * Log at info level: "Detected new media file: {path}"

  Module-level functions:
  - `_observer: Optional[Observer] = None` -- module singleton
  - `start_watcher(folders: list[str], on_new_file: callable, debounce_seconds: float = 10.0) -> Observer`:
    * Create Observer, create MediaFileWatcher handler
    * For each folder path, `observer.schedule(handler, path=folder, recursive=True)`
    * `observer.start()`, store in `_observer`
    * Return observer
  - `stop_watcher()` -- stop and join the observer if running
  - `restart_watcher(folders, on_new_file, debounce_seconds)` -- stop then start

  IMPORTANT: Wrap watchdog imports in try/except ImportError. If watchdog not available, `start_watcher` should log a warning and return None (graceful degradation, same pattern as plugin watcher).

  2. Create `backend/standalone/scanner.py` -- full directory scanner:

  ```python
  """Standalone directory scanner -- scans watched folders for media files.

  Walks configured directories, parses filenames, resolves metadata,
  creates standalone_series/standalone_movies entries, and populates
  wanted_items for files missing target language subtitles.
  """
  ```

  Class `StandaloneScanner`:
  - `__init__(self, metadata_resolver=None)`:
    * Store resolver (created lazily from config if None)
    * `self._scan_lock = threading.Lock()`
    * `self._scanning = False`

  - `_get_resolver(self) -> MetadataResolver`:
    * If self._resolver is None, create from config: `MetadataResolver(tmdb_key=settings.tmdb_api_key, tvdb_key=settings.tvdb_api_key, tvdb_pin=settings.tvdb_pin)`
    * Return resolver

  - `scan_all_folders(self) -> dict`:
    * Acquire _scan_lock (non-blocking, skip if already scanning)
    * Get all enabled watched_folders from DB
    * For each folder, call `_scan_folder(folder)`
    * Cleanup: remove wanted items whose files no longer exist for standalone items
    * Return summary {folders_scanned, series_found, movies_found, wanted_added, duration_seconds}

  - `_scan_folder(self, folder: dict) -> tuple[int, int, int]`:
    * Walk directory tree with os.walk
    * Filter for video files using `standalone.parser.is_video_file`
    * Parse each file with `standalone.parser.parse_media_file`
    * Group files by series using `standalone.parser.group_files_by_series`
    * For each group: create/update standalone_series or standalone_movie
    * For each file: check for missing target language subtitles
    * Return (series_count, movie_count, wanted_count)

  - `_process_series_group(self, title: str, files: list[dict], folder: dict) -> int`:
    * Resolve metadata for the series title
    * Upsert standalone_series
    * For each episode file: check for target language subtitle using existing `detect_existing_target_for_lang` from translator.py
    * If missing: call `upsert_wanted_item` with item_type="episode", instance_name="standalone", standalone_series_id=series_id
    * Return count of wanted items added

  - `_process_movie(self, parsed: dict, file_path: str, folder: dict) -> int`:
    * Resolve metadata for movie title
    * Upsert standalone_movie
    * Check for target language subtitle
    * If missing: call `upsert_wanted_item` with item_type="movie", instance_name="standalone", standalone_movie_id=movie_id
    * Return 1 if wanted, 0 if not

  - `process_single_file(self, file_path: str) -> dict`:
    * Parse the file
    * Resolve metadata
    * Create/update standalone entry
    * Check for subtitle, create wanted item if missing
    * Return {type, title, wanted: bool}
    * This is called by the watcher's on_new_file callback

  For target language detection: import and use `detect_existing_target_for_lang` from translator.py and `get_default_profile` from db.profiles. Use the default profile's target languages.

  Rate limit protection for metadata lookups: batch lookups by unique series title (NOT per-episode). Each unique title gets ONE metadata lookup.
  </action>
  <verify>
  ```bash
  cd backend && python -c "
from standalone.watcher import MediaFileWatcher, start_watcher, stop_watcher
from standalone.scanner import StandaloneScanner

# Verify watcher classes exist
handler = MediaFileWatcher(lambda path: print(f'New: {path}'), debounce_seconds=1.0)
assert hasattr(handler, 'on_created')
assert hasattr(handler, 'on_moved')
assert hasattr(handler, '_check_and_process')
print('MediaFileWatcher methods present')

# Verify scanner
scanner = StandaloneScanner()
assert hasattr(scanner, 'scan_all_folders')
assert hasattr(scanner, 'process_single_file')
assert hasattr(scanner, '_scan_folder')
print('StandaloneScanner methods present')
print('Watcher and Scanner import correctly')
"
  ```
  </verify>
  <done>MediaFileWatcher monitors directories with watchdog Observer and debounced file processing with stability checks. StandaloneScanner walks directories, parses files, resolves metadata, creates standalone entries, and populates wanted_items. Both handle errors gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: StandaloneManager singleton and wanted_scanner/app.py integration</name>
  <files>backend/standalone/__init__.py, backend/wanted_scanner.py, backend/app.py</files>
  <action>
  1. Replace the minimal `backend/standalone/__init__.py` with the full StandaloneManager (following mediaserver/__init__.py singleton pattern):

  ```python
  """Standalone mode package -- folder-watch operation without Sonarr/Radarr.

  StandaloneManager is the singleton orchestrator that owns the watcher,
  scanner, and metadata resolver. It starts/stops based on standalone_enabled config.
  """
  ```

  Module-level singleton:
  - `_manager: Optional[StandaloneManager] = None`
  - `_manager_lock = threading.Lock()`
  - `get_standalone_manager() -> StandaloneManager` -- double-checked locking singleton
  - `invalidate_standalone_manager()` -- stop and reset (for config changes)

  Class `StandaloneManager`:
  - `__init__(self)`:
    * `self._scanner = StandaloneScanner()` -- create scanner
    * `self._watcher_running = False`
    * `self._socketio = None`

  - `start(self, socketio=None)`:
    * Store socketio reference for WebSocket events
    * Get settings, check standalone_enabled
    * If not enabled, log info and return
    * Get enabled watched_folders from DB
    * If no folders, log info and return
    * Start watcher with folder paths using `start_watcher()`
    * Run initial scan in background thread: `threading.Thread(target=self._initial_scan, daemon=True).start()`
    * Log info: "Standalone mode started: watching {n} folders"

  - `stop(self)`:
    * Stop watcher via `stop_watcher()`
    * Set _watcher_running = False

  - `_initial_scan(self)`:
    * Call scanner.scan_all_folders()
    * Emit WebSocket event if socketio available: `socketio.emit("standalone_scan_complete", summary)`
    * Log summary

  - `_on_new_file(self, path: str)`:
    * This is the callback passed to start_watcher
    * Call scanner.process_single_file(path)
    * Emit WebSocket event if socketio: `socketio.emit("standalone_file_detected", {path, ...result})`

  - `reload(self)`:
    * Stop and restart with new config (called after config changes)

  - `get_status(self) -> dict`:
    * Return {enabled, watcher_running, folders_count, scanner_scanning}

  2. Modify `backend/wanted_scanner.py` -- add `_scan_standalone()` method to WantedScanner class:

  In `scan_all()` method, AFTER the Radarr scan block (around line 130) and BEFORE the cleanup, add:

  ```python
  # Scan standalone items (if standalone mode enabled)
  try:
      from config import get_settings
      if getattr(get_settings(), 'standalone_enabled', False):
          from standalone.scanner import StandaloneScanner
          sa, su, sp = self._scan_standalone()
          added += sa
          updated += su
          scanned_paths.update(sp)
  except Exception as e:
      logger.error("Wanted scan: Standalone error: %s", e)
  ```

  Add `_scan_standalone(self) -> tuple[int, int, set]` method:
  - Create StandaloneScanner if not cached
  - Call scanner.scan_all_folders()
  - Extract added/updated counts from summary
  - Collect scanned file paths from standalone series/movies in DB
  - Return (added, updated, scanned_paths)

  Also update `_cleanup()` to handle standalone items: when cleaning up stale wanted items, include items where instance_name="standalone" and file no longer exists. Do NOT delete standalone wanted items during Sonarr/Radarr-specific cleanup.

  3. Modify `backend/app.py` -- add standalone manager initialization:

  In `create_app()`, AFTER the media server manager initialization block and BEFORE the blueprints registration, add:

  ```python
  # Initialize standalone manager (folder watching + scanning)
  try:
      from config import get_settings as _get_standalone_settings
      if getattr(_get_standalone_settings(), 'standalone_enabled', False):
          from standalone import get_standalone_manager
          standalone_mgr = get_standalone_manager()
          logger.info("Standalone manager initialized")
  except Exception as e:
      logger.warning("Standalone manager initialization failed: %s", e)
  ```

  In `_start_schedulers(settings)`, AFTER the backup scheduler, add:

  ```python
  # Start standalone watcher if enabled
  if getattr(settings, 'standalone_enabled', False):
      try:
          from standalone import get_standalone_manager
          standalone_mgr = get_standalone_manager()
          standalone_mgr.start(socketio=socketio)
      except Exception as e:
          logging.getLogger(__name__).warning("Standalone watcher start failed: %s", e)
  ```
  </action>
  <verify>
  ```bash
  cd backend && python -c "
from standalone import get_standalone_manager, invalidate_standalone_manager, StandaloneManager

# Verify singleton
mgr1 = get_standalone_manager()
mgr2 = get_standalone_manager()
assert mgr1 is mgr2, 'Singleton broken'
print('Singleton works')

# Verify methods
assert hasattr(mgr1, 'start')
assert hasattr(mgr1, 'stop')
assert hasattr(mgr1, 'reload')
assert hasattr(mgr1, 'get_status')
print('StandaloneManager methods present')

# Verify status
status = mgr1.get_status()
assert 'enabled' in status
assert 'watcher_running' in status
print(f'Status: {status}')

# Cleanup
invalidate_standalone_manager()
print('Manager invalidated successfully')

# Verify wanted_scanner has standalone support
from wanted_scanner import WantedScanner
scanner = WantedScanner()
assert hasattr(scanner, '_scan_standalone'), 'Missing _scan_standalone method'
print('WantedScanner has _scan_standalone')
print('All integration checks pass')
"
  ```
  </verify>
  <done>StandaloneManager singleton manages watcher lifecycle and initial scan. WantedScanner.scan_all() includes _scan_standalone() for standalone items alongside Sonarr/Radarr. app.py initializes standalone manager and starts watcher in _start_schedulers when standalone_enabled=True.</done>
</task>

</tasks>

<verification>
- `python -c "from standalone import get_standalone_manager; print('Manager imports')"` succeeds
- `python -c "from standalone.watcher import start_watcher; print('Watcher imports')"` succeeds
- `python -c "from standalone.scanner import StandaloneScanner; print('Scanner imports')"` succeeds
- StandaloneManager.get_status() returns dict with enabled, watcher_running, folders_count
- WantedScanner has _scan_standalone method
- app.py contains standalone initialization in create_app and _start_schedulers
</verification>

<success_criteria>
1. MediaFileWatcher uses watchdog Observer with debounce and file stability checks
2. StandaloneScanner walks directories, groups files into series, resolves metadata, creates standalone entries, and populates wanted_items
3. StandaloneManager singleton orchestrates watcher and scanner lifecycle
4. wanted_scanner.scan_all() includes standalone items when standalone_enabled=True
5. app.py starts standalone manager in create_app and watcher in _start_schedulers
6. All components handle errors gracefully and use logging
</success_criteria>

<output>
After completion, create `.planning/phases/05-standalone-mode/05-03-SUMMARY.md`
</output>
