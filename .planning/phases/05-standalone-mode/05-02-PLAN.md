---
phase: 05-standalone-mode
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/metadata/__init__.py
  - backend/metadata/tmdb_client.py
  - backend/metadata/anilist_client.py
  - backend/metadata/tvdb_client.py
autonomous: true

must_haves:
  truths:
    - "TMDB client can search for TV series and movies by title and retrieve details"
    - "AniList client can search for anime by title and return romaji/english/native titles"
    - "TVDB client can search for series with JWT auth and retrieve episode lists"
    - "MetadataResolver orchestrates the lookup chain (AniList for anime, TMDB primary, TVDB fallback) and returns normalized results"
  artifacts:
    - path: "backend/metadata/__init__.py"
      provides: "MetadataResolver orchestrating TMDB/AniList/TVDB lookup chain"
      exports: ["MetadataResolver"]
    - path: "backend/metadata/tmdb_client.py"
      provides: "TMDB API v3 client with search and detail endpoints"
      exports: ["TMDBClient"]
    - path: "backend/metadata/anilist_client.py"
      provides: "AniList GraphQL client for anime metadata"
      exports: ["AniListClient"]
    - path: "backend/metadata/tvdb_client.py"
      provides: "TVDB API v4 client with JWT auth"
      exports: ["TVDBClient"]
  key_links:
    - from: "backend/metadata/__init__.py"
      to: "backend/metadata/tmdb_client.py"
      via: "TMDBClient instantiation"
      pattern: "TMDBClient"
    - from: "backend/metadata/__init__.py"
      to: "backend/metadata/anilist_client.py"
      via: "AniListClient instantiation"
      pattern: "AniListClient"
    - from: "backend/metadata/__init__.py"
      to: "backend/metadata/tvdb_client.py"
      via: "TVDBClient instantiation (optional)"
      pattern: "TVDBClient"
---

<objective>
Create the metadata lookup package with TMDB, AniList, and TVDB API clients plus MetadataResolver orchestrator.

Purpose: Enable structured metadata enrichment for standalone-detected media files. TMDB is the primary source for general media, AniList is primary for anime, TVDB is an optional fallback.
Output: `backend/metadata/` package with 4 files: `__init__.py` (MetadataResolver), `tmdb_client.py`, `anilist_client.py`, `tvdb_client.py`.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-standalone-mode/05-RESEARCH.md
@backend/sonarr_client.py
@backend/radarr_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: TMDB and AniList API clients</name>
  <files>backend/metadata/tmdb_client.py, backend/metadata/anilist_client.py</files>
  <action>
  1. Create `backend/metadata/tmdb_client.py` -- TMDB API v3 client using raw requests (following sonarr_client.py pattern of raw HTTP calls, NOT using a wrapper library):

  Class `TMDBClient`:
  - `__init__(self, api_key: str)` -- store key, create `requests.Session()` with `Authorization: Bearer {api_key}` header and reasonable timeout (15s)
  - `search_tv(self, query: str, year: int = None) -> dict | None` -- GET `/3/search/tv` with query, language=en-US, page=1, optional first_air_date_year. Return first result or None.
  - `search_movie(self, query: str, year: int = None) -> dict | None` -- GET `/3/search/movie` with query, language=en-US, page=1, optional year. Return first result or None.
  - `get_tv_details(self, tv_id: int) -> dict` -- GET `/3/tv/{tv_id}` with language=en-US. Return full details dict.
  - `get_tv_external_ids(self, tv_id: int) -> dict` -- GET `/3/tv/{tv_id}/external_ids`. Returns {imdb_id, tvdb_id, ...}.
  - `get_tv_season(self, tv_id: int, season_number: int) -> dict` -- GET `/3/tv/{tv_id}/season/{season_number}`. Returns season with episodes list.
  - `get_movie_details(self, movie_id: int) -> dict` -- GET `/3/movie/{movie_id}`. Return full details.
  - `get_movie_external_ids(self, movie_id: int) -> dict` -- GET `/3/movie/{movie_id}/external_ids`.

  BASE_URL = "https://api.themoviedb.org"
  All methods: try/except requests.RequestException, log errors with logger.warning, return None on failure (don't crash).
  Add `_get(self, path, params=None)` private helper to DRY the HTTP calls.

  2. Create `backend/metadata/anilist_client.py` -- AniList GraphQL client (no API key required):

  Class `AniListClient`:
  - `__init__(self)` -- create `requests.Session()` with timeout 15s
  - `SEARCH_QUERY` class constant -- GraphQL query for searching media by title, returning id, idMal, title (romaji/english/native), format, status, episodes, seasonYear, coverImage { large }, genres
  - `DETAILS_QUERY` class constant -- GraphQL query for getting full details by id, including externalLinks (site, url) and relations
  - `search_anime(self, title: str) -> dict | None` -- POST to https://graphql.anilist.co with SEARCH_QUERY, variables {search: title, type: "ANIME"}. Return first result or None.
  - `search_manga(self, title: str) -> dict | None` -- same but type: "MANGA" (for light novel adaptations that might appear as manga)
  - `get_details(self, anilist_id: int) -> dict | None` -- POST with DETAILS_QUERY, variable {id: anilist_id}. Return media object or None.

  ANILIST_URL = "https://graphql.anilist.co"
  Rate limit: 90 req/min. Add 0.7s sleep between calls using `time.sleep(0.7)` in a `_query(self, query, variables)` helper method (conservative approach).
  All methods: try/except requests.RequestException, log errors, return None on failure.
  </action>
  <verify>
  ```bash
  cd backend && python -c "
from metadata.tmdb_client import TMDBClient
from metadata.anilist_client import AniListClient
# Verify classes import and construct
tmdb = TMDBClient('test-key')
print(f'TMDBClient created: base_url={tmdb.BASE_URL}')
anilist = AniListClient()
print(f'AniListClient created: url={anilist.ANILIST_URL}')
# Verify methods exist
assert hasattr(tmdb, 'search_tv')
assert hasattr(tmdb, 'search_movie')
assert hasattr(tmdb, 'get_tv_details')
assert hasattr(tmdb, 'get_tv_external_ids')
assert hasattr(anilist, 'search_anime')
assert hasattr(anilist, 'get_details')
print('All methods present')
# Without real API keys, calls should return None gracefully (not crash)
result = tmdb.search_tv('test')
print(f'TMDB search with bad key: {result} (expected None or error, not crash)')
print('Clients import and construct correctly')
"
  ```
  </verify>
  <done>TMDBClient has search_tv, search_movie, get_tv_details, get_tv_external_ids, get_tv_season, get_movie_details, get_movie_external_ids methods. AniListClient has search_anime, get_details methods with rate limiting. Both gracefully handle errors (return None, don't crash).</done>
</task>

<task type="auto">
  <name>Task 2: TVDB client and MetadataResolver orchestrator</name>
  <files>backend/metadata/tvdb_client.py, backend/metadata/__init__.py</files>
  <action>
  1. Create `backend/metadata/tvdb_client.py` -- TVDB API v4 client with JWT auth:

  Class `TVDBClient`:
  - `__init__(self, api_key: str, pin: str = "")` -- store key and pin, create session, init _token="" and _token_expires=0
  - `_ensure_auth(self)` -- POST to `/v4/login` with {apikey, pin} if token empty/expired. Store token in session headers as Bearer. Token validity 24h. Log warning on auth failure (don't crash).
  - `search_series(self, query: str, year: int = None) -> dict | None` -- GET `/v4/search` with query=query, type=series, optional year. Return first result or None.
  - `get_series(self, series_id: int) -> dict` -- GET `/v4/series/{series_id}`. Return data dict.
  - `get_series_episodes(self, series_id: int, page: int = 0) -> dict` -- GET `/v4/series/{series_id}/episodes/default` with page param.
  - `search_movie(self, query: str, year: int = None) -> dict | None` -- GET `/v4/search` with query=query, type=movie.

  BASE_URL = "https://api4.thetvdb.com"
  All methods call `_ensure_auth()` first. try/except requests.RequestException, return None on failure.

  2. Create `backend/metadata/__init__.py` -- MetadataResolver orchestrator:

  ```python
  """Metadata package -- TMDB, AniList, and TVDB API clients with resolver.

  MetadataResolver orchestrates lookups across all three providers with
  caching via the metadata_cache DB table.
  """
  ```

  Class `MetadataResolver`:
  - `__init__(self, tmdb_key: str = "", tvdb_key: str = "", tvdb_pin: str = "")` -- create client instances lazily (only if keys provided). AniList always available (no key needed).
  - `_tmdb` property -- lazy TMDBClient creation (None if no key)
  - `_anilist` property -- lazy AniListClient creation (always available)
  - `_tvdb` property -- lazy TVDBClient creation (None if no key)

  - `resolve_series(self, title: str, year: int = None, is_anime: bool = False) -> dict` -- the main lookup chain:
    1. Check metadata_cache (via db.standalone.get_cached_metadata) using cache_key = f"series:{title.lower()}:{year or ''}"
    2. If cache hit, return cached result
    3. If is_anime and AniList available: search AniList first
    4. If TMDB available: search TMDB (get details + external IDs for TVDB/IMDB cross-reference)
    5. If TVDB available and nothing found: search TVDB as fallback
    6. Normalize result into standard dict: {title, year, tmdb_id, tvdb_id, anilist_id, imdb_id, poster_url, is_anime, episode_count, season_count, metadata_source}
    7. Cache result via db.standalone.cache_metadata
    8. Return result (return {title, year, metadata_source: "filename"} if all lookups fail)

  - `resolve_movie(self, title: str, year: int = None) -> dict` -- similar chain but for movies:
    1. Check cache with key f"movie:{title.lower()}:{year or ''}"
    2. TMDB search_movie -> get_movie_details -> get_movie_external_ids
    3. Normalize: {title, year, tmdb_id, imdb_id, poster_url, metadata_source}
    4. Cache and return

  - `_normalize_tmdb_tv(self, search_result: dict, details: dict = None, external_ids: dict = None) -> dict` -- private normalizer
  - `_normalize_anilist(self, result: dict) -> dict` -- private normalizer
  - `_normalize_tvdb(self, result: dict) -> dict` -- private normalizer
  - `_normalize_tmdb_movie(self, search_result: dict, details: dict = None, external_ids: dict = None) -> dict`

  IMPORTANT: The DB cache calls (get_cached_metadata, cache_metadata) should be wrapped in try/except to handle cases where db is not initialized (e.g., during testing without full app context). If DB not available, skip caching and proceed with API calls.

  Poster URL: TMDB uses `https://image.tmdb.org/t/p/w500{poster_path}`, AniList uses `coverImage.large` directly.
  </action>
  <verify>
  ```bash
  cd backend && python -c "
from metadata.tvdb_client import TVDBClient
from metadata import MetadataResolver

# Verify TVDB client
tvdb = TVDBClient('test-key')
assert hasattr(tvdb, 'search_series')
assert hasattr(tvdb, 'get_series')
assert hasattr(tvdb, 'get_series_episodes')
print('TVDBClient methods present')

# Verify MetadataResolver
resolver = MetadataResolver()
assert hasattr(resolver, 'resolve_series')
assert hasattr(resolver, 'resolve_movie')
print('MetadataResolver methods present')

# Test with no API keys -- should return filename fallback
result = resolver.resolve_series('Test Show', year=2024)
assert result.get('metadata_source') == 'filename', f'Expected filename source, got {result}'
print(f'No-key fallback: {result}')

# Test with keys but no network -- should handle gracefully
resolver2 = MetadataResolver(tmdb_key='invalid')
result2 = resolver2.resolve_series('Test Show')
print(f'Invalid key result: {result2.get(\"metadata_source\")}')
print('MetadataResolver works correctly')
"
  ```
  </verify>
  <done>TVDBClient has search_series, get_series, get_series_episodes with JWT auth. MetadataResolver orchestrates AniList-first-for-anime, TMDB-primary, TVDB-fallback lookup chain with DB-backed caching. All clients handle errors gracefully (return None/fallback, never crash).</done>
</task>

</tasks>

<verification>
- `python -c "from metadata import MetadataResolver; print('Package imports')"` succeeds
- `python -c "from metadata.tmdb_client import TMDBClient; print('TMDB imports')"` succeeds
- `python -c "from metadata.anilist_client import AniListClient; print('AniList imports')"` succeeds
- `python -c "from metadata.tvdb_client import TVDBClient; print('TVDB imports')"` succeeds
- MetadataResolver with no keys returns filename fallback for resolve_series/resolve_movie
- All clients handle network errors gracefully (no unhandled exceptions)
</verification>

<success_criteria>
1. TMDBClient provides search and detail methods for both TV and movie content using Bearer token auth
2. AniListClient provides anime search via GraphQL with rate limiting (0.7s between calls)
3. TVDBClient provides series search with JWT authentication and automatic token refresh
4. MetadataResolver orchestrates the correct lookup chain: AniList first for anime, TMDB primary, TVDB fallback
5. Results are normalized to a consistent dict format regardless of source
6. All clients handle errors gracefully (return None, log warning, never crash)
</success_criteria>

<output>
After completion, create `.planning/phases/05-standalone-mode/05-02-SUMMARY.md`
</output>
