---
phase: 12-batch-operations-smart-filter
plan: 03
type: execute
wave: 3
depends_on: [12-01, 12-02]
files_modified:
  - frontend/src/pages/Wanted.tsx
  - frontend/src/pages/History.tsx
  - frontend/src/pages/Library.tsx
  - frontend/src/components/layout/Sidebar.tsx
  - frontend/public/locales/en/wanted.json
  - frontend/public/locales/de/wanted.json
  - frontend/public/locales/en/common.json
  - frontend/public/locales/de/common.json
  - backend/tests/test_search.py
  - backend/tests/test_filter_presets.py
autonomous: true

must_haves:
  truths:
    - "Wanted page has FilterBar with status/type/subtitle_type/search filters + sort controls"
    - "Wanted page has per-row checkboxes and BatchActionBar for ignore/unignore/blacklist/export"
    - "History page has FilterBar with provider/format/language/search filters"
    - "History page has per-row checkboxes and BatchActionBar for export"
    - "Library page has a client-side search input and sort controls (no bulk actions — Sonarr-backed)"
    - "Wanted and History pages pass selection state from useSelectionStore (scope per page)"
    - "i18n keys for batch/filter UI added to EN and DE locale files"
    - "Backend tests cover search_all() and FilterPresetsRepository CRUD"
  artifacts:
    - path: "frontend/src/pages/Wanted.tsx"
      provides: "Wanted page with FilterBar + multi-select + BatchActionBar"
      contains: "FilterBar"
    - path: "frontend/src/pages/History.tsx"
      provides: "History page with FilterBar + multi-select"
      contains: "FilterBar"
    - path: "backend/tests/test_search.py"
      provides: "Unit tests for SearchRepository.search_all()"
      contains: "def test_"
    - path: "backend/tests/test_filter_presets.py"
      provides: "Unit tests for FilterPresetsRepository CRUD"
      contains: "def test_"
  key_links:
    - from: "frontend/src/pages/Wanted.tsx"
      to: "frontend/src/components/filters/FilterBar.tsx"
      via: "FilterBar import"
      pattern: "import.*FilterBar"
    - from: "frontend/src/pages/Wanted.tsx"
      to: "frontend/src/components/batch/BatchActionBar.tsx"
      via: "BatchActionBar import"
      pattern: "import.*BatchActionBar"
    - from: "frontend/src/pages/Wanted.tsx"
      to: "frontend/src/stores/selectionStore.ts"
      via: "useSelectionStore"
      pattern: "useSelectionStore"
---

<objective>
Page integration for Phase 12: wire FilterBar, multi-select checkboxes, BatchActionBar, and sort controls into Wanted, History, and Library pages; add i18n translations; write backend unit tests.

Purpose: Complete the user-facing Phase 12 features. After this plan, all four success criteria are met.

Output: 3 updated page files, updated i18n locale files (EN + DE), 2 new backend test files.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-batch-operations-smart-filter/12-RESEARCH.md

@frontend/src/pages/Wanted.tsx
@frontend/src/pages/History.tsx
@frontend/src/pages/Library.tsx
@frontend/src/components/filters/FilterBar.tsx
@frontend/src/components/batch/BatchActionBar.tsx
@frontend/src/stores/selectionStore.ts
@frontend/src/hooks/useApi.ts
@frontend/src/api/client.ts
@frontend/src/lib/types.ts
@backend/tests/test_server.py
@backend/db/repositories/search.py
@backend/db/repositories/presets.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate FilterBar + sort + multi-select into Wanted page</name>
  <files>
    frontend/src/pages/Wanted.tsx
  </files>
  <action>
Read the current `frontend/src/pages/Wanted.tsx` in full before editing.

**Changes to make:**

1. **Add imports:**
```typescript
import { FilterBar } from '@/components/filters/FilterBar'  // adjust path if no @ alias
import { BatchActionBar } from '@/components/batch/BatchActionBar'
import { useSelectionStore } from '@/stores/selectionStore'
import type { FilterGroup, ActiveFilter } from '@/lib/types'  // add ActiveFilter if not exported
```

2. **Add state for active filters and sort:**
```typescript
const SCOPE = 'wanted'
const [activeFilters, setActiveFilters] = useState<ActiveFilter[]>([])
const [sortBy, setSortBy] = useState('added_at')
const [sortDir, setSortDir] = useState<'asc' | 'desc'>('desc')
const [search, setSearch] = useState('')
const { getSelectedArray, getCount, toggleItem, selectAll, clearSelection } = useSelectionStore()
```

3. **Define FilterBar filter definitions for Wanted:**
```typescript
const WANTED_FILTERS = [
  { key: 'status', label: 'Status', type: 'select' as const, options: [
    { value: 'wanted', label: 'Wanted' },
    { value: 'ignored', label: 'Ignored' },
    { value: 'failed', label: 'Failed' },
    { value: 'found', label: 'Found' },
  ]},
  { key: 'item_type', label: 'Type', type: 'select' as const, options: [
    { value: 'episode', label: 'Episode' },
    { value: 'movie', label: 'Movie' },
  ]},
  { key: 'subtitle_type', label: 'Subtitle Type', type: 'select' as const, options: [
    { value: 'full', label: 'Full' },
    { value: 'forced', label: 'Forced' },
  ]},
  { key: 'title', label: 'Title', type: 'text' as const },
]
```

4. **Derive query params from activeFilters:**
Extract the filter values from `activeFilters` to pass to `useWantedItems()`:
```typescript
const filterStatus = activeFilters.find(f => f.key === 'status')?.value
const filterItemType = activeFilters.find(f => f.key === 'item_type')?.value
const filterSubtitleType = activeFilters.find(f => f.key === 'subtitle_type')?.value
const filterSearch = search || activeFilters.find(f => f.key === 'title')?.value
```

Update the `useWantedItems()` call to pass `sort_by=sortBy`, `sort_dir=sortDir`, `search=filterSearch` in addition to existing params. If the hook doesn't yet support these params, update the hook call signature to pass them as extra query params (add them to the queryFn's request params).

5. **Add a search input and sort controls above the table:**
- Add a small text input for `search` state (debounced 300ms using a simple `useEffect + setTimeout`)
- Add sort direction toggle button (↑/↓ icon, clicking toggles `sortDir`)
- Add sort field dropdown with options matching `SORT_FIELDS` from the backend (`added_at`, `title`, `last_search_at`, `current_score`, `search_count`)

6. **Add FilterBar below the existing filter buttons:**
```tsx
<FilterBar
  scope={SCOPE}
  filters={WANTED_FILTERS}
  activeFilters={activeFilters}
  onFiltersChange={setActiveFilters}
  onPresetLoad={(conditions: FilterGroup) => {
    // Convert FilterGroup into activeFilters array (top-level AND conditions only for now)
    if (conditions.logic === 'AND') {
      const filters = conditions.conditions
        .filter((c): c is FilterCondition => 'field' in c)
        .map((c) => {
          const def = WANTED_FILTERS.find(f => f.key === c.field)
          return { key: c.field, op: c.op, value: String(c.value), label: def?.label ?? c.field }
        })
      setActiveFilters(filters)
    }
  }}
/>
```

7. **Add checkboxes to each row:**
In the table's `<thead>`, add a first `<th>` with a "select all" checkbox:
```tsx
<th>
  <input
    type="checkbox"
    checked={getCount(SCOPE) === wantedItems?.data.length && (wantedItems?.data.length ?? 0) > 0}
    onChange={(e) => {
      if (e.target.checked) selectAll(SCOPE, orderedIds)
      else clearSelection(SCOPE)
    }}
  />
</th>
```

In each `<tr>`, add a first `<td>` with a per-row checkbox. Wire `onClick` on the `<tr>` to call `toggleItem(SCOPE, item.id, index, e.shiftKey, orderedIds)`.

8. **Add BatchActionBar at the bottom of the page (outside the table):**
```tsx
<BatchActionBar scope={SCOPE} actions={['ignore', 'unignore', 'blacklist', 'export']} />
```

**Important:** Do not remove any existing functionality. The existing filter buttons (all/wanted/failed/ignored, all/episode/movie) can coexist with the new FilterBar — they update the same state variables.

**Reset page to 1 when filters change** (add to the `onFiltersChange` handler).
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep "Wanted"` — no type errors in Wanted.tsx.
`cd frontend && npm run lint 2>&1 | grep "Wanted.tsx"` — no lint errors.
  </verify>
  <done>
Wanted.tsx has FilterBar with 4 filter defs, search input, sort controls, per-row checkboxes with Shift+click via selectionStore, BatchActionBar at the bottom. No existing functionality removed. TypeScript clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FilterBar + multi-select into History page</name>
  <files>
    frontend/src/pages/History.tsx
  </files>
  <action>
Read `frontend/src/pages/History.tsx` in full before editing.

**Changes to make:**

1. Add imports for `FilterBar`, `BatchActionBar`, `useSelectionStore`.

2. Add `SCOPE = 'history'` constant and active filters state.

3. Define filter defs for History:
```typescript
const HISTORY_FILTERS = [
  { key: 'provider', label: 'Provider', type: 'select' as const, options: [
    { value: 'animetosho', label: 'AnimeTosho' },
    { value: 'jimaku',     label: 'Jimaku' },
    { value: 'opensubtitles', label: 'OpenSubtitles' },
    { value: 'subdl',      label: 'SubDL' },
  ]},
  { key: 'format', label: 'Format', type: 'select' as const, options: [
    { value: 'ass', label: 'ASS' },
    { value: 'srt', label: 'SRT' },
  ]},
  { key: 'language', label: 'Language', type: 'text' as const },
  { key: 'file_path', label: 'File Path', type: 'text' as const },
]
```

4. Wire filter values into the `useDownloadHistory()` (or equivalent) hook call. Pass `format`, `language`, `search` from activeFilters.

5. Add FilterBar below the existing provider filter buttons.

6. Add per-row checkboxes and `BatchActionBar` with `actions={['export']}` (History has export only — no ignore/blacklist for history records).

7. **Do NOT remove existing provider filter buttons** — they coexist with FilterBar.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep "History"` — no type errors in History.tsx.
  </verify>
  <done>
History.tsx has FilterBar with provider/format/language/file_path filters, per-row checkboxes, BatchActionBar with export-only actions. Existing UI unchanged. TypeScript clean.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add search input and sort controls to Library page</name>
  <files>
    frontend/src/pages/Library.tsx
  </files>
  <action>
Read `frontend/src/pages/Library.tsx` in full before editing.

**Scope note:** Library is Sonarr-backed live data — it does not have a DB-backed filterable endpoint. The phase bulk-action success criterion (SC-1) is satisfied by Wanted + History pages. Library scope in this task is **search + sort only**.

1. **Client-side search:** Add a text input that filters the displayed series list by title:
```tsx
const [search, setSearch] = useState('')
const filteredSeries = series?.filter((s) =>
  s.title.toLowerCase().includes(search.toLowerCase())
) ?? []
```

2. **Sort controls:** Verify the existing sort by `title | missing | episodes` with `asc/desc` is wired. If sort state exists in the component but is NOT passed to the API call, wire it in.

3. **Add a search input** at the top of the Library page (alongside existing filter tabs):
```tsx
<input
  type="text"
  placeholder="Search series..."
  value={search}
  onChange={(e) => setSearch(e.target.value)}
  className="px-3 py-1.5 text-sm bg-background border border-border rounded-lg outline-none w-52 focus:border-teal-500"
/>
```
Apply the `filteredSeries` array to the rendered list instead of the raw API response. Do NOT modify the Sonarr API call.

**Do NOT add checkboxes or BatchActionBar to the Library page.** Library is read-only from a batch-action perspective — the Sonarr API is the source of truth, and there is no `POST /library/batch-action` backend endpoint. Bulk operations on library items (e.g., assign a profile to multiple series) are a post-Phase-12 enhancement.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep "Library"` — no type errors in Library.tsx.
  </verify>
  <done>
Library.tsx has a search input that filters the displayed series list client-side by title. Sort controls are correctly wired to the API (if they weren't before). No checkboxes, no BatchActionBar — Library is search+sort only in Phase 12. No existing functionality regressed.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire GlobalSearchModal into app layout</name>
  <files>
    frontend/src/App.tsx
    frontend/src/components/layout/Sidebar.tsx
  </files>
  <action>
Read `frontend/src/App.tsx` and `frontend/src/components/layout/Sidebar.tsx`.

**Goal:** The GlobalSearchModal (from Plan 02) must be accessible app-wide.

1. In `App.tsx` (or the root layout component that wraps all pages), add:
```tsx
import { useState } from 'react'
import { GlobalSearchModal } from '@/components/search/GlobalSearchModal'

// Inside the component:
const [searchOpen, setSearchOpen] = useState(false)

// Ctrl+K handler in a useEffect
useEffect(() => {
  const handler = (e: KeyboardEvent) => {
    if (e.key === 'k' && (e.metaKey || e.ctrlKey)) {
      e.preventDefault()
      setSearchOpen((v) => !v)
    }
  }
  document.addEventListener('keydown', handler)
  return () => document.removeEventListener('keydown', handler)
}, [])

// In JSX:
<GlobalSearchModal open={searchOpen} onOpenChange={setSearchOpen} />
```

2. In `Sidebar.tsx`, add a search trigger button:
- Find the sidebar header area
- Add a button with a Search icon and "Ctrl+K" / "⌘K" hint that calls `setSearchOpen(true)`
- This requires passing `onSearchOpen` as a prop to Sidebar, or using a shared state mechanism

If `Sidebar` is rendered inside the same component as `App.tsx`, pass `onSearchOpen` as a prop.
If the layout structure is different (e.g., `Layout.tsx` is the root), wire it there instead.

**Do not duplicate the Ctrl+K handler** — it must exist in exactly one place.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep -E "App\.tsx|Sidebar\.tsx"` — no new type errors.
App loads in browser (if dev server is running): GlobalSearchModal is rendered in the DOM.
  </verify>
  <done>
GlobalSearchModal mounted at the app root. Ctrl+K handler wired exactly once. Optional search button in Sidebar triggers the modal. No type errors.
  </done>
</task>

<task type="auto">
  <name>Task 5: i18n translations for batch/filter UI</name>
  <files>
    frontend/public/locales/en/common.json
    frontend/public/locales/de/common.json
    frontend/public/locales/en/wanted.json
    frontend/public/locales/de/wanted.json
  </files>
  <action>
Read the existing locale files to understand the current structure and key naming conventions.

**Add to `en/common.json`** (under a `"batch"` or `"filters"` section):
```json
"filters": {
  "addFilter": "Add filter",
  "clearAll": "Clear all",
  "presets": "Presets",
  "saveCurrentFilters": "Save current filters",
  "presetName": "Preset name...",
  "noPresets": "No saved presets"
},
"batch": {
  "itemsSelected": "{{count}} selected",
  "ignore": "Ignore",
  "unignore": "Unignore",
  "blacklist": "Blacklist",
  "export": "Export",
  "clearSelection": "Clear selection"
},
"search": {
  "placeholder": "Search series, episodes, subtitles...",
  "shortcut": "Ctrl+K",
  "noResults": "No results for \"{{query}}\"",
  "minChars": "Type at least 2 characters to search...",
  "series": "Series",
  "episodes": "Episodes",
  "subtitles": "Subtitles"
}
```

**Add to `de/common.json`** (German translations):
```json
"filters": {
  "addFilter": "Filter hinzufügen",
  "clearAll": "Alle löschen",
  "presets": "Voreinstellungen",
  "saveCurrentFilters": "Aktuelle Filter speichern",
  "presetName": "Name der Voreinstellung...",
  "noPresets": "Keine Voreinstellungen gespeichert"
},
"batch": {
  "itemsSelected": "{{count}} ausgewählt",
  "ignore": "Ignorieren",
  "unignore": "Aktivieren",
  "blacklist": "Sperrliste",
  "export": "Exportieren",
  "clearSelection": "Auswahl aufheben"
},
"search": {
  "placeholder": "Serien, Episoden, Untertitel suchen...",
  "shortcut": "Strg+K",
  "noResults": "Keine Ergebnisse für \"{{query}}\"",
  "minChars": "Mindestens 2 Zeichen eingeben...",
  "series": "Serien",
  "episodes": "Episoden",
  "subtitles": "Untertitel"
}
```

**Add to `en/wanted.json` and `de/wanted.json`:**
```json
"sortBy": "Sort by",
"sortFields": {
  "added_at": "Date added",
  "title": "Title",
  "last_search_at": "Last searched",
  "current_score": "Score",
  "search_count": "Search count"
}
```
German: `"sortBy": "Sortieren nach"`, `"sortFields": { "added_at": "Hinzugefügt", "title": "Titel", ... }`

Verify the JSON is valid after editing: no trailing commas, correct nesting.
  </action>
  <verify>
`python3 -c "import json; json.load(open('frontend/public/locales/en/common.json')); print('EN OK')"` succeeds.
`python3 -c "import json; json.load(open('frontend/public/locales/de/common.json')); print('DE OK')"` succeeds.
  </verify>
  <done>
EN and DE translations added for filters.*, batch.*, search.* in common.json. Sort field translations in wanted.json. All JSON files valid.
  </done>
</task>

<task type="auto">
  <name>Task 6: Backend tests — SearchRepository and FilterPresetsRepository</name>
  <files>
    backend/tests/test_search.py
    backend/tests/test_filter_presets.py
  </files>
  <action>
Read `backend/tests/test_server.py` or any existing test file to understand the test setup pattern (fixtures, app factory, db session setup).

**Create `backend/tests/test_search.py`:**

```python
"""Tests for SearchRepository FTS5 search."""

import pytest
from app import create_app
from extensions import db as _db
from db.repositories.search import SearchRepository


@pytest.fixture()
def app():
    app = create_app()
    app.config["TESTING"] = True
    app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
    with app.app_context():
        _db.create_all()
        from db.repositories.search import SearchRepository
        repo = SearchRepository()
        repo.init_search_tables()
        yield app


@pytest.fixture()
def search_repo(app):
    with app.app_context():
        return SearchRepository()


def test_search_empty_query(search_repo):
    """Short query returns empty results without error."""
    result = search_repo.search_all("a")
    assert result == {"series": [], "episodes": [], "subtitles": []}


def test_search_no_results(search_repo):
    """Query with no matching data returns empty lists."""
    result = search_repo.search_all("xyznonexistent")
    assert "series" in result
    assert "episodes" in result
    assert "subtitles" in result
    assert all(len(v) == 0 for v in result.values())


def test_search_result_structure(search_repo):
    """search_all always returns the three expected keys."""
    result = search_repo.search_all("test")
    assert set(result.keys()) == {"series", "episodes", "subtitles"}


def test_search_limit_respected(search_repo):
    """Limit parameter bounds the result count."""
    result = search_repo.search_all("a", limit=5)
    assert len(result["series"]) <= 5
    assert len(result["episodes"]) <= 5
    assert len(result["subtitles"]) <= 5
```

**Create `backend/tests/test_filter_presets.py`:**

```python
"""Tests for FilterPresetsRepository CRUD and validation."""

import pytest
from app import create_app
from extensions import db as _db
from db.repositories.presets import FilterPresetsRepository


@pytest.fixture()
def app():
    app = create_app()
    app.config["TESTING"] = True
    app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
    with app.app_context():
        _db.create_all()
        yield app


@pytest.fixture()
def repo(app):
    with app.app_context():
        return FilterPresetsRepository()


def test_create_and_list_preset(repo):
    """Created preset appears in list for correct scope."""
    conditions = {"logic": "AND", "conditions": [{"field": "status", "op": "eq", "value": "wanted"}]}
    preset = repo.create_preset("My Filter", "wanted", conditions)
    assert preset["name"] == "My Filter"
    assert preset["scope"] == "wanted"

    presets = repo.list_presets("wanted")
    assert len(presets) == 1
    assert presets[0]["id"] == preset["id"]


def test_list_presets_scope_isolation(repo):
    """Presets for 'wanted' scope don't appear in 'history' scope."""
    conditions = {"logic": "AND", "conditions": []}
    repo.create_preset("Wanted filter", "wanted", conditions)
    history_presets = repo.list_presets("history")
    assert len(history_presets) == 0


def test_delete_preset(repo):
    """Deleted preset no longer appears in list."""
    conditions = {"logic": "AND", "conditions": []}
    preset = repo.create_preset("To delete", "wanted", conditions)
    assert repo.delete_preset(preset["id"]) is True
    assert len(repo.list_presets("wanted")) == 0


def test_delete_nonexistent_preset(repo):
    """Deleting a non-existent preset returns False."""
    assert repo.delete_preset(9999) is False


def test_invalid_field_raises(repo):
    """Conditions with invalid field name raise ValueError."""
    bad_conditions = {"logic": "AND", "conditions": [
        {"field": "injected; DROP TABLE--", "op": "eq", "value": "x"}
    ]}
    with pytest.raises(ValueError, match="not allowed"):
        repo.create_preset("Bad", "wanted", bad_conditions)


def test_update_preset(repo):
    """Updated preset reflects new name."""
    conditions = {"logic": "AND", "conditions": []}
    preset = repo.create_preset("Original", "wanted", conditions)
    updated = repo.update_preset(preset["id"], name="Updated")
    assert updated["name"] == "Updated"
```

Follow the exact fixture and import pattern from existing tests. If the app fixture is different (uses a conftest.py), match that pattern instead.
  </action>
  <verify>
`cd backend && python -m pytest tests/test_search.py -v 2>&1 | tail -20` — all tests pass.
`cd backend && python -m pytest tests/test_filter_presets.py -v 2>&1 | tail -20` — all tests pass.
  </verify>
  <done>
test_search.py has 4 tests covering empty query, no results, structure, and limit. test_filter_presets.py has 6 tests covering create+list, scope isolation, delete, not-found, injection guard, update. All pass.
  </done>
</task>

<task type="auto">
  <name>Task 7: Final integration verification</name>
  <files></files>
  <action>
Run the full test suite and TypeScript check to confirm Phase 12 is complete:

```bash
# Backend
cd backend && python -m pytest tests/ -v 2>&1 | tail -30

# Frontend TypeScript
cd frontend && npx tsc --noEmit

# Frontend lint
cd frontend && npm run lint
```

If any test fails that was passing before Phase 12 (a regression), investigate and fix it.

If the TypeScript check shows errors only in the new Phase 12 files (not pre-existing files), fix them.

Then confirm the four Phase 12 success criteria are met by tracing through the code:

1. ✅ **Multi-select bulk actions** — Wanted has checkboxes + BatchActionBar with ignore/unignore/blacklist/export. History has checkboxes + BatchActionBar with export. Library has search+sort (bulk actions descoped: Sonarr-backed, no batch endpoint).
2. ✅ **AND/OR filter system** — FilterBar renders conditions that map to FilterGroup (AND by default). FilterPresetsRepository.build_clause() supports nested AND/OR; preset_conditions wired into get_wanted_items() and get_download_history().
3. ✅ **Saved filter presets** — FilterPresetMenu save/load/delete wired to /api/v1/filter-presets.
4. ✅ **Global Ctrl+K search** — GlobalSearchModal with cmdk mounted at app root, searches FTS5 backend.

Update the ROADMAP.md progress table to mark Phase 12 plans as complete when done.
  </action>
  <verify>
`cd backend && python -m pytest tests/ -q` — all tests pass (no regressions).
`cd frontend && npx tsc --noEmit` — zero errors.
  </verify>
  <done>
All backend tests pass. Frontend TypeScript clean. All four Phase 12 success criteria are satisfied. ROADMAP.md updated.
  </done>
</task>

</tasks>
