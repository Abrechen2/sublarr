---
phase: 12-batch-operations-smart-filter
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - frontend/package.json
  - frontend/src/stores/selectionStore.ts
  - frontend/src/lib/types.ts
  - frontend/src/api/client.ts
  - frontend/src/hooks/useApi.ts
  - frontend/src/components/search/GlobalSearchModal.tsx
  - frontend/src/components/filters/FilterBar.tsx
  - frontend/src/components/filters/FilterPresetMenu.tsx
  - frontend/src/components/batch/BatchActionBar.tsx
autonomous: true

must_haves:
  truths:
    - "cmdk and zustand are installed in frontend/package.json"
    - "Zustand selectionStore manages per-scope multi-select state with Shift+click range selection"
    - "GlobalSearchModal opens on Ctrl+K, debounce-searches backend, groups results by type"
    - "FilterBar renders filter chips with AND/OR logic, preset save/load, quick clear"
    - "BatchActionBar appears when selection count > 0, offers contextual bulk actions"
    - "TypeScript types FilterPreset, FilterGroup, FilterCondition, SearchResult added to lib/types.ts"
    - "API client functions: searchGlobal, getFilterPresets, createFilterPreset, updateFilterPreset, deleteFilterPreset, batchAction added"
    - "React Query hooks: useGlobalSearch, useFilterPresets, useBatchAction added to useApi.ts"
  artifacts:
    - path: "frontend/src/stores/selectionStore.ts"
      provides: "Zustand store for cross-page multi-select"
      contains: "useSelectionStore"
    - path: "frontend/src/components/search/GlobalSearchModal.tsx"
      provides: "Ctrl+K command palette with async FTS5 backend search"
      contains: "GlobalSearchModal"
    - path: "frontend/src/components/filters/FilterBar.tsx"
      provides: "Reusable filter chip bar with preset support"
      contains: "FilterBar"
    - path: "frontend/src/components/batch/BatchActionBar.tsx"
      provides: "Floating batch action bar shown when items are selected"
      contains: "BatchActionBar"
  key_links:
    - from: "frontend/src/components/search/GlobalSearchModal.tsx"
      to: "frontend/src/hooks/useApi.ts"
      via: "useGlobalSearch hook"
      pattern: "useGlobalSearch"
    - from: "frontend/src/components/filters/FilterBar.tsx"
      to: "frontend/src/hooks/useApi.ts"
      via: "useFilterPresets hook"
      pattern: "useFilterPresets"
    - from: "frontend/src/components/batch/BatchActionBar.tsx"
      to: "frontend/src/stores/selectionStore.ts"
      via: "useSelectionStore"
      pattern: "useSelectionStore"
---

<objective>
Frontend core infrastructure for Phase 12: install cmdk + zustand, create the selection Zustand store, GlobalSearchModal, FilterBar, FilterPresetMenu, BatchActionBar components, plus all TypeScript types, API client functions, and React Query hooks.

Purpose: Build all reusable components and shared infrastructure that Plan 03 wires into the Library, Wanted, and History pages.

Output: 2 new npm packages, 4 new component files, extended types.ts + client.ts + useApi.ts, Zustand selection store.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-batch-operations-smart-filter/12-RESEARCH.md

@frontend/src/lib/types.ts
@frontend/src/api/client.ts
@frontend/src/hooks/useApi.ts
@frontend/src/App.tsx
@frontend/src/components/layout/Sidebar.tsx
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install cmdk and zustand</name>
  <files>
    frontend/package.json
  </files>
  <action>
Run from the frontend directory:
```bash
cd frontend && npm install cmdk zustand
```

After install, verify both appear in `package.json` `dependencies`:
- `cmdk` ≥ 1.0.0
- `zustand` ≥ 5.0.0

Do not modify any other files in this task.
  </action>
  <verify>
`cd frontend && node -e "require('cmdk'); console.log('cmdk OK')"` succeeds (or TypeScript import check).
`cd frontend && node -e "require('zustand'); console.log('zustand OK')"` succeeds.
  </verify>
  <done>
cmdk and zustand present in package.json dependencies. Both importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types — FilterPreset, FilterGroup, SearchResult</name>
  <files>
    frontend/src/lib/types.ts
  </files>
  <action>
Add the following type definitions to the END of `frontend/src/lib/types.ts`. Do not modify existing types.

```typescript
// ─── Phase 12: Batch Operations + Smart-Filter ────────────────────────────

export type FilterOperator = 'eq' | 'neq' | 'contains' | 'starts' | 'gt' | 'lt' | 'in'
export type FilterScope = 'wanted' | 'library' | 'history'

export interface FilterCondition {
  field: string
  op: FilterOperator
  value: string | string[] | number | boolean
}

export interface FilterGroup {
  logic: 'AND' | 'OR'
  conditions: (FilterCondition | FilterGroup)[]
}

export interface FilterPreset {
  id: number
  name: string
  scope: FilterScope
  conditions: FilterGroup
  is_default: boolean
  created_at: string
  updated_at: string
}

export interface SearchResultSeries {
  id: number
  title: string
}

export interface SearchResultEpisode {
  id: number
  series_id: number
  title: string
  season_episode: string
}

export interface SearchResultSubtitle {
  id: number
  file_path: string
  provider_name: string
  language: string
}

export interface GlobalSearchResults {
  query: string
  series: SearchResultSeries[]
  episodes: SearchResultEpisode[]
  subtitles: SearchResultSubtitle[]
}

export type BatchAction = 'ignore' | 'unignore' | 'blacklist' | 'export'

export interface BatchActionResult {
  success: boolean
  action: BatchAction
  affected: number
  item_ids: number[]
  warning?: string
}
```
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | head -20` — no new type errors from added types.
  </verify>
  <done>
All Phase 12 TypeScript interfaces added to lib/types.ts. No existing types modified. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Zustand selection store</name>
  <files>
    frontend/src/stores/selectionStore.ts
  </files>
  <action>
Create `frontend/src/stores/selectionStore.ts` (create the `stores/` directory if it doesn't exist):

```typescript
/**
 * Zustand store for cross-page multi-select state.
 *
 * Uses a scope string per page ('wanted', 'library', 'history') so selections
 * on different pages are independent and survive navigation.
 *
 * Shift+click range selection operates on the orderedIds of the CURRENT PAGE
 * only to avoid cross-page range bugs.
 */
import { create } from 'zustand'

interface SelectionState {
  /** Map from scope to Set of selected IDs */
  selections: Record<string, Set<number>>
  /** Last clicked item index per scope (for Shift+click range) */
  lastClickedIndex: Record<string, number | null>
}

interface SelectionActions {
  toggleItem: (scope: string, id: number, index: number, shiftKey: boolean, orderedIds: number[]) => void
  selectAll: (scope: string, ids: number[]) => void
  clearSelection: (scope: string) => void
  getSelected: (scope: string) => Set<number>
  getSelectedArray: (scope: string) => number[]
  isSelected: (scope: string, id: number) => boolean
  getCount: (scope: string) => number
}

export const useSelectionStore = create<SelectionState & SelectionActions>((set, get) => ({
  selections: {},
  lastClickedIndex: {},

  toggleItem: (scope, id, index, shiftKey, orderedIds) => {
    set((state) => {
      const current = new Set(state.selections[scope] ?? [])
      const lastIdx = state.lastClickedIndex[scope] ?? null

      if (shiftKey && lastIdx !== null) {
        const [from, to] = lastIdx < index ? [lastIdx, index] : [index, lastIdx]
        for (let i = from; i <= to; i++) {
          if (orderedIds[i] !== undefined) current.add(orderedIds[i])
        }
      } else {
        if (current.has(id)) {
          current.delete(id)
        } else {
          current.add(id)
        }
      }

      return {
        selections: { ...state.selections, [scope]: current },
        lastClickedIndex: { ...state.lastClickedIndex, [scope]: index },
      }
    })
  },

  selectAll: (scope, ids) =>
    set((state) => ({ selections: { ...state.selections, [scope]: new Set(ids) } })),

  clearSelection: (scope) =>
    set((state) => ({
      selections: { ...state.selections, [scope]: new Set() },
      lastClickedIndex: { ...state.lastClickedIndex, [scope]: null },
    })),

  getSelected: (scope) => get().selections[scope] ?? new Set(),
  getSelectedArray: (scope) => [...(get().selections[scope] ?? new Set())],
  isSelected: (scope, id) => (get().selections[scope] ?? new Set()).has(id),
  getCount: (scope) => (get().selections[scope] ?? new Set()).size,
}))
```
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep selectionStore` — no type errors for this file.
  </verify>
  <done>
selectionStore.ts exists with useSelectionStore. Supports per-scope isolation, toggleItem with Shift+click range, selectAll, clearSelection, getCount. TypeScript-clean.
  </done>
</task>

<task type="auto">
  <name>Task 4: API client functions + React Query hooks for search and presets</name>
  <files>
    frontend/src/api/client.ts
    frontend/src/hooks/useApi.ts
  </files>
  <action>
**Add to `frontend/src/api/client.ts`** (at the end, following existing function patterns):

```typescript
// ─── Phase 12: Search + Filter Presets + Batch Actions ────────────────────

export async function searchGlobal(q: string, limit = 20): Promise<GlobalSearchResults> {
  const res = await api.get('/search', { params: { q, limit } })
  return res.data
}

export async function getFilterPresets(scope: FilterScope): Promise<FilterPreset[]> {
  const res = await api.get('/filter-presets', { params: { scope } })
  return res.data
}

export async function createFilterPreset(preset: Omit<FilterPreset, 'id' | 'created_at' | 'updated_at'>): Promise<FilterPreset> {
  const res = await api.post('/filter-presets', preset)
  return res.data
}

export async function updateFilterPreset(id: number, data: Partial<Pick<FilterPreset, 'name' | 'conditions' | 'is_default'>>): Promise<FilterPreset> {
  const res = await api.put(`/filter-presets/${id}`, data)
  return res.data
}

export async function deleteFilterPreset(id: number): Promise<void> {
  await api.delete(`/filter-presets/${id}`)
}

export async function batchAction(itemIds: number[], action: BatchAction): Promise<BatchActionResult> {
  const res = await api.post('/wanted/batch-action', { item_ids: itemIds, action })
  return res.data
}
```

Add `GlobalSearchResults, FilterPreset, FilterScope, FilterGroup, BatchAction, BatchActionResult` to the import from `./lib/types` at the top of `client.ts` (or `../lib/types` — match existing import path).

**Add to `frontend/src/hooks/useApi.ts`** (after existing hooks):

```typescript
// ─── Phase 12: Search + Filter Presets + Batch Actions ────────────────────

export function useGlobalSearch(query: string) {
  return useQuery({
    queryKey: ['search', query],
    queryFn: () => searchGlobal(query),
    enabled: query.trim().length >= 2,
    staleTime: 10_000,
    placeholderData: keepPreviousData,
  })
}

export function useFilterPresets(scope: FilterScope) {
  return useQuery({
    queryKey: ['filter-presets', scope],
    queryFn: () => getFilterPresets(scope),
    staleTime: 60_000,
  })
}

export function useCreateFilterPreset() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: (preset: Parameters<typeof createFilterPreset>[0]) => createFilterPreset(preset),
    onSuccess: (data) => qc.invalidateQueries({ queryKey: ['filter-presets', data.scope] }),
  })
}

export function useDeleteFilterPreset(scope: FilterScope) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: (id: number) => deleteFilterPreset(id),
    onSuccess: () => qc.invalidateQueries({ queryKey: ['filter-presets', scope] }),
  })
}

export function useBatchAction() {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({ itemIds, action }: { itemIds: number[]; action: BatchAction }) =>
      batchAction(itemIds, action),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ['wanted'] })
      qc.invalidateQueries({ queryKey: ['library'] })
    },
  })
}
```

Add all new function imports to the import statements at the top of `useApi.ts`. Add `keepPreviousData` to the tanstack/react-query imports if not already present.
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | head -20` — no new TypeScript errors.
  </verify>
  <done>
5 API client functions added. 5 React Query hooks added. All types imported from lib/types.ts. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 5: GlobalSearchModal component (cmdk)</name>
  <files>
    frontend/src/components/search/GlobalSearchModal.tsx
  </files>
  <action>
Create `frontend/src/components/search/GlobalSearchModal.tsx`:

```typescript
/**
 * Global Ctrl+K search modal using cmdk.
 *
 * - shouldFilter={false}: filtering is done server-side via FTS5
 * - Results grouped into Series, Episodes, Subtitles sections
 * - Debounce: TanStack Query enabled only when query.length >= 2
 * - Navigation: Enter on series navigates to /library/:id, episodes to /wanted, subtitles to /history
 */
import { useEffect, useState } from 'react'
import { Command } from 'cmdk'
import { useNavigate } from 'react-router-dom'
import { Search, Tv, Film, FileText, Loader2 } from 'lucide-react'
import { useGlobalSearch } from '@/hooks/useApi'

interface Props {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function GlobalSearchModal({ open, onOpenChange }: Props) {
  const [query, setQuery] = useState('')
  const navigate = useNavigate()
  const { data, isFetching } = useGlobalSearch(query)

  // Reset query when closed
  useEffect(() => {
    if (!open) setQuery('')
  }, [open])

  const hasSeries = (data?.series?.length ?? 0) > 0
  const hasEpisodes = (data?.episodes?.length ?? 0) > 0
  const hasSubtitles = (data?.subtitles?.length ?? 0) > 0
  const hasResults = hasSeries || hasEpisodes || hasSubtitles
  const showEmpty = query.length >= 2 && !isFetching && !hasResults

  return (
    <Command.Dialog
      open={open}
      onOpenChange={onOpenChange}
      shouldFilter={false}
      className="fixed inset-0 z-50 flex items-start justify-center pt-[15vh]"
      overlayClassName="fixed inset-0 bg-black/50 backdrop-blur-sm"
    >
      <div className="w-full max-w-lg rounded-xl border border-border bg-background shadow-2xl overflow-hidden">
        <div className="flex items-center gap-2 px-4 border-b border-border">
          <Search className="h-4 w-4 text-muted-foreground shrink-0" />
          <Command.Input
            value={query}
            onValueChange={setQuery}
            placeholder="Search series, episodes, subtitles..."
            className="flex-1 h-12 bg-transparent outline-none text-sm text-foreground placeholder:text-muted-foreground"
          />
          {isFetching && <Loader2 className="h-4 w-4 animate-spin text-muted-foreground shrink-0" />}
          <kbd className="text-xs text-muted-foreground bg-muted rounded px-1.5 py-0.5">Esc</kbd>
        </div>

        <Command.List className="max-h-80 overflow-y-auto p-2">
          {query.length < 2 && (
            <Command.Empty className="py-8 text-center text-sm text-muted-foreground">
              Type at least 2 characters to search...
            </Command.Empty>
          )}
          {showEmpty && (
            <Command.Empty className="py-8 text-center text-sm text-muted-foreground">
              No results for "{query}"
            </Command.Empty>
          )}

          {hasSeries && (
            <Command.Group heading="Series" className="text-xs font-semibold text-muted-foreground px-2 py-1">
              {data!.series.map((s) => (
                <Command.Item
                  key={`series-${s.id}`}
                  value={`series-${s.id}`}
                  onSelect={() => { navigate(`/library/${s.id}`); onOpenChange(false) }}
                  className="flex items-center gap-2 px-2 py-1.5 rounded text-sm cursor-pointer hover:bg-accent aria-selected:bg-accent"
                >
                  <Tv className="h-3.5 w-3.5 text-teal-500 shrink-0" />
                  <span>{s.title}</span>
                </Command.Item>
              ))}
            </Command.Group>
          )}

          {hasEpisodes && (
            <Command.Group heading="Episodes" className="text-xs font-semibold text-muted-foreground px-2 py-1">
              {data!.episodes.map((ep) => (
                <Command.Item
                  key={`ep-${ep.id}`}
                  value={`ep-${ep.id}`}
                  onSelect={() => { navigate('/wanted'); onOpenChange(false) }}
                  className="flex items-center gap-2 px-2 py-1.5 rounded text-sm cursor-pointer hover:bg-accent aria-selected:bg-accent"
                >
                  <Film className="h-3.5 w-3.5 text-blue-500 shrink-0" />
                  <span>{ep.title}</span>
                  {ep.season_episode && (
                    <span className="ml-auto text-xs text-muted-foreground">{ep.season_episode}</span>
                  )}
                </Command.Item>
              ))}
            </Command.Group>
          )}

          {hasSubtitles && (
            <Command.Group heading="Subtitles" className="text-xs font-semibold text-muted-foreground px-2 py-1">
              {data!.subtitles.map((sub) => (
                <Command.Item
                  key={`sub-${sub.id}`}
                  value={`sub-${sub.id}`}
                  onSelect={() => { navigate('/history'); onOpenChange(false) }}
                  className="flex items-center gap-2 px-2 py-1.5 rounded text-sm cursor-pointer hover:bg-accent aria-selected:bg-accent"
                >
                  <FileText className="h-3.5 w-3.5 text-green-500 shrink-0" />
                  <span className="truncate max-w-xs">{sub.file_path.split('/').pop()}</span>
                  <span className="ml-auto text-xs text-muted-foreground uppercase">{sub.language}</span>
                </Command.Item>
              ))}
            </Command.Group>
          )}
        </Command.List>
      </div>
    </Command.Dialog>
  )
}
```

Note: if `react-router-dom` is not used (check App.tsx for the router library used), replace `useNavigate` with the correct navigation hook from the project's routing library.

After creating this file, add the Ctrl+K binding to `frontend/src/App.tsx` (or the layout component in `frontend/src/components/layout/Sidebar.tsx`):

1. Import `GlobalSearchModal` and a `useState` for `searchOpen`
2. Add the `useEffect` Ctrl+K handler: `e.key === 'k' && (e.metaKey || e.ctrlKey)`
3. Render `<GlobalSearchModal open={searchOpen} onOpenChange={setSearchOpen} />` at the end of the root layout
4. Optionally: Add a search icon button in the Sidebar header that calls `setSearchOpen(true)` with a `⌘K` / `Ctrl+K` keyboard hint
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep GlobalSearchModal` — no type errors.
`cd frontend && npm run lint 2>&1 | head -20` — no lint errors in the new file.
  </verify>
  <done>
GlobalSearchModal.tsx renders a cmdk Command.Dialog with shouldFilter={false}. Groups series, episodes, subtitles. Ctrl+K handler wired in App.tsx or Sidebar. TypeScript and lint clean.
  </done>
</task>

<task type="auto">
  <name>Task 6: FilterBar component with preset support</name>
  <files>
    frontend/src/components/filters/FilterBar.tsx
    frontend/src/components/filters/FilterPresetMenu.tsx
  </files>
  <action>
**Create `frontend/src/components/filters/FilterBar.tsx`:**

Props interface:
```typescript
interface FilterDef {
  key: string           // field name matching backend allowlist
  label: string         // display label
  type: 'select' | 'text' | 'number'
  options?: { value: string; label: string }[]  // for type='select'
}

interface ActiveFilter {
  key: string
  op: FilterOperator
  value: string
  label: string
}

interface FilterBarProps {
  scope: FilterScope
  filters: FilterDef[]          // available filter definitions for this page
  activeFilters: ActiveFilter[]
  onFiltersChange: (filters: ActiveFilter[]) => void
  onPresetLoad?: (conditions: FilterGroup) => void
  className?: string
}
```

**Behavior:**
- Renders a row of active filter chips (each chip shows `label op value`, has an × to remove)
- Has an "+ Add Filter" button that opens a small dropdown to pick field → operator → value
- Has a "Clear all" button when any filter is active
- Has a `<FilterPresetMenu>` component at the end (save/load presets)
- Chip click edits the filter value inline

**Visual style:** Follow the existing Tailwind v4 token style from the project (use `bg-accent`, `text-muted-foreground`, `border-border`, `rounded-lg` — check existing component files for exact class names).

```typescript
import { X, Plus, Filter, ChevronDown } from 'lucide-react'
import { useState } from 'react'
import type { FilterScope, FilterGroup, FilterOperator } from '@/lib/types'
import { FilterPresetMenu } from './FilterPresetMenu'

export function FilterBar({ scope, filters, activeFilters, onFiltersChange, onPresetLoad, className }: FilterBarProps) {
  const [addingFilter, setAddingFilter] = useState(false)
  const [pendingKey, setPendingKey] = useState('')
  const [pendingValue, setPendingValue] = useState('')

  const removeFilter = (key: string) =>
    onFiltersChange(activeFilters.filter((f) => f.key !== key))

  const clearAll = () => onFiltersChange([])

  const addFilter = (key: string, value: string) => {
    const def = filters.find((f) => f.key === key)
    if (!def || !value) return
    const existing = activeFilters.filter((f) => f.key !== key)
    onFiltersChange([...existing, { key, op: 'eq', value, label: def.label }])
    setAddingFilter(false)
    setPendingKey('')
    setPendingValue('')
  }

  return (
    <div className={`flex flex-wrap items-center gap-2 ${className ?? ''}`}>
      <Filter className="h-4 w-4 text-muted-foreground shrink-0" />

      {activeFilters.map((f) => (
        <span
          key={f.key}
          className="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs bg-teal-500/10 text-teal-400 border border-teal-500/20"
        >
          <span className="text-muted-foreground">{f.label}:</span>
          {f.value}
          <button
            onClick={() => removeFilter(f.key)}
            className="ml-0.5 hover:text-foreground"
            aria-label={`Remove ${f.label} filter`}
          >
            <X className="h-3 w-3" />
          </button>
        </span>
      ))}

      {/* Add filter popover */}
      <div className="relative">
        <button
          onClick={() => setAddingFilter((v) => !v)}
          className="inline-flex items-center gap-1 px-2.5 py-0.5 rounded-full text-xs border border-dashed border-border text-muted-foreground hover:border-teal-500 hover:text-teal-400 transition-colors"
        >
          <Plus className="h-3 w-3" />
          Add filter
        </button>
        {addingFilter && (
          <div className="absolute top-7 left-0 z-20 bg-background border border-border rounded-lg shadow-lg p-3 min-w-48">
            <select
              className="w-full mb-2 text-sm bg-background border border-border rounded px-2 py-1"
              value={pendingKey}
              onChange={(e) => { setPendingKey(e.target.value); setPendingValue('') }}
            >
              <option value="">Pick field...</option>
              {filters.map((f) => (
                <option key={f.key} value={f.key}>{f.label}</option>
              ))}
            </select>
            {pendingKey && (() => {
              const def = filters.find((f) => f.key === pendingKey)!
              return def.type === 'select' ? (
                <select
                  className="w-full text-sm bg-background border border-border rounded px-2 py-1"
                  value={pendingValue}
                  onChange={(e) => setPendingValue(e.target.value)}
                  onBlur={() => { if (pendingValue) addFilter(pendingKey, pendingValue) }}
                >
                  <option value="">Pick value...</option>
                  {def.options?.map((o) => <option key={o.value} value={o.value}>{o.label}</option>)}
                </select>
              ) : (
                <input
                  type={def.type === 'number' ? 'number' : 'text'}
                  placeholder={`Enter ${def.label.toLowerCase()}...`}
                  value={pendingValue}
                  onChange={(e) => setPendingValue(e.target.value)}
                  onKeyDown={(e) => { if (e.key === 'Enter' && pendingValue) addFilter(pendingKey, pendingValue) }}
                  className="w-full text-sm bg-background border border-border rounded px-2 py-1 outline-none"
                  autoFocus
                />
              )
            })()}
          </div>
        )}
      </div>

      {activeFilters.length > 0 && (
        <button
          onClick={clearAll}
          className="text-xs text-muted-foreground hover:text-foreground"
        >
          Clear all
        </button>
      )}

      <div className="ml-auto">
        <FilterPresetMenu
          scope={scope}
          activeFilters={activeFilters}
          onPresetLoad={onPresetLoad ?? (() => {})}
        />
      </div>
    </div>
  )
}
```

**Create `frontend/src/components/filters/FilterPresetMenu.tsx`:**

```typescript
import { useState } from 'react'
import { Bookmark, ChevronDown, Save, Trash2 } from 'lucide-react'
import { useFilterPresets, useCreateFilterPreset, useDeleteFilterPreset } from '@/hooks/useApi'
import type { FilterScope, FilterGroup } from '@/lib/types'

interface Props {
  scope: FilterScope
  activeFilters: { key: string; op: string; value: string }[]
  onPresetLoad: (conditions: FilterGroup) => void
}

export function FilterPresetMenu({ scope, activeFilters, onPresetLoad }: Props) {
  const [open, setOpen] = useState(false)
  const [saveName, setSaveName] = useState('')
  const [saving, setSaving] = useState(false)
  const { data: presets = [] } = useFilterPresets(scope)
  const createPreset = useCreateFilterPreset()
  const deletePreset = useDeleteFilterPreset(scope)

  const handleSave = async () => {
    if (!saveName.trim()) return
    const conditions: FilterGroup = {
      logic: 'AND',
      conditions: activeFilters.map((f) => ({
        field: f.key,
        op: f.op as 'eq',
        value: f.value,
      })),
    }
    await createPreset.mutateAsync({ name: saveName.trim(), scope, conditions, is_default: false })
    setSaveName('')
    setSaving(false)
  }

  return (
    <div className="relative">
      <button
        onClick={() => setOpen((v) => !v)}
        className="inline-flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground"
        title="Filter presets"
      >
        <Bookmark className="h-3.5 w-3.5" />
        Presets
        <ChevronDown className="h-3 w-3" />
      </button>

      {open && (
        <div className="absolute right-0 top-6 z-20 bg-background border border-border rounded-lg shadow-lg p-3 min-w-52">
          {presets.length === 0 && !saving && (
            <p className="text-xs text-muted-foreground mb-2">No saved presets</p>
          )}
          {presets.map((p) => (
            <div key={p.id} className="flex items-center gap-1 group mb-1">
              <button
                onClick={() => { onPresetLoad(p.conditions); setOpen(false) }}
                className="flex-1 text-left text-sm hover:text-teal-400 truncate"
              >
                {p.name}
              </button>
              <button
                onClick={() => deletePreset.mutate(p.id)}
                className="opacity-0 group-hover:opacity-100 text-destructive"
                aria-label="Delete preset"
              >
                <Trash2 className="h-3 w-3" />
              </button>
            </div>
          ))}

          <div className="border-t border-border mt-2 pt-2">
            {saving ? (
              <div className="flex gap-1">
                <input
                  type="text"
                  placeholder="Preset name..."
                  value={saveName}
                  onChange={(e) => setSaveName(e.target.value)}
                  onKeyDown={(e) => { if (e.key === 'Enter') handleSave() }}
                  className="flex-1 text-xs bg-background border border-border rounded px-2 py-1 outline-none"
                  autoFocus
                />
                <button onClick={handleSave} className="text-teal-400 hover:text-teal-300">
                  <Save className="h-3.5 w-3.5" />
                </button>
              </div>
            ) : (
              <button
                onClick={() => setSaving(true)}
                disabled={activeFilters.length === 0}
                className="flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground disabled:opacity-40"
              >
                <Save className="h-3 w-3" />
                Save current filters
              </button>
            )}
          </div>
        </div>
      )}
    </div>
  )
}
```
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep -E "FilterBar|FilterPresetMenu"` — no type errors.
  </verify>
  <done>
FilterBar renders active filter chips with × remove, "+ Add filter" popover, "Clear all", and FilterPresetMenu. FilterPresetMenu lists saved presets with load/delete, and save-current-filters inline form. Both TypeScript-clean.
  </done>
</task>

<task type="auto">
  <name>Task 7: BatchActionBar component</name>
  <files>
    frontend/src/components/batch/BatchActionBar.tsx
  </files>
  <action>
Create `frontend/src/components/batch/BatchActionBar.tsx`:

```typescript
/**
 * Floating batch action bar shown at the bottom of the screen when items are selected.
 *
 * Renders: "{N} items selected · [Ignore] [Unignore] [Blacklist] [Export] [Clear]"
 * Disappears when selection count drops to 0.
 */
import { useState } from 'react'
import { X, EyeOff, Eye, Ban, Download } from 'lucide-react'
import { useSelectionStore } from '@/stores/selectionStore'
import { useBatchAction } from '@/hooks/useApi'
import type { BatchAction, FilterScope } from '@/lib/types'

interface BatchActionDef {
  action: BatchAction
  label: string
  icon: React.ReactNode
  variant?: 'default' | 'destructive'
}

interface Props {
  scope: FilterScope
  /** Which actions to show for this page */
  actions?: BatchAction[]
  onActionComplete?: (action: BatchAction, result: unknown) => void
}

const ACTION_DEFS: BatchActionDef[] = [
  { action: 'ignore',   label: 'Ignore',    icon: <EyeOff className="h-3.5 w-3.5" /> },
  { action: 'unignore', label: 'Unignore',  icon: <Eye className="h-3.5 w-3.5" /> },
  { action: 'blacklist',label: 'Blacklist', icon: <Ban className="h-3.5 w-3.5" />, variant: 'destructive' },
  { action: 'export',   label: 'Export',    icon: <Download className="h-3.5 w-3.5" /> },
]

export function BatchActionBar({ scope, actions = ['ignore', 'unignore', 'blacklist', 'export'], onActionComplete }: Props) {
  const { getSelectedArray, getCount, clearSelection } = useSelectionStore()
  const count = getCount(scope)
  const batchMutation = useBatchAction()
  const [lastResult, setLastResult] = useState<string | null>(null)

  if (count === 0) return null

  const handleAction = async (action: BatchAction) => {
    const ids = getSelectedArray(scope)
    if (ids.length === 0) return

    if (action === 'export') {
      // Export: trigger download of selected item IDs as JSON
      const result = await batchMutation.mutateAsync({ itemIds: ids, action })
      const blob = new Blob([JSON.stringify(result, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `sublarr-export-${scope}-${Date.now()}.json`
      a.click()
      URL.revokeObjectURL(url)
      onActionComplete?.(action, result)
      return
    }

    const result = await batchMutation.mutateAsync({ itemIds: ids, action })
    setLastResult(`${result.affected} items updated`)
    setTimeout(() => setLastResult(null), 3000)
    clearSelection(scope)
    onActionComplete?.(action, result)
  }

  const visibleActions = ACTION_DEFS.filter((a) => actions.includes(a.action))

  return (
    <div className="fixed bottom-6 left-1/2 -translate-x-1/2 z-40 flex items-center gap-2 px-4 py-2.5 bg-background border border-border rounded-full shadow-2xl shadow-black/20">
      <span className="text-sm font-medium text-foreground mr-1">
        {count} selected
      </span>
      <div className="h-4 w-px bg-border mx-1" />

      {visibleActions.map((def) => (
        <button
          key={def.action}
          onClick={() => handleAction(def.action)}
          disabled={batchMutation.isPending}
          className={`inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-colors
            ${def.variant === 'destructive'
              ? 'bg-destructive/10 text-destructive hover:bg-destructive/20'
              : 'bg-muted text-muted-foreground hover:bg-accent hover:text-foreground'
            } disabled:opacity-50`}
        >
          {def.icon}
          {def.label}
        </button>
      ))}

      {lastResult && (
        <span className="text-xs text-teal-400 ml-1">{lastResult}</span>
      )}

      <div className="h-4 w-px bg-border mx-1" />
      <button
        onClick={() => clearSelection(scope)}
        className="p-1 text-muted-foreground hover:text-foreground rounded-full"
        aria-label="Clear selection"
      >
        <X className="h-4 w-4" />
      </button>
    </div>
  )
}
```
  </action>
  <verify>
`cd frontend && npx tsc --noEmit 2>&1 | grep BatchActionBar` — no type errors.
`cd frontend && npm run lint 2>&1 | grep BatchActionBar` — no lint errors.
  </verify>
  <done>
BatchActionBar renders as a floating pill at bottom center when selection count > 0. Shows count, action buttons (ignore/unignore/blacklist/export), clear button. Calls batchMutation and triggers download for export action. TypeScript and lint clean.
  </done>
</task>

<task type="auto">
  <name>Task 8: Full TypeScript + lint verification</name>
  <files></files>
  <action>
Run a final full TypeScript type-check and lint pass:

```bash
cd frontend && npx tsc --noEmit
cd frontend && npm run lint
```

If there are any type errors or lint errors in files created or modified in this plan, fix them. Do NOT change files that were not touched in this plan unless they are imported by new files.

Common fixes needed:
- Ensure `@/` path alias resolves correctly (check tsconfig.json)
- If `@/` alias is not configured, use relative paths (e.g., `../stores/selectionStore`)
- Ensure `keepPreviousData` is exported from `@tanstack/react-query` v5 (in v5 it's `import { keepPreviousData } from '@tanstack/react-query'`)
  </action>
  <verify>
`cd frontend && npx tsc --noEmit` exits with 0 errors.
`cd frontend && npm run lint` exits with 0 errors (warnings are acceptable).
  </verify>
  <done>
Zero TypeScript errors. Zero lint errors in new and modified files. All Phase 12 frontend components are type-safe.
  </done>
</task>

</tasks>
