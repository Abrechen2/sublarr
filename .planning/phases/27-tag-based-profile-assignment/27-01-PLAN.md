---
phase: 27-tag-based-profile-assignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/models/core.py
  - backend/db/repositories/profiles.py
  - backend/db/profiles.py
  - backend/routes/profiles.py
  - backend/routes/webhooks.py
autonomous: true

must_haves:
  truths:
    - "User can create tag mapping rules (Sonarr/Radarr tag label to Language Profile name) in Settings"
    - "When a new series/movie arrives via webhook, tags are checked and matching Language Profile is auto-assigned"
    - "Tag mapping rules are manageable (create, edit, delete) in Settings Language Profiles"
    - "If no tag rule matches, existing default profile logic applies unchanged"
  artifacts:
    - path: "backend/db/models/core.py"
      provides: "TagProfileMapping or tag_profile_mappings table (tag_label, profile_id)"
    - path: "backend/db/repositories/profiles.py"
      provides: "CRUD for tag rules; get_profile_id_for_tags(tag_labels)"
    - path: "backend/routes/profiles.py"
      provides: "GET/POST/PUT/DELETE /api/v1/language-profiles/tag-rules"
    - path: "backend/routes/webhooks.py"
      provides: "After webhook: fetch series/movie tags from Sonarr/Radarr API; resolve profile from tag rules; assign_series_profile/assign_movie_profile"
  key_links:
    - from: "backend/routes/webhooks.py"
      to: "backend/db/profiles.py"
      via: "get_profile_id_for_tags, assign_series_profile"
    - from: "backend/routes/profiles.py"
      to: "backend/db/repositories/profiles.py"
      via: "tag rule CRUD"
---

<objective>
Backend: tag-to-profile mapping table and API; webhook uses tags to auto-assign Language Profile.

Purpose: When Sonarr/Radarr sends a webhook for a new series/movie, fetch its tags and match to a Language Profile via rules; assign that profile. No match = existing default behavior.

Output: Table tag_profile_mappings (tag_label, profile_id); repository and API for tag rules; webhook pipeline: get series/movie tags (Sonarr/Radarr API), get_profile_id_for_tags(labels), if found assign_series_profile or assign_movie_profile.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

@backend/routes/webhooks.py
@backend/db/profiles.py
@backend/routes/profiles.py
@backend/sonarr_client.py
@backend/radarr_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB model and repository for tag rules</name>
  <files>
    backend/db/models/core.py
    backend/db/repositories/profiles.py
    backend/db/profiles.py
  </files>
  <action>
1. Create model TagProfileMapping: id, tag_label (str, unique or unique per scope), profile_id (FK to language_profiles). One rule = one tag label maps to one profile. If same tag appears in multiple rules (e.g. different profiles for different contexts), use first match or document precedence (e.g. order by id).
2. Migration: create table tag_profile_mappings.
3. Repository: list_tag_rules(), create_tag_rule(tag_label, profile_id), update_tag_rule(id, tag_label?, profile_id?), delete_tag_rule(id). get_profile_id_for_tags(tag_labels: list[str]) -> optional profile_id: find first rule where tag_label in tag_labels; return that rule's profile_id.
4. Facade in db/profiles.py: expose tag rule CRUD and get_profile_id_for_tags.
  </action>
  <verify>
    Create rule "anime" -> profile 1; get_profile_id_for_tags(["anime"]) returns 1; get_profile_id_for_tags(["other"]) returns None.
  </verify>
  <done>
    Table and repository for tag rules; get_profile_id_for_tags implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: API for tag rules CRUD</name>
  <files>
    backend/routes/profiles.py
  </files>
  <action>
1. GET /api/v1/language-profiles/tag-rules: return list of { id, tag_label, profile_id, profile_name? }.
2. POST /api/v1/language-profiles/tag-rules: body { tag_label, profile_id }; create rule.
3. PUT /api/v1/language-profiles/tag-rules/:id: body { tag_label?, profile_id? }; update.
4. DELETE /api/v1/language-profiles/tag-rules/:id: delete rule.
  </action>
  <verify>
    curl CRUD on tag rules; list returns created rules.
  </verify>
  <done>
    Tag rules API implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Webhook fetches tags and assigns profile</name>
  <files>
    backend/routes/webhooks.py
  </files>
  <action>
1. In webhook_sonarr: after parsing series_id and episode path, call Sonarr API to get series details including tags (e.g. series.get("tags") or tag IDs resolved to labels via get_tags()). Get tag labels list. Call get_profile_id_for_tags(labels); if not None, call assign_series_profile(series_id, profile_id). Run this before or after existing auto_scan/auto_search so profile is set for subsequent steps.
2. In webhook_radarr: same for movie_id; Radarr API for movie tags; get_profile_id_for_tags; assign_movie_profile(movie_id, profile_id).
3. If get_profile_id_for_tags returns None, do not change assignment (existing default logic applies).
  </action>
  <verify>
    Mock webhook with series that has tag "anime"; rule "anime" -> profile 2; confirm assign_series_profile(series_id, 2) called.
  </verify>
  <done>
    Webhook fetches tags and auto-assigns profile when a rule matches; no match = no change.
  </done>
</task>

</tasks>

<verification>
1. tag_profile_mappings table and CRUD; get_profile_id_for_tags(tag_labels).
2. API: GET/POST/PUT/DELETE tag rules.
3. Webhook: get series/movie tags from *arr API; if rule matches, assign profile.
</verification>

<success_criteria>
- Tag mapping rules stored and manageable via API.
- Webhook auto-assigns Language Profile when tags match a rule; otherwise default behavior.
</success_criteria>

<output>
After completion, create `.planning/phases/27-tag-based-profile-assignment/27-01-SUMMARY.md`
</output>
