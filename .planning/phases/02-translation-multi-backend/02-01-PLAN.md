---
phase: 02-translation-multi-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/translation/__init__.py
  - backend/translation/base.py
  - backend/translation/llm_utils.py
  - backend/translation/ollama.py
  - backend/db/__init__.py
  - backend/db/translation.py
autonomous: true

must_haves:
  truths:
    - "TranslationBackend ABC exists with translate_batch, health_check, get_config_fields methods"
    - "TranslationManager can register backends, create instances with config from config_entries, and delegate translate calls"
    - "OllamaBackend implements TranslationBackend ABC and passes existing Ollama health check and translation tests"
    - "Shared LLM utilities (prompt building, response parsing, CJK hallucination detection) are extracted and reusable"
    - "translation_backend_stats table exists in database schema"
    - "language_profiles table has translation_backend and fallback_chain_json columns"
  artifacts:
    - path: "backend/translation/base.py"
      provides: "TranslationBackend ABC + TranslationResult dataclass"
      contains: "class TranslationBackend"
    - path: "backend/translation/__init__.py"
      provides: "TranslationManager singleton with registry, config loading, stats recording"
      contains: "class TranslationManager"
    - path: "backend/translation/llm_utils.py"
      provides: "Shared LLM prompt building, response parsing, CJK hallucination detection"
      contains: "build_translation_prompt"
    - path: "backend/translation/ollama.py"
      provides: "OllamaBackend implementing TranslationBackend ABC"
      contains: "class OllamaBackend"
    - path: "backend/db/__init__.py"
      provides: "translation_backend_stats table DDL + language_profiles migration"
      contains: "translation_backend_stats"
  key_links:
    - from: "backend/translation/ollama.py"
      to: "backend/translation/llm_utils.py"
      via: "import build_translation_prompt, parse_llm_response, has_cjk_hallucination"
      pattern: "from translation\\.llm_utils import"
    - from: "backend/translation/__init__.py"
      to: "backend/db/config.py"
      via: "config_entries lookup for backend.<name>.<key>"
      pattern: "backend\\."
    - from: "backend/translation/ollama.py"
      to: "backend/translation/base.py"
      via: "ABC inheritance"
      pattern: "class OllamaBackend.*TranslationBackend"
---

<objective>
Create the TranslationBackend ABC, TranslationManager, shared LLM utilities, and migrate the existing Ollama integration as the first backend implementation. Extend the database schema with backend stats tracking and profile-level backend selection columns.

Purpose: This is the foundation for all 5 translation backends. The ABC contract, manager orchestration, and shared LLM parsing logic must exist before any other backends can be implemented.
Output: `backend/translation/` package with working Ollama backend, extended DB schema.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-translation-multi-backend/02-RESEARCH.md

@backend/ollama_client.py
@backend/translator.py
@backend/providers/base.py
@backend/providers/__init__.py
@backend/circuit_breaker.py
@backend/db/__init__.py
@backend/db/translation.py
@backend/db/config.py
@backend/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create translation package with ABC, LLM utilities, and OllamaBackend</name>
  <files>
    backend/translation/__init__.py
    backend/translation/base.py
    backend/translation/llm_utils.py
    backend/translation/ollama.py
  </files>
  <action>
Create `backend/translation/` package with four files:

**base.py** — TranslationBackend ABC and TranslationResult dataclass:
- `TranslationResult` dataclass with fields: `translated_lines: list[str]`, `backend_name: str`, `response_time_ms: float = 0`, `characters_used: int = 0`, `error: Optional[str] = None`, `success: bool = True`
- `TranslationBackend` ABC with class-level attributes: `name`, `display_name`, `config_fields: list[dict]`, `supports_glossary: bool`, `supports_batch: bool`, `max_batch_size: int`
- Three abstract methods: `translate_batch(lines, source_lang, target_lang, glossary_entries=None) -> TranslationResult`, `health_check() -> tuple[bool, str]`, `get_config_fields() -> list[dict]`
- One optional method: `get_usage() -> dict` (default returns empty dict)
- Constructor takes `**config` and stores as `self.config`
- Follow the SubtitleProvider ABC pattern from `providers/base.py` for consistency

**llm_utils.py** — Extract shared LLM logic from `ollama_client.py`:
- `build_translation_prompt(lines, source_lang, target_lang, glossary_entries=None, prompt_template=None)` — combines glossary terms with numbered lines and prompt template. If no prompt_template provided, loads from config via `get_settings().get_prompt_template()`
- `parse_llm_response(response_text, expected_count) -> list[str] | None` — extracted from `ollama_client._parse_response()`, same logic (numbered line stripping, merge attempts, truncation)
- `has_cjk_hallucination(text) -> bool` — extracted from `ollama_client._has_cjk_hallucination()`, same CJK regex
- `build_prompt_with_glossary(prompt_template, glossary_entries, lines)` — extracted from `ollama_client.build_prompt_with_glossary()`, same logic
- Keep the `_CJK_RE` compiled regex at module level

**ollama.py** — OllamaBackend implementing TranslationBackend:
- Class attributes: `name = "ollama"`, `display_name = "Ollama (Local LLM)"`, `supports_glossary = True`, `supports_batch = True`, `max_batch_size = 25`
- `config_fields` matching research: url, model, temperature, request_timeout, max_retries (with defaults matching current Pydantic Settings values)
- `translate_batch()`: Builds prompt via `llm_utils.build_translation_prompt()`, calls Ollama `/api/generate` endpoint, parses via `llm_utils.parse_llm_response()`, checks CJK hallucination, retries on failure (same logic as current `ollama_client.translate_batch` including single-line fallback)
- `health_check()`: Same logic as current `ollama_client.check_ollama_health()` — GET `/api/tags`, check model availability
- `get_config_fields()`: Returns `self.config_fields`
- `get_usage()`: Returns empty dict (Ollama has no usage tracking)
- Config values: Read from `self.config` dict (populated by TranslationManager from config_entries). Fall back to Pydantic Settings values if config_entries are empty (migration path — per research open question 4)
- Keep `_call_ollama()` and `_translate_singles()` as private methods within the class

**__init__.py** — TranslationManager:
- `_backend_classes: dict[str, type[TranslationBackend]]` registry (class-level)
- `_backends: dict[str, TranslationBackend]` instances (instance-level, lazy-created)
- `_circuit_breakers: dict[str, CircuitBreaker]` per backend (reuse existing CircuitBreaker class)
- `register_backend(cls)` — registers a backend class by `cls.name`
- `get_backend(name) -> TranslationBackend | None` — lazy-creates instance, loads config from `config_entries` DB table using `backend.<name>.<key>` namespacing (same pattern as `plugin.<name>.<key>` from Phase 1)
- `get_all_backends() -> list[dict]` — returns list of registered backend info dicts (name, display_name, config_fields, configured status)
- `translate_with_fallback(lines, source_lang, target_lang, fallback_chain, glossary_entries=None) -> TranslationResult` — tries each backend in order, uses circuit breakers to skip known-failing backends, records success/failure stats
- `_load_backend_config(name) -> dict` — reads `config_entries` for keys matching `backend.<name>.*`, strips prefix, returns flat dict. Falls back to Pydantic Settings for Ollama (migration compatibility)
- `_record_success(backend_name, result)` and `_record_failure(backend_name, error)` — update `translation_backend_stats` table via `db.translation` functions
- `invalidate_backend(name)` — removes cached instance (for config changes)
- Singleton pattern: `get_translation_manager()` and `invalidate_translation_manager()` module-level functions
- Auto-register OllamaBackend on import (register at bottom of file after imports)
  </action>
  <verify>
Run: `cd backend && python -c "from translation import get_translation_manager; m = get_translation_manager(); print('Backends:', list(m._backend_classes.keys())); assert 'ollama' in m._backend_classes; print('OK')"`
Confirm output shows "Backends: ['ollama']" and "OK".
  </verify>
  <done>
TranslationBackend ABC exists with all required methods. OllamaBackend is registered and can be instantiated. Shared LLM utilities are importable. TranslationManager loads config from config_entries with Pydantic fallback for Ollama.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend database schema with backend stats table and profile columns</name>
  <files>
    backend/db/__init__.py
    backend/db/translation.py
  </files>
  <action>
**db/__init__.py** — Add to SCHEMA string:
```sql
CREATE TABLE IF NOT EXISTS translation_backend_stats (
    backend_name TEXT PRIMARY KEY,
    total_requests INTEGER DEFAULT 0,
    successful_translations INTEGER DEFAULT 0,
    failed_translations INTEGER DEFAULT 0,
    total_characters INTEGER DEFAULT 0,
    avg_response_time_ms REAL DEFAULT 0,
    last_response_time_ms REAL DEFAULT 0,
    last_success_at TEXT,
    last_failure_at TEXT,
    last_error TEXT DEFAULT '',
    consecutive_failures INTEGER DEFAULT 0,
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);
CREATE INDEX IF NOT EXISTS idx_translation_backend_stats_updated ON translation_backend_stats(updated_at);
```

Add to `_run_migrations()`:
- Check if `language_profiles` has `translation_backend` column; if not, `ALTER TABLE language_profiles ADD COLUMN translation_backend TEXT DEFAULT 'ollama'`
- Check if `language_profiles` has `fallback_chain_json` column; if not, `ALTER TABLE language_profiles ADD COLUMN fallback_chain_json TEXT DEFAULT '["ollama"]'`
- Check if `translation_backend_stats` table exists (try SELECT 1, catch OperationalError, create if missing) — same migration pattern used for glossary_entries and prompt_presets

**db/translation.py** — Add backend stats operations:
- `record_backend_success(backend_name, response_time_ms, characters_used)` — upsert into `translation_backend_stats`: increment total_requests and successful_translations, add to total_characters, update avg_response_time_ms using weighted running average formula `(old_avg * (n-1) + new) / n` (same formula as provider_stats), set last_success_at, reset consecutive_failures to 0
- `record_backend_failure(backend_name, error_msg)` — upsert: increment total_requests and failed_translations, increment consecutive_failures, set last_failure_at and last_error
- `get_backend_stats() -> list[dict]` — SELECT all from translation_backend_stats
- `get_backend_stat(backend_name) -> dict | None` — SELECT single row
- `reset_backend_stats(backend_name)` — DELETE row from translation_backend_stats

Also update `_row_to_profile()` in `db/profiles.py` to include the new `translation_backend` and `fallback_chain` fields:
- Add `d["translation_backend"] = d.get("translation_backend", "ollama")`
- Parse `fallback_chain_json`: `d["fallback_chain"] = json.loads(d.get("fallback_chain_json", '["ollama"]'))`
- Delete the raw JSON key from the dict

Update `update_language_profile()` in `db/profiles.py` to accept `translation_backend` and `fallback_chain` in the allowed fields set. For `fallback_chain`, serialize to JSON and store as `fallback_chain_json`.
  </action>
  <verify>
Run: `cd backend && python -c "
from db import get_db
db = get_db()
# Check translation_backend_stats table
db.execute('SELECT * FROM translation_backend_stats LIMIT 1')
# Check language_profiles columns
cursor = db.execute('PRAGMA table_info(language_profiles)')
cols = {row[1] for row in cursor.fetchall()}
assert 'translation_backend' in cols, f'Missing translation_backend, cols: {cols}'
assert 'fallback_chain_json' in cols, f'Missing fallback_chain_json, cols: {cols}'
print('Schema OK')
"`
  </verify>
  <done>
`translation_backend_stats` table exists with all columns. `language_profiles` table has `translation_backend` and `fallback_chain_json` columns. Backend stats CRUD operations work. Profile serialization includes new fields.
  </done>
</task>

</tasks>

<verification>
1. `from translation.base import TranslationBackend, TranslationResult` — imports succeed
2. `from translation.llm_utils import build_translation_prompt, parse_llm_response, has_cjk_hallucination` — imports succeed
3. `from translation.ollama import OllamaBackend` — imports succeed, `OllamaBackend.name == "ollama"`
4. `from translation import get_translation_manager` — manager has "ollama" registered
5. Database schema has `translation_backend_stats` table and `language_profiles.translation_backend` column
6. `from db.translation import record_backend_success, record_backend_failure, get_backend_stats` — imports succeed
</verification>

<success_criteria>
- TranslationBackend ABC defines the contract for all 5 backends
- OllamaBackend faithfully preserves all existing Ollama translation logic (prompt building, response parsing, CJK detection, retry, single-line fallback)
- TranslationManager can register backends, load config from config_entries, and track stats
- Database schema extended without breaking existing data
- Shared LLM utilities are importable from `translation.llm_utils`
</success_criteria>

<output>
After completion, create `.planning/phases/02-translation-multi-backend/02-01-SUMMARY.md`
</output>
