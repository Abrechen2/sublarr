---
phase: 02-translation-multi-backend
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - backend/translator.py
  - backend/routes/translate.py
  - backend/routes/profiles.py
  - backend/db/profiles.py
  - backend/config.py
autonomous: true

must_haves:
  truths:
    - "translator.py resolves translation backend from language profile instead of hardcoded Ollama"
    - "Translation uses fallback chain from profile when primary backend fails"
    - "Changing a profile's translation_backend or fallback_chain persists in database"
    - "API endpoints exist for listing backends, testing backends, and saving backend config"
    - "Translation config hash includes backend name for re-translation detection"
    - "Existing Ollama config migrates seamlessly (no reconfiguration needed)"
  artifacts:
    - path: "backend/translator.py"
      provides: "Multi-backend translation orchestration"
      contains: "get_translation_manager"
    - path: "backend/routes/translate.py"
      provides: "Backend management API endpoints"
      contains: "/backends"
    - path: "backend/routes/profiles.py"
      provides: "Profile endpoints with backend selection"
      contains: "translation_backend"
  key_links:
    - from: "backend/translator.py"
      to: "backend/translation/__init__.py"
      via: "TranslationManager.translate_with_fallback replaces ollama_client.translate_all"
      pattern: "translate_with_fallback"
    - from: "backend/translator.py"
      to: "backend/db/profiles.py"
      via: "profile lookup for backend selection"
      pattern: "get_series_profile|get_movie_profile|get_default_profile"
    - from: "backend/routes/translate.py"
      to: "backend/translation/__init__.py"
      via: "backend list and test endpoints"
      pattern: "get_translation_manager"
---

<objective>
Rewire translator.py to use TranslationManager instead of ollama_client.translate_all(). Add backend selection to language profiles. Create API endpoints for backend management (list, test, configure). Update translation config hash to include backend name.

Purpose: This connects all 5 backends to the actual translation pipeline, enabling per-profile backend selection and automatic fallback.
Output: Working multi-backend translation pipeline, backend management API.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-translation-multi-backend/02-RESEARCH.md
@.planning/phases/02-translation-multi-backend/02-01-SUMMARY.md

@backend/translator.py
@backend/ollama_client.py
@backend/routes/translate.py
@backend/routes/profiles.py
@backend/db/profiles.py
@backend/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewire translator.py to use TranslationManager with profile-based backend selection</name>
  <files>
    backend/translator.py
    backend/config.py
  </files>
  <action>
**translator.py** — Replace `from ollama_client import translate_all` with TranslationManager:

1. Remove the import `from ollama_client import translate_all` at the top.

2. Add a new function `_resolve_backend_for_context(arr_context, target_language)`:
   - Imports `get_default_profile`, `get_series_profile`, `get_movie_profile` from `db.profiles`
   - If `arr_context` has `sonarr_series_id`: use `get_series_profile(id)`
   - Elif `arr_context` has `radarr_movie_id`: use `get_movie_profile(id)`
   - Else: use `get_default_profile()`
   - Extract `translation_backend` (default "ollama") and `fallback_chain` (default ["ollama"]) from profile
   - If `translation_backend` not in `fallback_chain`, prepend it
   - Return `(translation_backend, fallback_chain)`

3. Add a new function `_translate_with_manager(lines, source_lang, target_lang, arr_context=None, series_id=None)`:
   - Imports `get_translation_manager` from `translation`
   - Resolves backend and fallback_chain via `_resolve_backend_for_context()`
   - Loads glossary entries if series_id provided (same pattern as current code)
   - Gets TranslationManager, calls `translate_with_fallback(lines, source_lang, target_lang, fallback_chain, glossary_entries)`
   - Manager internally handles batching per backend's `max_batch_size`
   - If result.success: return result.translated_lines
   - If result.success is False: raise RuntimeError with result.error

4. Update `translate_ass()`:
   - Replace `translated_texts = translate_all(dialog_texts, series_id=series_id)` with `translated_texts = _translate_with_manager(dialog_texts, source_lang=settings.source_language, target_lang=tgt_lang, arr_context=arr_context, series_id=series_id)`
   - Source language comes from profile or settings

5. Update `_translate_srt()`:
   - Same replacement of `translate_all()` with `_translate_with_manager()`
   - Pass `arr_context` through for profile resolution

6. Update `_translate_external_ass()`:
   - Same replacement

7. Update `_record_config_hash_for_result()`:
   - Change config hash to include backend name: `{backend_name}|{model_or_empty}|{target_language}`
   - Backend name is stored in the result stats (TranslationResult.backend_name)
   - Update `record_translation_config()` call to pass backend_name instead of ollama_model when using non-Ollama backends

**config.py** — Update `get_translation_config_hash()`:
- Accept optional `backend_name` parameter (default "ollama")
- Include backend_name in hash: `f"{backend_name}|{self.ollama_model}|{self.get_prompt_template()[:50]}|{self.target_language}"`
- For non-Ollama backends, model is not relevant, so hash becomes: `f"{backend_name}||{self.target_language}"`

**Important:** Do NOT delete `ollama_client.py` yet. The new OllamaBackend in `translation/ollama.py` replaces its functionality, but `ollama_client.py` can remain as a deprecated module until all references are confirmed migrated. The `from ollama_client import translate_all` import in translator.py is the primary call site being replaced.
  </action>
  <verify>
Run: `cd backend && python -c "
from translator import _resolve_backend_for_context, _translate_with_manager
# Test resolution with no context (should return default)
backend, chain = _resolve_backend_for_context(None, 'de')
print(f'Default backend: {backend}, chain: {chain}')
assert backend == 'ollama'
assert 'ollama' in chain
print('Backend resolution OK')
"`
  </verify>
  <done>
translator.py uses TranslationManager for all translation calls. Backend selection is resolved from language profiles. Fallback chain is honored. Config hash includes backend name. Existing installations using Ollama continue to work without reconfiguration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add backend management API endpoints and profile backend selection</name>
  <files>
    backend/routes/translate.py
    backend/routes/profiles.py
    backend/db/profiles.py
  </files>
  <action>
**routes/translate.py** — Add backend management endpoints:

1. `GET /api/v1/backends` — List all registered backends:
   - Calls `get_translation_manager().get_all_backends()`
   - Returns `{"backends": [{"name": str, "display_name": str, "config_fields": list, "configured": bool, "supports_glossary": bool, "max_batch_size": int}]}`

2. `POST /api/v1/backends/test/<name>` — Test a specific backend:
   - Gets backend via `get_translation_manager().get_backend(name)`
   - If not found: return 404
   - Calls `backend.health_check()` — returns `{"healthy": bool, "message": str}`
   - Also include `backend.get_usage()` if available: `{"healthy": bool, "message": str, "usage": dict}`

3. `PUT /api/v1/backends/<name>/config` — Save backend configuration:
   - Accepts JSON body with config key-value pairs
   - Stores each as `backend.<name>.<key>` in `config_entries` table via `db.config` module
   - Invalidates cached backend instance via `manager.invalidate_backend(name)`
   - Returns `{"status": "saved"}`

4. `GET /api/v1/backends/<name>/config` — Get backend configuration:
   - Reads `config_entries` for keys matching `backend.<name>.*`
   - Strips prefix, returns flat dict
   - Masks password fields (replace value with "***" if field type is "password" and value is non-empty)

5. `GET /api/v1/backends/stats` — Get all backend translation stats:
   - Calls `get_backend_stats()` from `db.translation`
   - Returns `{"stats": list[dict]}`

**routes/profiles.py** — Extend profile endpoints:

1. Update `POST /api/v1/language-profiles` to accept `translation_backend` and `fallback_chain` fields in the request body. Pass them through to `create_language_profile()`.

2. Update `PUT /api/v1/language-profiles/<id>` to accept `translation_backend` and `fallback_chain` fields. Pass to `update_language_profile()`.

3. Ensure `GET /api/v1/language-profiles` returns `translation_backend` and `fallback_chain` in each profile (already handled by `_row_to_profile()` update from Plan 01).

**db/profiles.py** — Update `create_language_profile()`:
- Add optional parameters: `translation_backend: str = "ollama"`, `fallback_chain: list[str] | None = None`
- Default `fallback_chain` to `[translation_backend]` if None
- Include `translation_backend` and `fallback_chain_json` in INSERT statement

Update `update_language_profile()`:
- Add `translation_backend` and `fallback_chain` to the `allowed` set
- For `fallback_chain`: serialize to JSON, store as `fallback_chain_json`
  </action>
  <verify>
Run: `cd backend && python -c "
# Test backend endpoints exist (route registration)
from app import create_app
app = create_app(testing=True)
rules = [r.rule for r in app.url_map.iter_rules()]
assert '/api/v1/backends' in rules, f'Missing /backends, rules: {[r for r in rules if \"backend\" in r]}'
print('Backend routes registered')
# Test profile backend field
from db.profiles import get_default_profile
p = get_default_profile()
print(f'Default profile backend: {p.get(\"translation_backend\", \"NOT SET\")}')
assert 'translation_backend' in p
print('Profile integration OK')
"`
  </verify>
  <done>
Backend management API provides list, test, configure, and stats endpoints. Language profiles support translation_backend and fallback_chain fields. Profile CRUD endpoints accept and return backend selection. The full pipeline from profile -> backend resolution -> translation works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `POST /api/v1/translate` still works (uses default Ollama backend via profile)
2. `GET /api/v1/backends` returns list of all registered backends
3. `POST /api/v1/backends/test/ollama` returns health check result
4. `PUT /api/v1/backends/deepl/config` saves DeepL API key to config_entries
5. `GET /api/v1/language-profiles` returns profiles with `translation_backend` field
6. `PUT /api/v1/language-profiles/<id>` with `translation_backend: "deepl"` persists
7. translator.py no longer imports from ollama_client
</verification>

<success_criteria>
- translator.py uses TranslationManager.translate_with_fallback() for ALL translation paths (ASS, SRT, external ASS)
- Backend selection comes from language profile, not hardcoded
- Fallback chain tries each backend in order until one succeeds
- Backend config is stored in config_entries with backend.<name>.<key> namespacing
- Existing Ollama-only installations work without any config changes
- API endpoints for backend management are functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-translation-multi-backend/02-04-SUMMARY.md`
</output>
