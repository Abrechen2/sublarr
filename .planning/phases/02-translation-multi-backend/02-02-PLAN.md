---
phase: 02-translation-multi-backend
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/translation/deepl_backend.py
  - backend/translation/libretranslate.py
  - backend/translation/__init__.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "DeepL backend translates text using the official deepl SDK with auto-detected Free/Pro plan"
    - "DeepL backend supports native glossary creation and caching"
    - "LibreTranslate backend translates text line-by-line via REST API"
    - "Both backends implement health_check that verifies service availability"
    - "Both backends are registered in TranslationManager and appear in get_all_backends()"
  artifacts:
    - path: "backend/translation/deepl_backend.py"
      provides: "DeepL translation backend with glossary support"
      contains: "class DeepLBackend"
    - path: "backend/translation/libretranslate.py"
      provides: "LibreTranslate backend with per-line translation"
      contains: "class LibreTranslateBackend"
  key_links:
    - from: "backend/translation/deepl_backend.py"
      to: "backend/translation/base.py"
      via: "ABC inheritance"
      pattern: "class DeepLBackend.*TranslationBackend"
    - from: "backend/translation/libretranslate.py"
      to: "backend/translation/base.py"
      via: "ABC inheritance"
      pattern: "class LibreTranslateBackend.*TranslationBackend"
    - from: "backend/translation/__init__.py"
      to: "backend/translation/deepl_backend.py"
      via: "auto-registration on import"
      pattern: "register_backend.*DeepLBackend"
---

<objective>
Implement DeepL and LibreTranslate translation backends as the two API-based (non-LLM) backends. These accept text directly and return clean translations without prompt construction or response parsing.

Purpose: API backends provide deterministic, high-quality translations for European languages (DeepL) and a free self-hosted option (LibreTranslate).
Output: Two working backend implementations registered in TranslationManager.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-translation-multi-backend/02-RESEARCH.md
@.planning/phases/02-translation-multi-backend/02-01-SUMMARY.md

@backend/translation/base.py
@backend/translation/__init__.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DeepL translation backend</name>
  <files>
    backend/translation/deepl_backend.py
    backend/requirements.txt
  </files>
  <action>
**requirements.txt** — Add `deepl>=1.20.0` to the dependencies.

**deepl_backend.py** — DeepL backend implementing TranslationBackend:
- Class attributes: `name = "deepl"`, `display_name = "DeepL"`, `supports_glossary = True`, `supports_batch = True`, `max_batch_size = 50`
- `config_fields`: api_key (password, required), no plan field needed (SDK auto-detects Free vs Pro from key suffix `:fx`)
- Lazy client creation: `_get_client()` creates `deepl.DeepLClient(auth_key=api_key)` on first use, caches in `self._client`
- Glossary cache: `self._glossary_cache: dict[tuple[str, str], glossary_id]` caching DeepL glossary IDs by (source, target) pair
- `_to_deepl_lang(iso_code)` static helper mapping ISO 639-1 to DeepL codes (en->EN, de->DE, pt->PT-BR, etc. — use mapping from research)
- `translate_batch()`:
  1. Get client via `_get_client()`
  2. Map source_lang and target_lang via `_to_deepl_lang()`
  3. If glossary_entries provided and non-empty: call `_get_or_create_glossary()` to get/create DeepL glossary, pass as `glossary` kwarg
  4. Call `client.translate_text(lines, source_lang=source, target_lang=target, **kwargs)`
  5. Extract translated text: `[r.text for r in results]`
  6. Return TranslationResult with translated_lines, characters_used = sum of input line lengths
- `_get_or_create_glossary(source, target, entries)`:
  1. Check `self._glossary_cache` for (source, target) key
  2. If not cached: build entries dict `{e["source_term"]: e["target_term"] for e in entries}`, call `client.create_glossary(name, source_lang, target_lang, entries)`, cache glossary ID
  3. Return glossary object or None on failure (log warning, do not break translation)
- `health_check()`: Call `client.get_usage()`, return `(True, f"OK ({plan}, {usage.character.count}/{usage.character.limit} chars)")` where plan is "Free" if key ends with `:fx` else "Pro". Catch exceptions and return `(False, str(e))`
- `get_usage()`: Return dict with `characters_used`, `characters_limit`, `plan` from `client.get_usage()`
- `get_config_fields()`: Return `self.config_fields`
- Import guard: Wrap `import deepl` in try/except ImportError, log warning if not installed, make translate_batch raise RuntimeError("deepl package not installed")
  </action>
  <verify>
Run: `cd backend && python -c "from translation.deepl_backend import DeepLBackend; b = DeepLBackend(); assert b.name == 'deepl'; assert b.max_batch_size == 50; assert b.supports_glossary == True; print('DeepL backend OK')"`
  </verify>
  <done>
DeepLBackend implements TranslationBackend ABC. Glossary caching works. Health check reports plan type and usage. Config fields expose api_key for Settings UI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LibreTranslate backend and register both backends</name>
  <files>
    backend/translation/libretranslate.py
    backend/translation/__init__.py
  </files>
  <action>
**libretranslate.py** — LibreTranslate backend implementing TranslationBackend:
- Class attributes: `name = "libretranslate"`, `display_name = "LibreTranslate (Self-Hosted)"`, `supports_glossary = False`, `supports_batch = False`, `max_batch_size = 1`
- `config_fields`: url (text, required, default "http://libretranslate:5000"), api_key (password, optional, default ""), request_timeout (number, optional, default "30")
- `translate_batch()`:
  1. Get url from config, strip trailing slash
  2. Get api_key and timeout from config
  3. For each line in `lines`: POST to `{url}/translate` with JSON payload `{"q": line, "source": source_lang, "target": target_lang, "format": "text"}`, add `api_key` to payload if non-empty
  4. Parse response: `data.get("translatedText", line)`
  5. Collect all translated lines
  6. Return TranslationResult with translated_lines, characters_used
  7. Use `requests.post()` with timeout, call `resp.raise_for_status()`
  8. On any exception: return TranslationResult with success=False, error message, translated_lines=[] (fail fast, let fallback chain handle it)
- `health_check()`: GET `{url}/languages`, check status 200, return `(True, f"OK ({len(langs)} languages available)")`. Catch exceptions, return `(False, str(e))`
- `get_config_fields()`: Return `self.config_fields`
- `get_usage()`: Return empty dict (no usage tracking)
- No import guard needed (uses stdlib requests, already a dependency)

**__init__.py** — Register both new backends:
- At bottom of file (after OllamaBackend import), add imports for DeepLBackend and LibreTranslateBackend
- Use try/except ImportError for DeepLBackend (deepl library is optional)
- Register each: `register_backend(DeepLBackend)`, `register_backend(LibreTranslateBackend)`
- Use the existing `register_backend()` function pattern
  </action>
  <verify>
Run: `cd backend && python -c "
from translation import get_translation_manager
m = get_translation_manager()
backends = list(m._backend_classes.keys())
print('Backends:', backends)
assert 'ollama' in backends
assert 'libretranslate' in backends
# DeepL may or may not be available depending on pip install
print('Registration OK')
"`
  </verify>
  <done>
LibreTranslateBackend implements TranslationBackend ABC with per-line translation. Both DeepL and LibreTranslate backends are registered in TranslationManager alongside Ollama. `get_all_backends()` returns all three.
  </done>
</task>

</tasks>

<verification>
1. `from translation.deepl_backend import DeepLBackend` — imports and instantiates
2. `from translation.libretranslate import LibreTranslateBackend` — imports and instantiates
3. TranslationManager has all three backends registered (ollama, deepl, libretranslate)
4. `deepl>=1.20.0` appears in requirements.txt
5. Each backend has correct config_fields, supports_glossary, max_batch_size values
</verification>

<success_criteria>
- DeepL backend uses official SDK, auto-detects Free/Pro plan, supports glossary caching
- LibreTranslate backend translates line-by-line with configurable URL and optional API key
- Both backends have working health_check methods
- Both are registered in TranslationManager
- requirements.txt updated with deepl dependency
</success_criteria>

<output>
After completion, create `.planning/phases/02-translation-multi-backend/02-02-SUMMARY.md`
</output>
