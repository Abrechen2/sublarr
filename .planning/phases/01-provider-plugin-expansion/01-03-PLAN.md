---
phase: 01-provider-plugin-expansion
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/providers/plugins/watcher.py
  - backend/providers/plugins/__init__.py
  - backend/providers/plugins/template/my_provider.py
  - backend/providers/plugins/template/README.md
  - backend/routes/plugins.py
  - backend/app.py
  - backend/config.py
autonomous: true

must_haves:
  truths:
    - "API endpoint POST /plugins/reload re-discovers and re-registers plugins without app restart"
    - "Optional file watcher auto-reloads plugins when .py files change in the plugins directory"
    - "Plugin template file is a working example that a developer can copy, modify, and drop in to create a new provider"
    - "Template includes docstrings explaining every required method and config_fields pattern"
  artifacts:
    - path: "backend/providers/plugins/watcher.py"
      provides: "Watchdog-based file watcher for plugin hot-reload"
      contains: "FileSystemEventHandler"
    - path: "backend/providers/plugins/template/my_provider.py"
      provides: "Annotated plugin template for developers"
      contains: "class MyProvider(SubtitleProvider)"
    - path: "backend/providers/plugins/template/README.md"
      provides: "Plugin development guide"
      contains: "Creating a Sublarr Provider Plugin"
  key_links:
    - from: "backend/providers/plugins/watcher.py"
      to: "backend/providers/plugins/__init__.py"
      via: "calls PluginManager.reload() on file change events"
      pattern: "reload"
    - from: "backend/routes/plugins.py"
      to: "backend/providers/plugins/__init__.py"
      via: "POST /plugins/reload calls PluginManager.reload()"
      pattern: "reload"
    - from: "backend/app.py"
      to: "backend/providers/plugins/watcher.py"
      via: "starts watcher if plugin_hot_reload enabled"
      pattern: "start_plugin_watcher"
---

<objective>
Add hot-reload support for plugins (API endpoint + optional file watcher) and create a developer-friendly plugin template with documentation. This completes PLUG-03 (Hot-Reload) and PLUG-05 (Plugin Template + Developer Documentation).

Purpose: Hot-reload enables plugin development without restarting the app. The template enables third-party developers to create providers in under 30 minutes (Success Criterion 5).

Output: Working hot-reload mechanism + production-ready plugin template.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-provider-plugin-expansion/01-RESEARCH.md

# Plan 01 creates the plugin system this plan extends
@.planning/phases/01-provider-plugin-expansion/01-01-SUMMARY.md

@backend/providers/plugins/__init__.py
@backend/providers/plugins/loader.py
@backend/providers/base.py
@backend/routes/plugins.py
@backend/app.py
@backend/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement watchdog-based file watcher and wire hot-reload</name>
  <files>
    backend/providers/plugins/watcher.py
    backend/providers/plugins/__init__.py
    backend/routes/plugins.py
    backend/app.py
    backend/config.py
  </files>
  <action>
    1. Create `backend/providers/plugins/watcher.py`:
       - Import watchdog.observers.Observer and watchdog.events.FileSystemEventHandler.
       - Create `PluginFileWatcher(FileSystemEventHandler)` class:
         - `__init__(self, plugin_manager, debounce_seconds=2.0)`: stores manager ref and debounce timer.
         - `on_modified(self, event)`: if event.src_path ends with '.py' and not starting with '_', schedule a debounced reload. Use threading.Timer for debounce (cancel previous timer if new event arrives within debounce window).
         - `on_created(self, event)`: same as on_modified.
         - `on_deleted(self, event)`: schedule debounced reload.
         - `_debounced_reload(self)`: calls `self.plugin_manager.reload()` and then `invalidate_manager()` from providers to re-init ProviderManager. Logs what was loaded/unloaded. Wraps in try/except to never crash the watcher thread.
       - Create `start_plugin_watcher(plugin_manager, plugins_dir: str) -> Observer`:
         - Creates Observer, schedules PluginFileWatcher on plugins_dir (non-recursive).
         - Starts observer as daemon thread.
         - Returns observer instance for later cleanup.
       - Create `stop_plugin_watcher(observer: Observer)`: stops observer.

    2. In `backend/config.py`, add setting:
       ```python
       plugin_hot_reload: bool = False  # Enable watchdog file watcher for plugins directory
       ```

    3. In `backend/app.py`, in `create_app()`, after plugin discovery, conditionally start the watcher:
       ```python
       if not testing and settings.plugin_hot_reload:
           try:
               from providers.plugins.watcher import start_plugin_watcher
               watcher = start_plugin_watcher(plugin_mgr, plugins_dir)
               logger.info("Plugin hot-reload watcher started on %s", plugins_dir)
           except ImportError:
               logger.warning("watchdog not installed, plugin hot-reload disabled")
       ```
       The watcher is optional -- if watchdog is not installed, it gracefully degrades.

    4. In `backend/routes/plugins.py`, ensure the POST /plugins/reload endpoint also invalidates the ProviderManager after reload (so new plugins are immediately usable for searches). Verify this was done in Plan 01; if not, add `invalidate_manager()` call.
  </action>
  <verify>
    - `cd backend && python -c "from providers.plugins.watcher import PluginFileWatcher, start_plugin_watcher; print('Watcher imported OK')"`
    - `cd backend && python -c "from config import get_settings; assert hasattr(get_settings(), 'plugin_hot_reload'); print('hot_reload setting exists')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30`
  </verify>
  <done>
    File watcher monitors plugins directory for .py file changes and triggers debounced plugin reload. Hot-reload is optional (controlled by plugin_hot_reload setting). POST /plugins/reload also works for manual reload. Watchdog not installed = graceful degradation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create plugin developer template and documentation</name>
  <files>
    backend/providers/plugins/template/my_provider.py
    backend/providers/plugins/template/README.md
  </files>
  <action>
    1. Create `backend/providers/plugins/template/my_provider.py` -- a fully annotated, working provider template:
       ```python
       """Example Sublarr provider plugin.

       Copy this file to your plugins directory (default: /config/plugins/),
       rename it, and modify the class to implement your provider.

       Requirements:
       - The file must contain exactly one class that extends SubtitleProvider
       - The class must have a unique 'name' attribute (lowercase, no spaces)
       - The class must implement search() and download() methods
       - config_fields declares what settings the user can configure in the UI
       """

       from providers.base import (
           SubtitleProvider,
           SubtitleResult,
           SubtitleFormat,
           VideoQuery,
       )
       from providers.http_session import create_session

       class MyProvider(SubtitleProvider):
           """Your custom subtitle provider.

           Attributes:
               name: Unique provider identifier (lowercase, no spaces, no underscores at start).
                     This appears in the Settings UI and API responses.
               languages: Set of ISO 639-1 language codes this provider supports.
               config_fields: List of configuration fields rendered in the Settings UI.
                     Each field: {"key": str, "label": str, "type": "text"|"password"|"number",
                                  "required": bool, "default": str}
               rate_limit: (max_requests, window_seconds) - rate limiting. (0, 0) = no limit.
               timeout: HTTP request timeout in seconds.
               max_retries: Number of retry attempts on failure.
           """

           name = "my_provider"  # CHANGE THIS - must be unique across all providers
           languages = {"en", "de", "fr"}  # ISO 639-1 codes your provider supports

           config_fields = [
               {"key": "api_key", "label": "API Key", "type": "password", "required": True},
               {"key": "base_url", "label": "Base URL", "type": "text", "required": False, "default": "https://api.example.com"},
           ]

           rate_limit = (30, 60)  # 30 requests per 60 seconds
           timeout = 15  # seconds
           max_retries = 2

           def __init__(self, **config):
               super().__init__(**config)
               self.session = None
               self.api_key = config.get("api_key", "")
               self.base_url = config.get("base_url", "https://api.example.com")

           def initialize(self):
               """Called once when the provider is loaded. Set up HTTP sessions here."""
               self.session = create_session(
                   max_retries=self.max_retries,
                   timeout=self.timeout,
                   user_agent="Sublarr-Plugin/1.0",
               )

           def terminate(self):
               """Called when the provider is unloaded. Clean up resources."""
               if self.session:
                   self.session.close()
                   self.session = None

           def search(self, query: VideoQuery) -> list[SubtitleResult]:
               """Search for subtitles matching the query.

               Args:
                   query: Contains file_path, title, series_title, season, episode,
                          languages, imdb_id, tvdb_id, anidb_id, release_group, etc.

               Returns:
                   List of SubtitleResult objects. Do NOT sort -- the ProviderManager
                   handles scoring and sorting.

               Tips:
                   - Use query.is_episode to check if searching for TV episode
                   - Use query.is_movie to check if searching for movie
                   - Use query.display_name for logging
                   - Set result.matches to indicate what matched (e.g., {"series", "episode"})
                   - The score is computed automatically from matches by the manager
               """
               if not self.session:
                   return []

               results = []

               # Example: search by series title and episode
               # Replace this with your actual API call
               # params = {"q": query.series_title, "season": query.season, "episode": query.episode}
               # resp = self.session.get(f"{self.base_url}/search", params=params)
               # for item in resp.json():
               #     results.append(SubtitleResult(
               #         provider_name=self.name,
               #         subtitle_id=str(item["id"]),
               #         language=item["language"],
               #         format=SubtitleFormat.SRT,  # or SubtitleFormat.ASS
               #         filename=item["filename"],
               #         download_url=item["download_url"],
               #         release_info=item.get("release_info", ""),
               #         matches={"series", "episode"},  # What matched
               #     ))

               return results

           def download(self, result: SubtitleResult) -> bytes:
               """Download a subtitle file.

               Args:
                   result: A SubtitleResult from search() with download_url populated.

               Returns:
                   Raw subtitle file content as bytes.

               Tips:
                   - Handle ZIP/RAR archives: extract the subtitle file from the archive
                   - Handle encoding: the manager expects UTF-8 bytes
                   - Set result.content and result.format if the download reveals the format
               """
               if not self.session:
                   raise RuntimeError(f"{self.name} not initialized")

               resp = self.session.get(result.download_url)
               resp.raise_for_status()
               content = resp.content

               # If the download is a ZIP, extract the subtitle:
               # import zipfile, io
               # if content[:4] == b'PK\\x03\\x04':
               #     with zipfile.ZipFile(io.BytesIO(content)) as zf:
               #         for name in zf.namelist():
               #             if name.endswith(('.srt', '.ass')):
               #                 content = zf.read(name)
               #                 break

               result.content = content
               return content

           def health_check(self) -> tuple[bool, str]:
               """Check if the provider is reachable (optional, default returns True).

               Returns:
                   (is_healthy, message) tuple
               """
               if not self.session:
                   return False, "Not initialized"
               try:
                   resp = self.session.get(f"{self.base_url}/health", timeout=5)
                   return resp.status_code == 200, f"HTTP {resp.status_code}"
               except Exception as e:
                   return False, str(e)
       ```

    2. Create `backend/providers/plugins/template/README.md` -- plugin developer guide:
       Content should cover:
       - Quick start (copy template, rename, modify)
       - Provider API contract (search, download, health_check, initialize, terminate)
       - config_fields schema and how the Settings UI renders them
       - VideoQuery fields reference (all available query data)
       - SubtitleResult fields reference (what to populate)
       - Scoring: explain the matches set and how scores are computed
       - Rate limiting and timeout configuration
       - Error handling (ProviderAuthError, ProviderRateLimitError, ProviderTimeoutError)
       - Testing your plugin (drop in, reload, check logs)
       - Common patterns: handling ZIP archives, XZ compression, session management
       - Docker volume mounting for plugins directory
       - Limitations: plugins run in the same process, no sandboxing
  </action>
  <verify>
    - `cd backend && python -c "import ast; ast.parse(open('providers/plugins/template/my_provider.py').read()); print('Template is valid Python')"`
    - Verify README.md exists and has substantial content: `wc -l backend/providers/plugins/template/README.md` (should be 100+ lines)
    - `cd backend && python -m pytest tests/ -x -q --timeout=30`
  </verify>
  <done>
    Plugin template is a complete, annotated, working example that developers can copy and modify. README covers the full plugin development workflow. A developer can create a new provider in under 30 minutes using the template.
  </done>
</task>

</tasks>

<verification>
1. Hot-reload works: drop a test plugin .py file into plugins dir, call POST /plugins/reload, verify it appears in GET /plugins.
2. Template validity: the template file parses as valid Python and all imports resolve.
3. Documentation: README covers provider contract, config_fields, scoring, error handling.
4. All existing tests pass: `cd backend && python -m pytest tests/ -x -q --timeout=30`
</verification>

<success_criteria>
- POST /plugins/reload re-discovers plugins and re-initializes ProviderManager
- Watchdog file watcher triggers debounced reload on .py file changes (when enabled)
- plugin_hot_reload setting controls watcher (default: false)
- Watchdog not installed = graceful degradation (no crash)
- Template file is valid Python with complete docstrings
- README covers full plugin development workflow
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-provider-plugin-expansion/01-03-SUMMARY.md`
</output>
