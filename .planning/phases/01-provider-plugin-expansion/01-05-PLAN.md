---
phase: 01-provider-plugin-expansion
plan: 05
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/providers/kitsunekko.py
  - backend/providers/napisy24.py
  - backend/providers/whisper_subgen.py
autonomous: true

must_haves:
  truths:
    - "User can search and download Japanese anime subtitles from Kitsunekko"
    - "User can search and download Polish subtitles from Napisy24 using file hash"
    - "User can generate subtitles via an external Whisper/Subgen instance"
    - "All three providers register via @register_provider and declare their own config_fields"
  artifacts:
    - path: "backend/providers/kitsunekko.py"
      provides: "Kitsunekko HTML scraping provider for Japanese anime subs"
      contains: "@register_provider"
    - path: "backend/providers/napisy24.py"
      provides: "Napisy24 hash-based POST API provider for Polish subs"
      contains: "@register_provider"
    - path: "backend/providers/whisper_subgen.py"
      provides: "Whisper-Subgen external ASR service provider"
      contains: "@register_provider"
  key_links:
    - from: "backend/providers/kitsunekko.py"
      to: "backend/providers/base.py"
      via: "extends SubtitleProvider"
      pattern: "class KitsunekkoProvider.SubtitleProvider"
    - from: "backend/providers/napisy24.py"
      to: "backend/providers/base.py"
      via: "extends SubtitleProvider"
      pattern: "class Napisy24Provider.SubtitleProvider"
    - from: "backend/providers/whisper_subgen.py"
      to: "backend/providers/base.py"
      via: "extends SubtitleProvider"
      pattern: "class WhisperSubgenProvider.SubtitleProvider"
---

<objective>
Implement three medium-complexity providers: Kitsunekko (Japanese anime subtitle scraping, PROV-04), Napisy24 (Polish subtitle hash-based lookup, PROV-06), and Whisper-Subgen (external ASR service, PROV-05). Each has a distinct API pattern requiring specialized handling.

Purpose: Kitsunekko complements the existing Jimaku provider for Japanese anime subs. Napisy24 covers the Polish subtitle market. Whisper-Subgen enables speech-to-text generation as a last-resort provider.

Output: Three new built-in providers expanding language and source coverage.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-provider-plugin-expansion/01-RESEARCH.md

@.planning/phases/01-provider-plugin-expansion/01-01-SUMMARY.md

@backend/providers/base.py
@backend/providers/__init__.py
@backend/providers/http_session.py
@backend/providers/animetosho.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Kitsunekko provider (HTML scraping for Japanese anime subs)</name>
  <files>backend/providers/kitsunekko.py</files>
  <action>
    Create `backend/providers/kitsunekko.py` implementing Kitsunekko HTML scraping:

    Site: `https://kitsunekko.net`

    Class: `KitsunekkoProvider(SubtitleProvider)` with `@register_provider` decorator.
    - `name = "kitsunekko"`
    - `languages = {"ja"}` -- Japanese only (this is a Japanese subtitle source)
    - `config_fields = []` -- no auth
    - `rate_limit = (10, 60)` -- polite scraping: 10 requests per minute
    - `timeout = 20`
    - `max_retries = 2`

    **search(query) implementation:**
    1. Only search for Japanese language. If "ja" not in `query.languages`, return [].
    2. Build directory URL: `https://kitsunekko.net/dirlist.php?dir=subtitles/japanese/{series_title}/`
       - Normalize series_title: lowercase, replace spaces with underscores or try multiple patterns.
    3. Fetch the page, parse HTML with BeautifulSoup (html.parser or lxml).
    4. The page is a directory listing with links to subtitle files (.ass, .srt, .zip).
    5. For each file link:
       - Extract filename from the href attribute.
       - Try to match episode number from filename (reuse patterns from animetosho).
       - Filter by episode if query has season/episode.
       - Build `SubtitleResult` with direct download URL.
       - Detect format from file extension.
       - Set `matches`: "series" always (matched by directory), "episode" if episode number matched.

    **download(result) implementation:**
    - `GET {download_url}` -- returns the subtitle file directly (or a ZIP).
    - Handle ZIP archives: extract first .ass/.srt file.
    - Return content bytes.

    **health_check():**
    - `GET https://kitsunekko.net/` -- if 200, healthy.

    **Error handling:**
    - Site may be down or return 403. Handle gracefully.
    - HTML structure may change. Use defensive parsing (check element exists before accessing).
    - Log warnings on parse failures, never crash.

    Import BeautifulSoup conditionally: `try: from bs4 import BeautifulSoup; except ImportError: ...` and skip search if not available (log warning).
  </action>
  <verify>
    - `cd backend && python -c "from providers.kitsunekko import KitsunekkoProvider; p = KitsunekkoProvider(); assert p.name == 'kitsunekko'; assert 'ja' in p.languages; print('Kitsunekko OK')"`
    - `cd backend && python -c "from providers import _PROVIDER_CLASSES; assert 'kitsunekko' in _PROVIDER_CLASSES; print('Kitsunekko registered')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30`
  </verify>
  <done>
    KitsunekkoProvider scrapes directory listings for Japanese anime subtitles, matches episodes, handles ZIP archives, and gracefully handles site unavailability.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Napisy24 provider (hash-based POST) and Whisper-Subgen provider (external ASR)</name>
  <files>
    backend/providers/napisy24.py
    backend/providers/whisper_subgen.py
  </files>
  <action>
    **Napisy24 Provider:**

    Create `backend/providers/napisy24.py`:

    API: `http://napisy24.pl/run/CheckSubAgent.php`

    Class: `Napisy24Provider(SubtitleProvider)` with `@register_provider`.
    - `name = "napisy24"`
    - `languages = {"pl"}` -- Polish only
    - `config_fields = [{"key": "username", "label": "Username", "type": "text", "required": False, "default": "subliminal"}, {"key": "password", "label": "Password", "type": "password", "required": False, "default": "lanimilbus"}]`
    - `rate_limit = (20, 60)` -- conservative
    - `timeout = 15`
    - `max_retries = 2`

    **search(query):**
    1. Only search for Polish. If "pl" not in `query.languages`, return [].
    2. Requires file_path for hash computation. If no file_path or file doesn't exist, return [].
    3. Compute Napisy24 hash: MD5 of first 10MB of the file (based on Bazarr's implementation).
    4. `POST` to CheckSubAgent endpoint with form data:
       - `postAction`: "CheckSub"
       - `ua`: username (default "subliminal")
       - `ap`: password (default "lanimilbus")
       - `fs`: file size in bytes
       - `fh`: computed hash
       - `fn`: filename (basename only)
    5. Parse pipe-delimited response. If response starts with "OK", it contains subtitle info.
    6. Build SubtitleResult with:
       - `subtitle_id`: extracted ID from response
       - `matches`: {"hash"} (hash match = highest score)
       - `format`: SubtitleFormat.SRT

    **download(result):**
    - Download URL from search response.
    - Returns ZIP file -- extract first .srt from it.

    **health_check():**
    - Simple POST with dummy data, check for non-error response.

    ---

    **Whisper-Subgen Provider:**

    Create `backend/providers/whisper_subgen.py`:

    Class: `WhisperSubgenProvider(SubtitleProvider)` with `@register_provider`.
    - `name = "whisper_subgen"`
    - `languages`: all Whisper-supported languages (en, ja, de, fr, es, it, pt, ru, zh, ko, ar, nl, pl, sv, cs, hu, tr, th, vi, id, hi, etc.)
    - `config_fields = [{"key": "endpoint", "label": "Subgen URL", "type": "text", "required": True, "default": "http://subgen:9000"}, {"key": "timeout", "label": "Timeout (seconds)", "type": "number", "required": False, "default": "600"}]`
    - `rate_limit = (2, 60)` -- very conservative, transcription is slow
    - `timeout = 600` -- 10 minutes for long files
    - `max_retries = 1` -- don't retry expensive operations

    **search(query):**
    1. Requires file_path. If no file_path or file doesn't exist, return [].
    2. Do NOT actually transcribe in search. Return a single "generatable" SubtitleResult:
       ```python
       SubtitleResult(
           provider_name=self.name,
           subtitle_id=f"whisper:{os.path.basename(query.file_path)}",
           language=query.languages[0] if query.languages else "en",
           format=SubtitleFormat.SRT,
           score=10,  # Very low -- last resort
           matches=set(),  # No matches = lowest priority
           provider_data={"file_path": query.file_path},
       )
       ```
    3. This ensures Whisper is only used when no other provider has results (scored last).

    **download(result):**
    1. Extract audio from the media file using ffmpeg:
       ```python
       import subprocess
       cmd = ["ffmpeg", "-i", file_path, "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1", "-f", "wav", "pipe:1"]
       proc = subprocess.run(cmd, capture_output=True, timeout=120)
       audio_data = proc.stdout
       ```
    2. POST audio to Subgen `/asr` endpoint:
       ```python
       resp = self.session.post(
           f"{self.endpoint}/asr",
           params={"task": "transcribe", "language": result.language, "output": "srt"},
           files={"audio_file": ("audio.wav", audio_data, "audio/wav")},
           timeout=self.config_timeout,
       )
       ```
    3. Return SRT content bytes.

    **health_check():**
    - `GET {endpoint}/health` or just check if endpoint is reachable.

    **Important constraints (from research):**
    - This is ONLY the external Subgen client (PROV-05). No local Whisper processing.
    - Phase 4 will build the full local Whisper backend.
    - Audio extraction requires ffmpeg to be installed (it's in the Docker image already).
    - Use configurable timeout (default 600s) -- transcription of a 24-min episode can take 30-300s.
  </action>
  <verify>
    - `cd backend && python -c "from providers.napisy24 import Napisy24Provider; p = Napisy24Provider(); assert p.name == 'napisy24'; assert 'pl' in p.languages; print('Napisy24 OK')"`
    - `cd backend && python -c "from providers.whisper_subgen import WhisperSubgenProvider; p = WhisperSubgenProvider(); assert p.name == 'whisper_subgen'; print('WhisperSubgen OK')"`
    - `cd backend && python -c "from providers import _PROVIDER_CLASSES; assert 'napisy24' in _PROVIDER_CLASSES and 'whisper_subgen' in _PROVIDER_CLASSES; print('Both registered')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30`
  </verify>
  <done>
    Napisy24Provider searches Polish subs via file hash with POST API. WhisperSubgenProvider delegates transcription to an external Subgen instance with configurable timeout. Both registered and follow provider patterns.
  </done>
</task>

</tasks>

<verification>
1. All three providers registered: `cd backend && python -c "from providers import _PROVIDER_CLASSES; names = set(_PROVIDER_CLASSES.keys()); assert {'kitsunekko', 'napisy24', 'whisper_subgen'}.issubset(names); print('All 3 registered:', sorted(names))"`
2. Provider status includes new providers via API.
3. All existing tests pass: `cd backend && python -m pytest tests/ -x -q --timeout=30`
</verification>

<success_criteria>
- KitsunekkoProvider: scrapes kitsunekko.net for Japanese anime subs, BS4 optional graceful degradation
- Napisy24Provider: file hash computation + POST API for Polish subs, ZIP extraction
- WhisperSubgenProvider: returns low-score placeholder in search, transcribes via ffmpeg + Subgen in download
- All three use @register_provider and declare config_fields
- All three handle errors gracefully (site down, missing ffmpeg, timeout)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-provider-plugin-expansion/01-05-SUMMARY.md`
</output>
