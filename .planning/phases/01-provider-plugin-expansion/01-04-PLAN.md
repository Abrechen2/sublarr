---
phase: 01-provider-plugin-expansion
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/providers/gestdown.py
  - backend/providers/podnapisi.py
autonomous: true

must_haves:
  truths:
    - "User can search and download subtitles from Gestdown (covers Addic7ed content)"
    - "User can search and download subtitles from Podnapisi"
    - "Both providers register via @register_provider and declare their own config_fields"
    - "Both providers handle rate limiting, errors, and archive extraction correctly"
  artifacts:
    - path: "backend/providers/gestdown.py"
      provides: "Gestdown REST API provider (Addic7ed proxy)"
      contains: "@register_provider"
      exports: ["GestdownProvider"]
    - path: "backend/providers/podnapisi.py"
      provides: "Podnapisi XML API provider"
      contains: "@register_provider"
      exports: ["PodnapisiProvider"]
  key_links:
    - from: "backend/providers/gestdown.py"
      to: "backend/providers/base.py"
      via: "extends SubtitleProvider ABC"
      pattern: "class GestdownProvider.SubtitleProvider"
    - from: "backend/providers/podnapisi.py"
      to: "backend/providers/base.py"
      via: "extends SubtitleProvider ABC"
      pattern: "class PodnapisiProvider.SubtitleProvider"
---

<objective>
Implement two low-complexity REST/XML-based providers: Gestdown (REST API, Addic7ed proxy covering PROV-01 and PROV-03) and Podnapisi (XML API, PROV-02). Both have stable APIs, no authentication required, and straightforward response formats.

Purpose: These are the easiest providers to implement and validate, establishing patterns for the remaining providers. Gestdown covers Addic7ed content without the anti-scraping issues.

Output: Two new built-in providers ready for subtitle search and download.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-provider-plugin-expansion/01-RESEARCH.md

# Plan 01 creates the declarative config_fields pattern this plan uses
@.planning/phases/01-provider-plugin-expansion/01-01-SUMMARY.md

@backend/providers/base.py
@backend/providers/__init__.py
@backend/providers/http_session.py
@backend/providers/animetosho.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Gestdown provider (Addic7ed proxy via REST API)</name>
  <files>backend/providers/gestdown.py</files>
  <action>
    Create `backend/providers/gestdown.py` implementing the Gestdown REST API:

    API Base: `https://api.gestdown.info`

    Class: `GestdownProvider(SubtitleProvider)` with `@register_provider` decorator.
    - `name = "gestdown"` (satisfies both PROV-01 Addic7ed and PROV-03 Gestdown)
    - `languages`: large set of European + Asian languages supported by Addic7ed (en, de, fr, es, it, pt, nl, pl, sv, da, no, fi, cs, hu, tr, ro, el, he, ar, zh, ja, ko, ru, etc.)
    - `config_fields = []` -- no auth required
    - `rate_limit = (30, 60)` -- conservative rate limit
    - `timeout = 15`
    - `max_retries = 2`

    **search(query) implementation:**
    1. TV shows only (Gestdown does not support movies). If `query.is_movie`, return [].
    2. Look up show by TVDB ID first (most accurate): `GET /shows/external/tvdb/{tvdb_id}`.
    3. If no TVDB ID or lookup fails, search by name: `GET /shows/search/{series_title}`.
    4. For each matching show, get subtitles: `GET /subtitles/get/{show_id}/{season}/{episode}/{language_code}`.
    5. Map Gestdown language codes to ISO 639-1. Gestdown uses its own language IDs -- make a lookup request `GET /languages` on first use and cache the mapping.
    6. Filter to `completed: true` subtitles only.
    7. Build `SubtitleResult` objects with:
       - `subtitle_id`: the Gestdown subtitle UUID
       - `download_url`: the `downloadUri` from the API response
       - `filename`: from API response
       - `format`: detect from filename extension (.srt most common)
       - `matches`: set with "series" if show matched, "episode" if season+episode matched
       - `release_info`: the subtitle version/release name from API

    **download(result) implementation:**
    - `GET {download_url}` with `allow_redirects=True`
    - Gestdown returns the subtitle file directly (no archive)
    - Return `resp.content`

    **health_check():**
    - `GET /shows/search/test` -- if 200, healthy

    Handle HTTP 429 (rate limit) by raising ProviderRateLimitError.
    Handle HTTP 423 (locked/retry) by waiting 1s and retrying once.

    Follow the animetosho.py pattern for structure: same imports, session creation via create_session(), logging pattern.
  </action>
  <verify>
    - `cd backend && python -c "from providers.gestdown import GestdownProvider; p = GestdownProvider(); assert p.name == 'gestdown'; assert len(p.config_fields) == 0; print('Gestdown provider OK')"`
    - `cd backend && python -c "from providers import _PROVIDER_CLASSES; assert 'gestdown' in _PROVIDER_CLASSES; print('Gestdown registered')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30`
  </verify>
  <done>
    GestdownProvider is registered, searches Addic7ed content via REST API with TVDB ID or name lookup, downloads SRT subtitles directly, handles rate limits and retries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Podnapisi provider (XML API)</name>
  <files>backend/providers/podnapisi.py</files>
  <action>
    Create `backend/providers/podnapisi.py` implementing the Podnapisi XML API:

    API Base: `https://www.podnapisi.net`

    Class: `PodnapisiProvider(SubtitleProvider)` with `@register_provider` decorator.
    - `name = "podnapisi"`
    - `languages`: European language focus (en, de, fr, es, it, pt, sl, hr, sr, bs, cs, sk, pl, hu, ro, bg, tr, el, nl, sv, da, no, fi, etc.)
    - `config_fields = []` -- no auth required
    - `rate_limit = (30, 60)` -- conservative
    - `timeout = 15`
    - `max_retries = 2`

    **search(query) implementation:**
    1. Build search params: `sXML=1` (XML response), `sK` (search keyword = series_title or title).
    2. Add optional params: `sTS` (season), `sTE` (episode), `sY` (year).
    3. Add language param: `sL` (Podnapisi language code -- map from ISO 639-1 to Podnapisi's numeric codes using a lookup dict, common ones: en=2, de=14, fr=8, es=28, etc.).
    4. `GET /subtitles/search/old` with params.
    5. Parse XML response using `lxml.etree.fromstring()`:
       - Root: `<results>`, each subtitle: `<subtitle>`.
       - Extract: `<pid>` (ID), `<release>` (filename/release info), `<language>` (code), `<flags>` (hearing impaired check), `<downloads>` (popularity).
    6. Build `SubtitleResult` for each subtitle:
       - `subtitle_id`: pid value
       - `download_url`: `https://www.podnapisi.net/subtitles/{pid}/download`
       - `format`: detect from release info or default to SRT
       - `matches`: build from what query fields matched
       - `release_info`: the release string

    **download(result) implementation:**
    - `GET {download_url}` -- returns a ZIP archive
    - Extract the first subtitle file (.srt, .ass, .ssa) from the ZIP using zipfile module
    - Return extracted content bytes

    **health_check():**
    - `GET /subtitles/search/old?sXML=1&sK=test&sJ=1` -- if 200 with XML, healthy

    Handle lxml import gracefully: if lxml not installed, fall back to xml.etree.ElementTree from stdlib (with a warning log that performance may be degraded).
  </action>
  <verify>
    - `cd backend && python -c "from providers.podnapisi import PodnapisiProvider; p = PodnapisiProvider(); assert p.name == 'podnapisi'; print('Podnapisi provider OK')"`
    - `cd backend && python -c "from providers import _PROVIDER_CLASSES; assert 'podnapisi' in _PROVIDER_CLASSES; print('Podnapisi registered')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30`
  </verify>
  <done>
    PodnapisiProvider is registered, searches via XML API with language/season/episode filtering, downloads and extracts subtitles from ZIP archives, handles XML parsing with lxml (or stdlib fallback).
  </done>
</task>

</tasks>

<verification>
1. Both providers registered: `cd backend && python -c "from providers import _PROVIDER_CLASSES; assert 'gestdown' in _PROVIDER_CLASSES and 'podnapisi' in _PROVIDER_CLASSES; print('Both providers registered:', list(_PROVIDER_CLASSES.keys()))"`
2. Provider status includes new providers: start test app, GET /api/v1/providers should list gestdown and podnapisi.
3. All existing tests pass: `cd backend && python -m pytest tests/ -x -q --timeout=30`
</verification>

<success_criteria>
- GestdownProvider registered with name "gestdown", searches Addic7ed content via REST API
- PodnapisiProvider registered with name "podnapisi", searches via XML API
- Both use @register_provider decorator and declare config_fields
- Both handle rate limits, timeouts, and errors properly
- Both follow existing provider patterns (session creation, logging, result building)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-provider-plugin-expansion/01-04-SUMMARY.md`
</output>
