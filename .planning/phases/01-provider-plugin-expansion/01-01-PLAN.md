---
phase: 01-provider-plugin-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/providers/base.py
  - backend/providers/__init__.py
  - backend/providers/plugins/__init__.py
  - backend/providers/plugins/loader.py
  - backend/providers/plugins/manifest.py
  - backend/db/plugins.py
  - backend/providers/animetosho.py
  - backend/providers/jimaku.py
  - backend/providers/opensubtitles.py
  - backend/providers/subdl.py
  - backend/routes/plugins.py
  - backend/routes/__init__.py
  - backend/app.py
  - backend/config.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "A Python file dropped into the plugins directory is discovered, validated, and registered as a usable provider on app startup"
    - "A new provider can expose config fields that automatically appear in the Settings UI without modifying ProviderManager code"
    - "Plugin config is stored in config_entries table with namespaced keys and persists across restarts"
    - "Name collisions between plugins and built-in providers are detected and rejected with clear error messages"
    - "A bad plugin (syntax error, missing dependency, missing required methods) does not prevent the app from starting -- errors are caught and logged, not propagated"
  artifacts:
    - path: "backend/providers/base.py"
      provides: "Extended SubtitleProvider ABC with config_fields class attribute"
      contains: "config_fields"
    - path: "backend/providers/plugins/__init__.py"
      provides: "PluginManager class for discovery, loading, validation"
      exports: ["PluginManager", "get_plugin_manager"]
    - path: "backend/providers/plugins/loader.py"
      provides: "importlib-based module loader for plugin files"
      contains: "spec_from_file_location"
    - path: "backend/providers/plugins/manifest.py"
      provides: "PluginManifest dataclass and validation logic"
      contains: "PluginManifest"
    - path: "backend/db/plugins.py"
      provides: "Plugin config CRUD with namespaced config_entries storage"
      contains: "get_plugin_config"
    - path: "backend/routes/plugins.py"
      provides: "Plugin management API endpoints"
      contains: "bp = Blueprint"
  key_links:
    - from: "backend/providers/plugins/loader.py"
      to: "backend/providers/base.py"
      via: "issubclass check against SubtitleProvider"
      pattern: "issubclass.*SubtitleProvider"
    - from: "backend/providers/plugins/__init__.py"
      to: "backend/providers/__init__.py"
      via: "registers discovered plugins into _PROVIDER_CLASSES"
      pattern: "_PROVIDER_CLASSES"
    - from: "backend/providers/__init__.py"
      to: "backend/db/plugins.py"
      via: "reads plugin config from DB for provider initialization"
      pattern: "get_plugin_config"
    - from: "backend/app.py"
      to: "backend/providers/plugins/__init__.py"
      via: "initializes PluginManager during create_app"
      pattern: "get_plugin_manager"
---

<objective>
Build the plugin infrastructure that transforms Sublarr's hardcoded provider system into a plugin-based architecture. This plan refactors the provider base class to support declarative config_fields, creates the plugin auto-discovery system (importlib-based file scanning), adds plugin manifest validation, implements namespaced config storage in the database, and exposes plugin management API endpoints.

Purpose: This is the foundation for all new providers and third-party plugins. Without this, every new provider requires code changes to ProviderManager's switch/case blocks and the Settings Pydantic model.

Output: Plugin system ready for provider registration -- both built-in (Plan 04-06) and external (user-dropped files).
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-provider-plugin-expansion/01-RESEARCH.md

@backend/providers/base.py
@backend/providers/__init__.py
@backend/providers/animetosho.py
@backend/config.py
@backend/db/__init__.py
@backend/db/providers.py
@backend/routes/providers.py
@backend/routes/__init__.py
@backend/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SubtitleProvider ABC with declarative class attributes and refactor ProviderManager</name>
  <files>
    backend/providers/base.py
    backend/providers/__init__.py
  </files>
  <action>
    1. In `backend/providers/base.py`, add new class attributes to `SubtitleProvider`:
       ```python
       config_fields: list[dict] = []
       # Each dict: {"key": str, "label": str, "type": "text"|"password"|"number", "required": bool, "default": str}
       ```
       Also add a `rate_limit` class attribute tuple: `rate_limit: tuple[int, int] = (0, 0)` (max_requests, window_seconds; 0,0 = no limit).
       Also add a `timeout` class attribute: `timeout: int = 30` (seconds).
       Also add a `max_retries` class attribute: `max_retries: int = 2`.
       Also add a `is_plugin` class attribute: `is_plugin: bool = False` (True for externally loaded plugins).

    2. In `backend/providers/__init__.py`:
       a. Add collision check to `register_provider()`: if `cls.name` already in `_PROVIDER_CLASSES`, log a warning and skip (built-in providers always win).
       b. Replace `_get_provider_config()` switch/case: instead of hardcoded per-name config, read config from the provider class's `config_fields` declarations. For each field in the provider class's `config_fields`, look up the value from: (1) Pydantic Settings via `getattr(self.settings, field["key"], "")`, then (2) plugin config from DB if provider `is_plugin`. Strip whitespace from credential values. Keep backward compatibility: the existing 4 built-in providers still work with their existing Settings fields.
       c. Replace `_get_provider_config_fields()` static method: instead of hardcoded `fields_map`, read from `_PROVIDER_CLASSES[name].config_fields`. Return an empty list if the class has no `config_fields`.
       d. Replace hardcoded `PROVIDER_RATE_LIMITS`, `PROVIDER_TIMEOUTS`, `PROVIDER_RETRIES` dicts: read from provider class attributes (`rate_limit`, `timeout`, `max_retries`). Keep the dicts as fallbacks for backward compat but prefer the class attribute.
       e. In `_init_providers()`, after importing built-in providers, call `_load_plugins()` which imports from the plugin manager (deferred to Task 3 -- for now, add the method stub that does nothing if plugin manager is not available).
  </action>
  <verify>
    - `cd backend && python -c "from providers.base import SubtitleProvider; assert hasattr(SubtitleProvider, 'config_fields'); assert hasattr(SubtitleProvider, 'is_plugin'); print('ABC extended OK')"`
    - `cd backend && python -c "from providers import _PROVIDER_CLASSES; assert len(_PROVIDER_CLASSES) >= 4; print('Providers still registered:', list(_PROVIDER_CLASSES.keys()))"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30` (existing tests still pass)
  </verify>
  <done>
    SubtitleProvider ABC has config_fields, rate_limit, timeout, max_retries, is_plugin class attributes. ProviderManager reads from class attributes instead of hardcoded switch/case. _load_plugins() stub ready for Task 3. Existing behavior preserved.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update 4 built-in providers to declare their own config_fields and operational attributes</name>
  <files>
    backend/providers/animetosho.py
    backend/providers/jimaku.py
    backend/providers/opensubtitles.py
    backend/providers/subdl.py
  </files>
  <action>
    Add declarative class attributes to each existing built-in provider. Keep the exact same key names as currently used in the Pydantic Settings model so the existing config cascade continues to work. The `register_provider` decorator remains in `__init__.py`; built-in providers still use it.

    - `animetosho.py`: Add to the class body:
      ```python
      config_fields = []  # no auth needed
      rate_limit = (50, 30)
      timeout = 20
      max_retries = 2
      ```

    - `jimaku.py`: Add to the class body:
      ```python
      config_fields = [
          {"key": "jimaku_api_key", "label": "API Key", "type": "password", "required": True}
      ]
      rate_limit = (100, 60)
      timeout = 30
      max_retries = 2
      ```

    - `opensubtitles.py`: Add to the class body:
      ```python
      config_fields = [
          {"key": "opensubtitles_api_key", "label": "API Key", "type": "password", "required": True},
          {"key": "opensubtitles_username", "label": "Username", "type": "text", "required": False},
          {"key": "opensubtitles_password", "label": "Password", "type": "password", "required": False},
      ]
      rate_limit = (40, 10)
      timeout = 15
      max_retries = 3
      ```

    - `subdl.py`: Add to the class body:
      ```python
      config_fields = [
          {"key": "subdl_api_key", "label": "API Key", "type": "password", "required": True}
      ]
      rate_limit = (30, 10)
      timeout = 15
      max_retries = 2
      ```

    Verify that the ProviderManager's refactored `_get_provider_config()` (from Task 1) correctly reads these declarations and produces identical config dicts to the old hardcoded approach.
  </action>
  <verify>
    - `cd backend && python -c "from providers import _PROVIDER_CLASSES; print([f'{n}: {len(c.config_fields)} fields' for n, c in _PROVIDER_CLASSES.items()])"`
    - `cd backend && python -c "from providers.jimaku import JimakuProvider; assert JimakuProvider.config_fields[0]['key'] == 'jimaku_api_key'; print('Jimaku config_fields OK')"`
    - `cd backend && python -c "from providers.opensubtitles import OpenSubtitlesProvider; assert len(OpenSubtitlesProvider.config_fields) == 3; print('OpenSubs config_fields OK')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30` (existing tests still pass)
  </verify>
  <done>
    All 4 built-in providers declare their own config_fields, rate_limit, timeout, and max_retries. ProviderManager reads these instead of hardcoded values. Existing config cascade preserved.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create plugin discovery system, manifest validation, DB config storage, and API endpoints</name>
  <files>
    backend/providers/plugins/__init__.py
    backend/providers/plugins/loader.py
    backend/providers/plugins/manifest.py
    backend/db/plugins.py
    backend/providers/__init__.py
    backend/config.py
    backend/routes/plugins.py
    backend/routes/__init__.py
    backend/app.py
    backend/requirements.txt
  </files>
  <action>
    1. Create `backend/providers/plugins/` package:

    2. `backend/providers/plugins/manifest.py`:
       - Define `PluginManifest` dataclass: name (str), version (str), author (str, default=""), description (str, default=""), min_sublarr_version (str, default=""), config_fields (list[dict], default_factory=list), languages (list[str], default_factory=list), requires_auth (bool, default=False).
       - Define `validate_plugin(cls, existing_names: set[str]) -> tuple[bool, str]`: checks that cls has `name` attribute (non-empty), cls.name not in existing_names, cls has `search` method (callable), cls has `download` method (callable), cls is a subclass of SubtitleProvider. Returns (True, "OK") or (False, reason_string).
       - Define `extract_manifest(cls) -> PluginManifest`: reads class attributes to build manifest. Uses getattr with defaults for optional fields.
       - NOTE on safe import: Validation uses exception catching only, no sandboxing. Plugins run in the same process, same trust model as Bazarr's plugin system. A malicious plugin could do anything -- this is documented as a known limitation. Validation catches accidental errors (missing methods, name collisions, syntax errors), not intentional abuse.

    3. `backend/providers/plugins/loader.py`:
       - Define `discover_plugins(plugins_dir: str, existing_names: set[str]) -> tuple[dict[str, type], list[dict]]`:
         - Scans `plugins_dir` for `*.py` files (skip files starting with `_` or `.`).
         - For each file, uses `importlib.util.spec_from_file_location` + `module_from_spec` + `exec_module` to load.
         - Wraps each module load in try/except to prevent bad plugins from crashing the app. Catches Exception broadly (including ImportError, SyntaxError, AttributeError) and logs the traceback.
         - For each loaded module, inspects members for SubtitleProvider subclasses (using inspect.getmembers + isclass + issubclass).
         - Validates each discovered class using `validate_plugin()`.
         - Returns (discovered_classes_dict, errors_list) where errors_list is [{"file": str, "error": str}].
       - Define `unload_plugin(module_name: str)`: removes from `sys.modules`.

    4. `backend/providers/plugins/__init__.py`:
       - Define `PluginManager` class:
         - `__init__(self, plugins_dir: str)`: stores plugins_dir, initializes empty `_loaded` dict, empty `_errors` list.
         - `discover(self) -> tuple[list[str], list[dict]]`: calls `discover_plugins()` with current `_PROVIDER_CLASSES` names as existing_names. For each valid plugin, sets `cls.is_plugin = True` and registers it in `_PROVIDER_CLASSES` via direct assignment (not the decorator). Returns (loaded_names, errors).
         - `reload(self) -> tuple[list[str], list[dict]]`: unloads all currently loaded plugins (removes from `_PROVIDER_CLASSES` and `sys.modules`), then calls `discover()` again.
         - `get_plugin_info(self) -> list[dict]`: returns info about loaded plugins (name, version, author, etc from manifest).
       - Define module-level `_plugin_manager: Optional[PluginManager] = None`.
       - Define `get_plugin_manager() -> Optional[PluginManager]` and `init_plugin_manager(plugins_dir: str) -> PluginManager`.

    5. `backend/db/plugins.py`:
       - `get_plugin_config(provider_name: str) -> dict`: reads from `config_entries` table where key starts with `plugin.<provider_name>.`. Returns dict with the prefix stripped.
       - `set_plugin_config(provider_name: str, key: str, value: str)`: writes to `config_entries` with key `plugin.<provider_name>.<key>`.
       - `get_all_plugin_configs() -> dict[str, dict]`: gets all `plugin.*` entries grouped by provider name.
       - `delete_plugin_config(provider_name: str)`: deletes all config entries for a plugin.

    6. Add `SUBLARR_PLUGINS_DIR` to `backend/config.py` Settings class:
       ```python
       plugins_dir: str = "/config/plugins"
       ```

    7. Wire into `backend/providers/__init__.py`: update the `_load_plugins()` stub from Task 1 to actually call `init_plugin_manager(settings.plugins_dir)` and `manager.discover()`. In `_get_provider_config()`, if the provider class has `is_plugin = True`, read config from `get_plugin_config()` instead of Pydantic Settings.

    8. Create `backend/routes/plugins.py` with Blueprint `bp = Blueprint("plugins", __name__, url_prefix="/api/v1")`:
       - `GET /plugins` -- list all loaded plugins with their manifest info, enabled state, and config fields. Calls `get_plugin_manager().get_plugin_info()`. Returns `{"plugins": [...]}`.
       - `POST /plugins/reload` -- trigger plugin re-discovery. Calls `get_plugin_manager().reload()`. Also calls `invalidate_manager()` from providers to re-init the ProviderManager with new plugins. Returns `{"loaded": [...], "errors": [...]}`.
       - `GET /plugins/<name>/config` -- get config for a specific plugin. Reads from `get_plugin_config(name)`. Returns `{"config": {...}}`.
       - `PUT /plugins/<name>/config` -- update config for a plugin. Accepts JSON body with key-value pairs. Writes each to `set_plugin_config()`. Then calls `invalidate_manager()` to re-init providers with new config. Returns `{"status": "updated"}`.

    9. Register the plugins blueprint in `backend/routes/__init__.py`: add `from routes.plugins import bp as plugins_bp` and include it in the blueprint list.

    10. In `backend/app.py`, in `create_app()`, after `init_db()` and before `register_blueprints()`, add plugin initialization:
        ```python
        # Initialize plugin system
        from providers.plugins import init_plugin_manager
        plugins_dir = settings.plugins_dir
        if plugins_dir:
            import os
            os.makedirs(plugins_dir, exist_ok=True)
            plugin_mgr = init_plugin_manager(plugins_dir)
            loaded, errors = plugin_mgr.discover()
            if loaded:
                logger.info("Loaded %d plugins: %s", len(loaded), loaded)
            if errors:
                for err in errors:
                    logger.warning("Plugin load error: %s â€” %s", err["file"], err["error"])
        ```

    11. Add `backend/requirements.txt` entries for new dependencies (needed by Plan 04-06 providers but best to add now):
        ```
        beautifulsoup4>=4.12.0
        lxml>=5.1.0
        watchdog>=6.0.0
        guessit>=3.8.0
        ```
  </action>
  <verify>
    - `cd backend && python -c "from providers.plugins import PluginManager; print('PluginManager imported OK')"`
    - `cd backend && python -c "from providers.plugins.manifest import PluginManifest, validate_plugin; print('Manifest imported OK')"`
    - `cd backend && python -c "from providers.plugins.loader import discover_plugins; print('Loader imported OK')"`
    - `cd backend && python -c "from db.plugins import get_plugin_config, set_plugin_config; print('DB plugins imported OK')"`
    - `cd backend && python -c "from config import get_settings; s = get_settings(); assert hasattr(s, 'plugins_dir'); print('plugins_dir:', s.plugins_dir)"`
    - `cd backend && python -c "from routes.plugins import bp; print('plugins blueprint:', bp.name, bp.url_prefix)"`
    - `cd backend && python -c "from routes import register_blueprints; print('register_blueprints imports OK')"`
    - `cd backend && python -m pytest tests/ -x -q --timeout=30` (existing tests still pass)
  </verify>
  <done>
    PluginManager discovers .py files from plugins_dir, validates SubtitleProvider subclasses (safe import = exception catching, no sandboxing), registers them in _PROVIDER_CLASSES with is_plugin=True. Plugin config reads/writes to config_entries with namespaced keys. Bad plugins log errors but don't crash the app. Plugin management API is accessible at /api/v1/plugins. Blueprint is registered in the app factory. Plugin discovery runs on startup.
  </done>
</task>

</tasks>

<verification>
1. Start the app with `cd backend && python -c "from app import create_app; app = create_app(testing=True); print('App created OK')"` -- should initialize without errors.
2. Verify provider status still works: `cd backend && python -c "from app import create_app; app = create_app(testing=True); client = app.test_client(); resp = client.get('/api/v1/providers'); print(resp.status_code, resp.get_json()['providers'][0]['name'])"` -- should return 200 with existing providers.
3. Verify plugin endpoints exist: test client GET /api/v1/plugins should return 200 with empty plugins list.
4. Verify no regression: `cd backend && python -m pytest tests/ -x -q --timeout=30`
</verification>

<success_criteria>
- SubtitleProvider ABC has config_fields, rate_limit, timeout, max_retries, is_plugin class attributes
- All 4 built-in providers declare their own config_fields (matching existing Pydantic Settings keys)
- ProviderManager._get_provider_config() reads from class attributes, not hardcoded switch/case
- ProviderManager._get_provider_config_fields() reads from class attributes, not hardcoded dict
- PluginManager discovers .py files, validates them, and registers valid SubtitleProvider subclasses
- Safe import = exception catching only (no sandboxing, same trust model as Bazarr)
- Plugin config stored in config_entries with "plugin.<name>.<key>" namespacing
- API endpoints: GET /plugins, POST /plugins/reload, GET/PUT /plugins/<name>/config
- Name collision detection prevents duplicate provider names
- Bad plugins do not crash the app (caught and logged)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-provider-plugin-expansion/01-01-SUMMARY.md`
</output>
