---
phase: 04-whisper-speech-to-text
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/routes/__init__.py
  - backend/routes/whisper.py
  - backend/translator.py
  - backend/providers/whisper_subgen.py
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/whisper/transcribe submits a job to the queue and returns job_id"
    - "GET /api/v1/whisper/queue returns list of all Whisper jobs with progress"
    - "GET /api/v1/whisper/jobs/<id> returns a specific job's status and result"
    - "GET /api/v1/whisper/backends returns available Whisper backends with config"
    - "POST /api/v1/whisper/backends/test/<name> tests a specific Whisper backend"
    - "When all providers fail in translate_file, Case D submits a Whisper job and returns whisper_pending status"
    - "WhisperSubgenProvider is deprecated with import warning and no-op behavior"
  artifacts:
    - path: "backend/routes/whisper.py"
      provides: "Whisper API blueprint with transcribe, queue, backends endpoints"
      exports: ["bp"]
    - path: "backend/translator.py"
      provides: "Case D integration after Case C4 failure"
      contains: "Case D"
    - path: "backend/routes/__init__.py"
      provides: "Updated blueprint registration including whisper_bp"
      contains: "whisper"
    - path: "backend/providers/whisper_subgen.py"
      provides: "Deprecated provider with warning logs"
      contains: "deprecated"
  key_links:
    - from: "backend/routes/whisper.py"
      to: "backend/whisper/__init__.py"
      via: "get_whisper_manager() for backend operations"
      pattern: "from whisper import get_whisper_manager"
    - from: "backend/routes/whisper.py"
      to: "backend/whisper/queue.py"
      via: "WhisperQueue for job submission"
      pattern: "from whisper\\.queue import"
    - from: "backend/translator.py"
      to: "backend/whisper/__init__.py"
      via: "Case D whisper fallback"
      pattern: "get_whisper_manager|_is_whisper_enabled"
    - from: "backend/routes/__init__.py"
      to: "backend/routes/whisper.py"
      via: "blueprint registration"
      pattern: "from routes\\.whisper import bp"
---

<objective>
Wire the whisper/ package into the Flask application: create the Whisper API blueprint with transcription and backend management endpoints, integrate Case D into translator.py as the Whisper fallback after all providers fail, register the new blueprint, and deprecate the old WhisperSubgenProvider.

Purpose: This plan connects the self-contained whisper/ package (Plan 01) to the rest of the application. After this plan, Whisper transcription is available via both the REST API (manual trigger) and the translation pipeline (automatic fallback).

Output: Whisper API routes, Case D in translator.py, updated blueprint registration, deprecated WhisperSubgenProvider
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-whisper-speech-to-text/04-RESEARCH.md
@.planning/phases/04-whisper-speech-to-text/04-01-SUMMARY.md

Key pattern references:
@backend/routes/mediaservers.py (API blueprint pattern for backends with test/config)
@backend/routes/translate.py (backend management endpoints pattern, _run_job background thread)
@backend/routes/__init__.py (blueprint registration)
@backend/translator.py (translate_file function, Cases A-C, Case C4 integration point)
@backend/providers/whisper_subgen.py (to deprecate)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Whisper API blueprint and blueprint registration</name>
  <files>
    backend/routes/whisper.py
    backend/routes/__init__.py
  </files>
  <action>
    Create the Whisper API blueprint following the established patterns from routes/mediaservers.py and routes/translate.py.

    **backend/routes/whisper.py** -- New blueprint:
    - `bp = Blueprint("whisper", __name__, url_prefix="/api/v1/whisper")`
    - Endpoints:

    1. `POST /transcribe` -- Submit a transcription job:
       - Accepts JSON: {"file_path": str, "language": str (optional, defaults to source_language from config)}
       - Generates job_id via uuid.uuid4().hex
       - Gets WhisperQueue singleton (import from whisper.queue or create module-level)
       - Submits job to queue with socketio from extensions
       - Returns 202 {"job_id": ..., "status": "queued"}

    2. `GET /queue` -- List all Whisper jobs:
       - Optional query params: status (filter), limit (default 50)
       - Returns 200 with list of job dicts from db/whisper.py get_whisper_jobs()

    3. `GET /jobs/<job_id>` -- Get specific job status:
       - Returns 200 with job dict, or 404 if not found

    4. `DELETE /jobs/<job_id>` -- Cancel/delete a job:
       - If job is queued: mark cancelled
       - If job is completed/failed: delete from DB
       - Returns 200 {"success": true} or 404

    5. `GET /backends` -- List available Whisper backends:
       - Returns 200 with list from get_whisper_manager().get_all_backends()

    6. `POST /backends/test/<name>` -- Test a specific Whisper backend:
       - Gets backend from manager, calls health_check()
       - Returns 200 {"healthy": bool, "message": str}

    7. `GET /backends/config/<name>` -- Get backend config:
       - Reads from config_entries with whisper.<name>.<key> namespacing
       - Masks password fields (same pattern as routes/translate.py backend config)
       - Returns 200 with config dict

    8. `PUT /backends/config/<name>` -- Save backend config:
       - Accepts JSON config dict
       - Saves to config_entries with whisper.<name>.<key> namespacing
       - Invalidates cached backend instance
       - Returns 200 {"success": true}

    9. `PUT /config` -- Save global Whisper config:
       - Accepts JSON: {"whisper_backend": str, "max_concurrent_whisper": int, "whisper_enabled": bool}
       - Saves to config_entries
       - Returns 200 {"success": true}

    10. `GET /config` -- Get global Whisper config:
        - Reads whisper_backend, max_concurrent_whisper, whisper_enabled from config_entries
        - Returns 200 with config dict

    11. `GET /stats` -- Get Whisper statistics:
        - Returns 200 with stats from db/whisper.py get_whisper_stats()

    Module-level singleton for WhisperQueue:
    ```python
    _queue: Optional[WhisperQueue] = None
    def _get_queue() -> WhisperQueue:
        global _queue
        if _queue is None:
            max_concurrent = int(_get_config("max_concurrent_whisper", "1"))
            _queue = WhisperQueue(max_concurrent=max_concurrent)
        return _queue
    ```

    **backend/routes/__init__.py** -- Add whisper blueprint:
    - Add `from routes.whisper import bp as whisper_bp` to imports
    - Add `whisper_bp` to the blueprint list
  </action>
  <verify>
    python -c "from routes.whisper import bp; print(f'Blueprint OK: {bp.name}, prefix: {bp.url_prefix}')"
    python -c "from routes import register_blueprints; print('Registration OK')"
    grep -c "whisper_bp" backend/routes/__init__.py  # Should be 2 (import + list)
  </verify>
  <done>
    Whisper API blueprint is registered and serves all endpoints for transcription job management, backend configuration, and statistics. WhisperQueue singleton manages concurrent jobs with WebSocket progress events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Case D integration in translator.py and WhisperSubgenProvider deprecation</name>
  <files>
    backend/translator.py
    backend/providers/whisper_subgen.py
  </files>
  <action>
    **backend/translator.py** -- Add Case D after Case C4:

    After the line `logger.warning("Case C4: No source subtitle found for %s", mkv_path)` and before the return statement, add Case D:

    ```python
    # === CASE D: Whisper transcription as last resort ===
    if _is_whisper_enabled():
        logger.info("Case D: No subtitle source found, attempting Whisper transcription for %s", mkv_path)
        whisper_result = _submit_whisper_job(mkv_path, arr_context)
        if whisper_result:
            return whisper_result
        logger.warning("Case D: Whisper transcription not available or failed to submit for %s", mkv_path)
    ```

    Add two helper functions (place near the other helper functions in the module):

    ```python
    def _is_whisper_enabled() -> bool:
        """Check if Whisper transcription is enabled in config."""
        try:
            from db.config import get_config_entry
            enabled = get_config_entry("whisper_enabled")
            return enabled and enabled.lower() in ("true", "1", "yes")
        except Exception:
            return False

    def _submit_whisper_job(mkv_path: str, arr_context: dict = None) -> Optional[dict]:
        """Submit a Whisper transcription job for the given media file.

        Case D is async: submits to the Whisper queue and returns a
        'whisper_pending' status. The queue worker handles transcription and
        can re-enter the translation pipeline after completion.

        Returns:
            Dict with status='whisper_pending' and job_id, or None if Whisper
            is not available.
        """
        try:
            from whisper import get_whisper_manager
            from whisper.queue import WhisperQueue
            from routes.whisper import _get_queue
            from extensions import socketio
            import uuid

            manager = get_whisper_manager()
            backend = manager.get_active_backend()
            if not backend:
                logger.info("Case D: No Whisper backend configured")
                return None

            # Determine source language from config or arr_context
            settings = get_settings()
            source_lang = settings.source_language or "ja"

            job_id = uuid.uuid4().hex
            queue = _get_queue()
            queue.submit(
                job_id=job_id,
                file_path=mkv_path,
                language=source_lang,
                source_language=source_lang,
                whisper_manager=manager,
                socketio=socketio,
            )

            logger.info("Case D: Submitted Whisper job %s for %s (language: %s)",
                        job_id, os.path.basename(mkv_path), source_lang)

            return {
                "success": True,
                "status": "whisper_pending",
                "whisper_job_id": job_id,
                "message": f"Whisper transcription queued (job {job_id[:8]}...)",
                "stats": {"source": "whisper", "whisper_job_id": job_id},
            }
        except Exception as e:
            logger.warning("Case D: Failed to submit Whisper job: %s", e)
            return None
    ```

    Update the docstring of translate_file() to mention Case D:
    - Add to the existing docstring after Case C documentation:
    ```
    CASE D: Whisper transcription (if enabled):
        D1: Submit audio transcription to Whisper queue â†’ returns whisper_pending
    ```

    **backend/providers/whisper_subgen.py** -- Deprecate:
    - Add deprecation warning at module level:
      ```python
      import warnings
      warnings.warn(
          "WhisperSubgenProvider is deprecated. Use the Whisper backend system "
          "(whisper/subgen_backend.py) instead. This provider will be removed in v1.0.0.",
          DeprecationWarning,
          stacklevel=2,
      )
      ```
    - Change the search() method to return empty list with a deprecation log:
      ```python
      def search(self, query):
          logger.warning("WhisperSubgenProvider.search() is deprecated. Use Whisper backend system instead.")
          return []
      ```
    - Change the download() method to raise ProviderError with deprecation message:
      ```python
      def download(self, result):
          raise ProviderError("WhisperSubgenProvider is deprecated. Use Whisper backend system instead.")
      ```
    - Keep the @register_provider decorator to avoid import errors, but the provider now does nothing.
    - Update the module docstring to state it is deprecated.
  </action>
  <verify>
    grep -n "Case D" backend/translator.py  # Should find Case D code
    grep -n "_is_whisper_enabled\|_submit_whisper_job" backend/translator.py  # Should find both helpers
    grep -n "deprecated" backend/providers/whisper_subgen.py  # Should find deprecation markers
    python -c "from translator import translate_file; print('translator imports OK')"
    python -c "from providers.whisper_subgen import WhisperSubgenProvider; print('Deprecated provider imports OK')"
  </verify>
  <done>
    translator.py has Case D that submits Whisper jobs when all providers fail (async, returns whisper_pending status). WhisperSubgenProvider is deprecated (search returns empty, download raises error, deprecation warning on import). The old provider no longer interferes with the new Whisper backend system.
  </done>
</task>

</tasks>

<verification>
- `python -c "from app import create_app; app = create_app(testing=True); print('App starts with whisper blueprint')"` -- No import errors
- `curl -X GET http://localhost:5765/api/v1/whisper/backends` -- Returns backend list
- `curl -X GET http://localhost:5765/api/v1/whisper/queue` -- Returns empty job list
- `curl -X GET http://localhost:5765/api/v1/whisper/config` -- Returns Whisper config
- `grep "Case D" backend/translator.py` -- Case D code present
- `grep "deprecated" backend/providers/whisper_subgen.py` -- Deprecation markers present
</verification>

<success_criteria>
- Whisper API blueprint registered and serving all endpoints (transcribe, queue, backends, config, stats)
- Case D in translator.py submits Whisper job after Case C4 failure when whisper_enabled is true
- WhisperSubgenProvider deprecated (no-op search, error on download, deprecation warning)
- Blueprint registration updated in routes/__init__.py
- No existing functionality broken (Cases A-C unchanged)
</success_criteria>

<output>
After completion, create `.planning/phases/04-whisper-speech-to-text/04-02-SUMMARY.md`
</output>
