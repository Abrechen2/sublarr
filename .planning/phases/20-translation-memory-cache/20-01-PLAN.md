---
phase: 20-translation-memory-cache
plan: 01
type: execute
wave: 1
depends_on: ["19-02"]
files_modified:
  - backend/db/models/translation.py
  - backend/db/repositories/translation.py
  - backend/db/translation.py
  - backend/translator.py
  - backend/db/migrations/versions/
  - backend/routes/translate.py
autonomous: true

must_haves:
  truths:
    - "Successfully translated lines are stored in a persistent cache keyed by source_lang, target_lang, and normalized source text"
    - "On subsequent translation runs, cached translations are reused for identical source lines without calling the LLM"
    - "Near-identical lines (configurable similarity threshold) can hit the cache"
    - "User can clear the translation memory cache via API"
  artifacts:
    - path: "backend/db/models/translation.py"
      provides: "TranslationMemory or TranslationCache ORM model"
    - path: "backend/db/migrations/versions/"
      provides: "Alembic migration for translation_memory table"
    - path: "backend/db/repositories/translation.py"
      provides: "lookup_translation_cache, store_translation_cache, clear_translation_cache"
    - path: "backend/translator.py"
      provides: "Cache lookup before LLM call; store on success"
  key_links:
    - from: "backend/translator.py"
      to: "backend/db/translation.py"
      via: "lookup_translation_cache / store_translation_cache"
    - from: "backend/routes/translate.py"
      to: "backend/db/translation.py"
      via: "clear_translation_cache for DELETE cache endpoint"
---

<objective>
Backend: persistent translation memory cache — store and reuse translations by (source_lang, target_lang, normalized_text).

Purpose: Reduce LLM calls and cost by reusing translations for identical or near-identical lines. Cache is keyed by source language, target language, and normalized source text; optional similarity matching for near-identical lines.

Output: New DB table (translation_memory or translation_cache), repository methods (lookup, store, clear), config for enable/similarity threshold, integration in translator.py (lookup before _translate_with_manager, store after success).
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

@backend/translator.py
@backend/db/translation.py
@backend/db/repositories/translation.py
@backend/db/models/translation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB model and migration for translation memory</name>
  <files>
    backend/db/models/translation.py
    backend/db/migrations/versions/
  </files>
  <action>
1. Add model TranslationMemory (or TranslationCache): id, source_lang (str), target_lang (str), source_text_normalized (str, indexed), translated_text (str), created_at. Optional: text_hash for fast lookup (hash of source_text_normalized). Unique constraint or index on (source_lang, target_lang, source_text_normalized) or (source_lang, target_lang, text_hash).
2. Alembic migration: create table translation_memory with the above columns; add index for lookup by (source_lang, target_lang, source_text_normalized).
  </action>
  <verify>
    Run: `cd backend && alembic upgrade head` and `python -c "from db.models.translation import TranslationMemory; print(TranslationMemory)"`.
  </verify>
  <done>
    Model and migration exist; table created successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Repository and facade for cache lookup/store/clear</name>
  <files>
    backend/db/repositories/translation.py
    backend/db/translation.py
  </files>
  <action>
1. Repository: add lookup_translation_cache(source_lang, target_lang, source_text_normalized) -> optional translated_text; add store_translation_cache(source_lang, target_lang, source_text_normalized, translated_text); add clear_translation_cache() for bulk delete. Normalization: strip, lower, collapse whitespace (define once, use consistently).
2. Optional: similarity lookup — for configurable threshold (e.g. 0.95), use simple ratio (e.g. difflib.SequenceMatcher) to find best match; if above threshold return cached translation. Config entry translation_memory_similarity_threshold (0.0 = exact only, 1.0 = any match); default 1.0 (exact only) to start is fine.
3. Facade in db/translation.py: expose lookup_translation_cache, store_translation_cache, clear_translation_cache.
  </action>
  <verify>
    Unit test: store a pair, lookup returns it; clear, lookup returns None.
  </verify>
  <done>
    Lookup (exact and optionally similar), store, and clear implemented and exposed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Translator integration and config</name>
  <files>
    backend/translator.py
    backend/db/config.py
  </files>
  <action>
1. Config: translation_memory_enabled (bool, default true), translation_memory_similarity_threshold (float, default 1.0 for exact). Store in config_entries.
2. In _translate_with_manager (or the layer that has the list of lines): before calling the manager, for each line normalize and lookup cache. Split lines into cached (indices + translations) and uncached (indices + texts). If all cached, return cached list in order; otherwise call manager only for uncached lines, then merge cached + newly translated, then store new translations in cache. Preserve order so output list matches input indices.
  </action>
  <verify>
    Run backend tests. Translate same file twice; second run should hit cache (fewer or no LLM calls if backend supports logging).
  </verify>
  <done>
    Translation pipeline uses cache when enabled; new translations are stored; order preserved.
  </done>
</task>

<task type="auto">
  <name>Task 4: API to clear cache and optional stats</name>
  <files>
    backend/routes/translate.py
  </files>
  <action>
1. DELETE /api/v1/translation-memory/cache (or POST /api/v1/translation-memory/clear) to clear the translation memory table. Require confirmation or no body.
2. Optional: GET /api/v1/translation-memory/stats returning e.g. { "entries": count } for frontend display.
  </action>
  <verify>
    curl DELETE clears cache; GET stats returns count (if implemented).
  </verify>
  <done>
    Clear endpoint implemented; stats optional.
  </done>
</task>

</tasks>

<verification>
1. Table translation_memory exists with source_lang, target_lang, source_text_normalized, translated_text.
2. Lookup (exact, optional similarity), store, clear work via repository/facade.
3. Translator uses cache before LLM and stores after success; config enables/disables and sets similarity.
4. API clears cache (and optionally returns stats).
</verification>

<success_criteria>
- Translated lines are cached by (source_lang, target_lang, normalized text).
- Subsequent runs reuse cached translations for identical lines.
- Optional near-identical matching via configurable threshold.
- User can clear cache via API.
</success_criteria>

<output>
After completion, create `.planning/phases/20-translation-memory-cache/20-01-SUMMARY.md`
</output>
