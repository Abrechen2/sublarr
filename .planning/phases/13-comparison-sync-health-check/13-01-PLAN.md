---
phase: 13-comparison-sync-health-check
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/health_checker.py
  - backend/db/models/quality.py
  - backend/db/repositories/quality.py
  - backend/db/quality.py
  - backend/routes/tools.py
autonomous: true

must_haves:
  truths:
    - "Health check engine detects duplicate lines, timing overlaps, encoding issues, and missing styles"
    - "Each subtitle file receives a 0-100 quality score derived from detected issues"
    - "Health check results are persisted in the database for trend tracking"
    - "Advanced sync operations (offset, speed multiplier, framerate conversion) work via pysubs2"
    - "Auto-fix functions can resolve detected issues with backup before applying"
    - "Comparison endpoint serves content of multiple subtitle files in a single response"
  artifacts:
    - path: "backend/health_checker.py"
      provides: "Health check detection engine with 10 check functions + auto-fix + score calculation"
      min_lines: 200
    - path: "backend/db/models/quality.py"
      provides: "SubtitleHealthResult ORM model"
      contains: "class SubtitleHealthResult"
    - path: "backend/db/repositories/quality.py"
      provides: "QualityRepository CRUD for health results"
      contains: "class QualityRepository"
    - path: "backend/db/quality.py"
      provides: "Convenience shim for quality repository"
      exports: ["save_health_result", "get_health_result", "get_quality_trends"]
    - path: "backend/routes/tools.py"
      provides: "4 new endpoints: health-check, health-fix, advanced-sync, compare"
  key_links:
    - from: "backend/routes/tools.py"
      to: "backend/health_checker.py"
      via: "import in health-check/health-fix endpoints"
      pattern: "from health_checker import"
    - from: "backend/routes/tools.py"
      to: "backend/db/quality.py"
      via: "save/fetch health results"
      pattern: "from db.quality import"
    - from: "backend/health_checker.py"
      to: "pysubs2"
      via: "subtitle parsing for all checks"
      pattern: "import pysubs2"
    - from: "backend/db/repositories/quality.py"
      to: "backend/db/models/quality.py"
      via: "ORM model import"
      pattern: "from db.models.quality import SubtitleHealthResult"
---

<objective>
Backend health-check engine, quality DB model/repository, advanced sync, and comparison/health API endpoints.

Purpose: Provide all backend infrastructure for Phase 13 -- health detection, quality persistence, advanced timing sync via pysubs2, auto-fix functions, and multi-file comparison serving. This is the foundation that Plans 02 and 03 consume via API.

Output: health_checker.py module, SubtitleHealthResult ORM + repository + shim, 4 new tools.py endpoints (health-check, health-fix, advanced-sync, compare).
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-comparison-sync-health-check/13-RESEARCH.md

@backend/routes/tools.py
@backend/db/models/core.py
@backend/db/repositories/base.py
@backend/db/repositories/__init__.py
@backend/db/quality.py
@backend/health_checker.py
@backend/ass_utils.py
@backend/routes/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Health-check engine + quality DB model/repository/shim</name>
  <files>
    backend/health_checker.py
    backend/db/models/quality.py
    backend/db/repositories/quality.py
    backend/db/quality.py
    backend/db/models/__init__.py
    backend/db/repositories/__init__.py
  </files>
  <action>
Create `backend/health_checker.py` with these components:

**HealthIssue dict structure:**
```python
{
    "check": str,           # check name (e.g., "duplicate_lines")
    "severity": str,        # "error", "warning", "info"
    "message": str,         # human-readable description
    "line": int | None,     # event index (1-based) or None
    "auto_fixable": bool,
    "fix": str | None,      # description of what fix does
}
```

**10 check functions** (each takes a pysubs2.SSAFile, returns list of issue dicts):
1. `check_duplicate_lines` -- exact duplicate (same start, end, text, style). Use set-based O(n) detection.
2. `check_timing_overlaps` -- overlapping events within same style+layer. Group by (style, layer), sort by start, check `curr.start < prev.end`. Severity: warning if overlap <500ms, error if >=500ms.
3. `check_encoding_issues` -- takes raw bytes too; detect BOM presence, non-UTF8 via chardet (with ImportError fallback). Severity: warning.
4. `check_missing_styles` -- ASS events referencing styles not in `subs.styles.keys()`. Severity: error. Skip if format is SRT.
5. `check_empty_events` -- events with empty `plaintext` (after strip). Severity: warning.
6. `check_excessive_duration` -- single event >10 seconds duration. Severity: info.
7. `check_negative_timing` -- end < start. Severity: error.
8. `check_zero_duration` -- start == end. Severity: warning.
9. `check_line_too_long` -- any line in plaintext >80 chars. Severity: info.
10. `check_missing_newlines` -- ASS dialogue text with >80 chars and no `\N` break. Severity: info. Skip for SRT.

**Orchestrator function:**
`run_health_checks(file_path: str) -> dict` -- loads file via pysubs2, runs all 10 checks, returns `{"file_path": str, "checks_run": int, "issues": list, "score": int, "checked_at": str}`. Quality score: 100 minus 10 per error, 3 per warning, 1 per info, clamped to 0.

**Auto-fix functions:**
- `fix_duplicate_lines(subs) -> int` -- remove duplicates, return count removed
- `fix_timing_overlaps(subs) -> int` -- trim prev.end to curr.start for same-style overlaps
- `fix_missing_styles(subs) -> int` -- change undefined style references to "Default"
- `fix_empty_events(subs) -> int` -- remove events with empty plaintext
- `fix_negative_timing(subs) -> int` -- swap start/end when end < start
- `fix_zero_duration(subs) -> int` -- remove zero-duration events

`apply_fixes(file_path: str, fix_names: list[str]) -> dict` -- loads file, applies requested fixes in order, saves, returns `{"fixes_applied": list, "counts": dict, "new_score": int}`. Must call `_create_backup` from tools.py pattern before saving (import not needed -- just use shutil.copy2 directly with same .bak pattern).

**Create `backend/db/models/quality.py`:**
```python
class SubtitleHealthResult(db.Model):
    __tablename__ = "subtitle_health_results"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    file_path: Mapped[str] = mapped_column(Text, nullable=False)
    score: Mapped[int] = mapped_column(Integer, nullable=False, default=100)
    issues_json: Mapped[str] = mapped_column(Text, default="[]")
    checks_run: Mapped[int] = mapped_column(Integer, default=0)
    checked_at: Mapped[str] = mapped_column(Text, nullable=False)
    __table_args__ = (
        Index("idx_health_results_path", "file_path"),
        Index("idx_health_results_score", "score"),
    )
```
Follow exact patterns from `db/models/core.py` -- use `from extensions import db`, `Mapped`, `mapped_column`.

**Add import in `db/models/__init__.py`:**
Add `from db.models.quality import SubtitleHealthResult` to the existing imports.

**Create `backend/db/repositories/quality.py`:**
```python
class QualityRepository(BaseRepository):
    def save_health_result(self, file_path, score, issues_json, checks_run, checked_at) -> dict
    def get_health_result(self, file_path) -> dict | None  # most recent for path
    def get_health_results_for_series(self, path_prefix) -> list[dict]  # all results under a series path
    def get_quality_trends(self, days=30) -> list[dict]  # daily avg score + issue count
    def delete_health_results(self, file_path) -> int  # cleanup
```
Follow patterns from `db/repositories/library.py` -- `self.session.query(Model)`, `self._to_dict()`, `self._commit()`.

**Add to `db/repositories/__init__.py`:**
Add `from db.repositories.quality import QualityRepository` and re-export.

**Create `backend/db/quality.py` convenience shim:**
Follow exact pattern from other shims (e.g., `db/config.py`). Thin wrapper with `_repo` and `_get_repo()` lazy init. Functions: `save_health_result`, `get_health_result`, `get_health_results_for_series`, `get_quality_trends`, `delete_health_results`.
  </action>
  <verify>
`cd backend && python -c "from health_checker import run_health_checks, apply_fixes; print('health_checker OK')"` succeeds.
`cd backend && python -c "from db.models.quality import SubtitleHealthResult; print('model OK')"` succeeds.
`cd backend && python -c "from db.repositories.quality import QualityRepository; print('repo OK')"` succeeds.
`cd backend && python -c "from db.quality import save_health_result, get_health_result, get_quality_trends; print('shim OK')"` succeeds.
  </verify>
  <done>
health_checker.py has 10 check functions, score calculation, and 6 auto-fix functions. SubtitleHealthResult ORM model exists with path and score indexes. QualityRepository provides CRUD + trend queries. Shim module provides convenience functions. All imports resolve without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Advanced sync, health-check, health-fix, and compare API endpoints in tools.py</name>
  <files>
    backend/routes/tools.py
    backend/routes/__init__.py
  </files>
  <action>
Extend `backend/routes/tools.py` with 4 new endpoints. All MUST use `_validate_file_path()` for security. All modifying endpoints MUST call `_create_backup()` before changes.

**1. POST /tools/health-check**
Accepts: `{"file_path": str}` or `{"file_paths": list[str]}` for batch.
- For single file: call `run_health_checks(file_path)`, save result via `save_health_result()`, return the result dict.
- For batch: iterate file_paths (max 50), run checks on each, save all, return `{"results": [...], "summary": {"total": N, "avg_score": float, "total_issues": int}}`.
- Lazy import: `from health_checker import run_health_checks` inside the function.
- Lazy import: `from db.quality import save_health_result` inside the function.
- OpenAPI docstring following existing tools.py pattern (human summary + `---` + YAML).

**2. POST /tools/health-fix**
Accepts: `{"file_path": str, "fixes": list[str]}` where fixes are check names (e.g., `["duplicate_lines", "timing_overlaps"]`).
- Validate fix_names against known fixable checks: `{"duplicate_lines", "timing_overlaps", "missing_styles", "empty_events", "negative_timing", "zero_duration"}`.
- Call `_create_backup(abs_path)` before any modification.
- Call `apply_fixes(abs_path, fixes)` from health_checker.
- After fix, re-run health check and save updated result.
- Return `{"status": "fixed", "fixes_applied": [...], "counts": {...}, "new_score": int, "remaining_issues": int}`.

**3. POST /tools/advanced-sync**
Accepts: `{"file_path": str, "operation": str, ...params}`.
- Operations:
  - `"offset"`: requires `offset_ms` (int). Use `pysubs2.load()` + `subs.shift(ms=offset_ms)`.
  - `"speed"`: requires `speed_factor` (float, 0.5-2.0 range validation). Loop events: `event.start = round(event.start / factor)`, `event.end = round(event.end / factor)`.
  - `"framerate"`: requires `in_fps` (float) and `out_fps` (float). Use `subs.transform_framerate(in_fps, out_fps)`.
- All operations: `_create_backup()` first, load via pysubs2, apply, save.
- Return `{"status": "synced", "operation": str, "events": int}`.
- For preview mode: if `"preview": true` in request, return 5 representative events (first, quarter, middle, three-quarter, last) with before/after timestamps instead of saving. No backup needed for preview.
- Lazy import pysubs2 at function level.

**4. POST /tools/compare**
Accepts: `{"file_paths": list[str]}` (2-4 paths).
- Validate: 2-4 paths, each via `_validate_file_path()`.
- For each path: read content (with chardet encoding detection, same pattern as existing `get_file_content`), detect format.
- Return `{"panels": [{"path": str, "content": str, "format": "ass"|"srt", "encoding": str, "total_lines": int}, ...]}`.

**Also add quality trends endpoint:**

**5. GET /tools/quality-trends**
Query params: `days` (int, default 30).
- Lazy import `from db.quality import get_quality_trends`.
- Return `{"trends": [...], "days": int}`.

No changes needed to `routes/__init__.py` -- tools blueprint is already registered.
  </action>
  <verify>
`cd backend && python -c "from routes.tools import bp; rules = [r.rule for r in bp.deferred_functions]; print(f'tools blueprint loads OK')"` -- or simply verify the Flask app starts: `cd backend && python -c "from app import create_app; app = create_app(testing=True); print(f'{len(list(app.url_map.iter_rules()))} routes')"` should show an increased route count.
  </verify>
  <done>
tools.py has 5 new endpoints (health-check, health-fix, advanced-sync, compare, quality-trends). All endpoints use _validate_file_path for security. All modifying endpoints create backups. Advanced-sync supports offset/speed/framerate via pysubs2. Health-check runs 10 checks and persists results. Compare serves 2-4 file contents. App starts without import errors.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && python -c "from app import create_app; app = create_app(testing=True); routes = [r.rule for r in app.url_map.iter_rules() if '/tools/' in r.rule]; print(f'{len(routes)} tools routes'); assert len(routes) >= 13"` -- at least 13 tools routes (8 existing + 5 new).
2. `cd backend && python -c "from health_checker import run_health_checks, apply_fixes; print('imports OK')"` -- health checker importable.
3. `cd backend && python -c "from db.models.quality import SubtitleHealthResult; print(SubtitleHealthResult.__tablename__)"` -- prints "subtitle_health_results".
4. `cd backend && python -c "from db.quality import save_health_result, get_quality_trends; print('shim OK')"` -- shim importable.
</verification>

<success_criteria>
- health_checker.py implements 10 detection functions, score calculation, and 6 auto-fix functions
- SubtitleHealthResult ORM model with file_path, score, issues_json, checks_run, checked_at columns
- QualityRepository with CRUD, series-level queries, and trend aggregation
- 5 new tools.py endpoints: health-check (single + batch), health-fix, advanced-sync (offset/speed/framerate + preview), compare (2-4 files), quality-trends
- All endpoints use _validate_file_path for path security
- All modifying endpoints create .bak backup before changes
- Flask app starts without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-comparison-sync-health-check/13-01-SUMMARY.md`
</output>
