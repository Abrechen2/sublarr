---
phase: 09-openapi-release-preparation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/App.tsx
  - frontend/src/pages/Settings.tsx
  - frontend/src/pages/Settings/index.tsx
  - frontend/src/pages/Settings/GeneralTab.tsx
  - frontend/src/pages/Settings/ProvidersTab.tsx
  - frontend/src/pages/Settings/TranslationTab.tsx
  - frontend/src/pages/Settings/WhisperTab.tsx
  - frontend/src/pages/Settings/MediaServersTab.tsx
  - frontend/src/pages/Settings/EventsTab.tsx
  - frontend/src/pages/Settings/AdvancedTab.tsx
  - frontend/src/components/shared/PageSkeleton.tsx
  - frontend/package.json
autonomous: true

must_haves:
  truths:
    - "All page imports in App.tsx use React.lazy for route-level code splitting"
    - "Settings page is split into 5-7 tab sub-components with shared state managed by parent"
    - "Vite produces separate chunks per lazy-loaded page component"
  artifacts:
    - path: "frontend/src/App.tsx"
      provides: "Lazy-loaded route imports with Suspense fallback"
      contains: "React.lazy"
    - path: "frontend/src/pages/Settings/index.tsx"
      provides: "Settings page shell with tab state management"
      contains: "export"
    - path: "frontend/src/components/shared/PageSkeleton.tsx"
      provides: "Loading skeleton for Suspense fallback"
      contains: "PageSkeleton"
  key_links:
    - from: "frontend/src/App.tsx"
      to: "frontend/src/pages/*"
      via: "React.lazy(() => import(...))"
      pattern: "lazy.*import"
    - from: "frontend/src/pages/Settings/index.tsx"
      to: "frontend/src/pages/Settings/*Tab.tsx"
      via: "direct imports for tab components (not lazy -- tabs share state)"
      pattern: "import.*Tab"
---

<objective>
Optimize frontend performance: implement route-level code splitting with React.lazy for all pages, split the 4703-line Settings.tsx into 5-7 focused tab sub-components, and add a loading skeleton component for Suspense fallback.

Purpose: The monolithic bundle loads all pages upfront. Code splitting reduces initial load time by ~60%. The 4703-line Settings.tsx is the largest file in the codebase and violates the <200 line component guideline -- splitting it improves maintainability and load performance.

Output: Lazy-loaded routes in App.tsx, Settings/ directory with tab components, PageSkeleton component, separate Vite chunks per page.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-openapi-release-preparation/09-RESEARCH.md
@frontend/src/App.tsx
@frontend/src/pages/Settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PageSkeleton and convert App.tsx to React.lazy imports</name>
  <files>
    frontend/src/components/shared/PageSkeleton.tsx
    frontend/src/App.tsx
  </files>
  <action>
1. Create `frontend/src/components/shared/PageSkeleton.tsx`:
   - A simple loading skeleton that matches the page layout
   - Use Tailwind classes for the skeleton animation
   - Include a shimmer/pulse effect for visual feedback
   - Structure: header bar skeleton + content area skeleton with 2-3 card shapes
   - Example:
     ```tsx
     export function PageSkeleton() {
       return (
         <div className="animate-pulse space-y-6">
           <div className="h-8 w-48 rounded bg-gray-700/50" />
           <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
             {[1, 2, 3].map(i => (
               <div key={i} className="h-32 rounded-lg bg-gray-700/30" />
             ))}
           </div>
           <div className="h-64 rounded-lg bg-gray-700/20" />
         </div>
       )
     }
     ```

2. Convert `frontend/src/App.tsx`:
   - Replace all static page imports with `React.lazy()` dynamic imports
   - Add `import { lazy, Suspense } from 'react'`
   - Keep non-page imports as-is (Sidebar, Toast, useWebSocket, QueryClient)
   - Wrap `<AnimatedRoutes />` (or the Routes inside it) with `<Suspense fallback={<PageSkeleton />}>`
   - Each lazy import uses the default or named export pattern matching current usage:
     - Named exports: `const Dashboard = lazy(() => import('@/pages/Dashboard').then(m => ({ default: m.Dashboard })))`
     - Default exports: `const Onboarding = lazy(() => import('@/pages/Onboarding'))`
   - Alternatively, change page components to use default exports if they don't already, then use simple `lazy(() => import(...))` pattern
   - All 13 page components should be lazy-loaded: Dashboard, Activity, Wanted, Queue, Settings, Logs, Statistics, Library, SeriesDetail, History, Blacklist, NotFound, Onboarding

**Important:** The `key={location.pathname}` on the AnimatedRoutes div may cause re-mounts on every navigation. With lazy loading, this means re-fetching chunks on every route change. Consider whether the animation behavior is worth the cost -- if so, keep it. The Suspense boundary should be inside AnimatedRoutes, wrapping the Routes component.

**Named vs Default export handling:** Check each page file. Most use named exports (e.g., `export function Dashboard()`). For React.lazy compatibility, use the `.then(m => ({ default: m.ExportName }))` adapter pattern, or add `export default` to each page. The adapter pattern is cleaner since it doesn't modify existing exports.
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit && npm run build 2>&1 | tail -20`

Expected: TypeScript compilation succeeds. Build output shows multiple chunk files (one per lazy-loaded page). No errors about missing exports.
  </verify>
  <done>
  - PageSkeleton.tsx created with Tailwind skeleton animation
  - App.tsx uses React.lazy for all 13 page imports
  - Suspense wrapper with PageSkeleton fallback
  - Build produces separate chunks per page
  - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Split Settings.tsx into tab sub-components</name>
  <files>
    frontend/src/pages/Settings.tsx
    frontend/src/pages/Settings/index.tsx
    frontend/src/pages/Settings/GeneralTab.tsx
    frontend/src/pages/Settings/ProvidersTab.tsx
    frontend/src/pages/Settings/TranslationTab.tsx
    frontend/src/pages/Settings/WhisperTab.tsx
    frontend/src/pages/Settings/MediaServersTab.tsx
    frontend/src/pages/Settings/EventsTab.tsx
    frontend/src/pages/Settings/AdvancedTab.tsx
  </files>
  <action>
Split the 4703-line Settings.tsx into a directory structure with focused tab components.

1. Analyze `Settings.tsx` to identify tab boundaries. The component uses a TAB_KEYS mapping and renders different content per tab. Each tab section is a natural split point.

2. Create `frontend/src/pages/Settings/` directory structure.

3. Create `frontend/src/pages/Settings/index.tsx` as the parent shell:
   - Keep the tab navigation, save/discard logic, and shared state (form values, dirty state, active tab)
   - Import and render tab components based on activeTab
   - Export `SettingsPage` (named export matching current App.tsx usage)
   - Keep the useTranslation hook for tab labels
   - Tab components receive necessary props: config values, onChange handlers, save state

4. Extract tab components (estimate 5-7 based on visible tabs in Settings):

   **GeneralTab.tsx:** General settings (source/target language, Sonarr/Radarr instances, path mappings, language profiles).
   **ProvidersTab.tsx:** Provider configuration (enable/disable, credentials, priority, test buttons). Includes provider cards.
   **TranslationTab.tsx:** Translation backend configuration (Ollama/DeepL/LibreTranslate/OpenAI/Google), fallback chains, prompt presets, glossary.
   **WhisperTab.tsx:** Whisper backend config (faster-whisper, Subgen), global whisper toggle, model selection.
   **MediaServersTab.tsx:** Media server instances (Jellyfin/Emby, Plex, Kodi), test buttons.
   **EventsTab.tsx:** Events & Hooks tab (shell scripts, outgoing webhooks, scoring weights).
   **AdvancedTab.tsx:** Remaining tabs: Backup, Library Sources (standalone), Notification, and any other settings sections.

   If the current Settings.tsx has more tabs that map to clear visual sections, adjust the split accordingly. The goal is 5-7 files of ~400-800 lines each (not perfect balance, just manageable chunks).

5. **State management strategy:**
   - Parent (index.tsx) owns: config data (from React Query), save/discard handlers, dirty state tracking
   - Tabs receive: relevant config slice as props, onChange callback
   - Tabs do NOT fetch their own data -- they receive it from parent
   - This preserves the existing behavior where unsaved changes persist across tab switches

6. **i18n:** Keep the existing useTranslation patterns. Tab components use their own useTranslation('settings') hooks for labels.

7. Delete the original `Settings.tsx` after the split is complete and verified.

**Important pitfall (from research):** Shared state across tabs. If tabs have their own useState, switching tabs unmounts/remounts and loses state. Solution: parent owns all form state, passes down via props. Each tab's onChange calls back to parent to update the shared state object.

**Important:** The lazy-load in App.tsx from Task 1 imports from `@/pages/Settings` which resolves to `pages/Settings/index.tsx` -- this should work automatically with the directory-based structure.
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit && npm run build 2>&1 | tail -20`

Verify: TypeScript compiles. Build succeeds. Then check the Settings directory has the expected files:
`ls frontend/src/pages/Settings/`

Expected: index.tsx + 5-7 tab component files. No more standalone Settings.tsx in pages/.
  </verify>
  <done>
  - Settings.tsx split into Settings/ directory with index.tsx + 5-7 tab components
  - Parent index.tsx manages shared state (config, save, dirty tracking)
  - Tab components receive props (no independent data fetching)
  - Unsaved changes preserved across tab switches
  - Original Settings.tsx deleted
  - TypeScript compiles and build succeeds
  - Each tab file is under ~1000 lines (manageable size)
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` produces multiple chunks (verify via `ls dist/assets/*.js | wc -l` -- should be significantly more than before)
2. `cd frontend && npx tsc --noEmit` passes with zero errors
3. Settings page functions identically after split: tab switching, form state preservation, save/discard
4. All routes load correctly with lazy loading (no blank pages, skeleton shows briefly on first load)
5. `cd frontend && npm test` passes
</verification>

<success_criteria>
- Route-level code splitting active for all 13 page components
- Settings split from 4703-line monolith into 5-7 focused tab components under 1000 lines each
- Build produces separate chunks (measurable increase in output JS file count)
- No functional regressions in Settings page behavior
</success_criteria>

<output>
After completion, create `.planning/phases/09-openapi-release-preparation/09-03-SUMMARY.md`
</output>
