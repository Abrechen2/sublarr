---
phase: 18-per-series-glossary
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/models/translation.py
  - backend/db/migrations/versions/make_glossary_series_id_nullable.py
  - backend/db/repositories/translation.py
  - backend/db/translation.py
  - backend/routes/profiles.py
  - backend/translator.py
autonomous: true

must_haves:
  truths:
    - "Global glossary entries (series_id=NULL) can be created via POST /api/v1/glossary without a series_id"
    - "GET /api/v1/glossary without series_id returns global glossary entries"
    - "GET /api/v1/glossary?series_id=N still returns per-series entries (no regression)"
    - "When translating for a series, glossary includes both global and per-series entries with per-series overriding global on same source_term"
    - "Series without per-series entries still use global glossary entries"
  artifacts:
    - path: "backend/db/migrations/versions/make_glossary_series_id_nullable.py"
      provides: "Alembic migration making glossary_entries.series_id nullable"
    - path: "backend/db/repositories/translation.py"
      provides: "get_global_glossary and get_merged_glossary_for_series methods"
    - path: "backend/db/translation.py"
      provides: "Facade functions for global and merged glossary"
    - path: "backend/routes/profiles.py"
      provides: "Updated glossary routes accepting optional series_id"
    - path: "backend/translator.py"
      provides: "Merged glossary loading in translation pipeline"
  key_links:
    - from: "backend/translator.py"
      to: "backend/db/translation.py"
      via: "get_merged_glossary_for_series() call"
      pattern: "get_merged_glossary_for_series"
    - from: "backend/routes/profiles.py"
      to: "backend/db/translation.py"
      via: "add_glossary_entry with series_id=None for global"
    - from: "backend/db/repositories/translation.py"
      to: "backend/db/models/translation.py"
      via: "GlossaryEntry.series_id nullable query"
---

<objective>
Backend data model, API, and merge logic for per-series glossary with global glossary support.

Purpose: Enable global glossary entries (series_id=NULL) alongside existing per-series entries, with merge logic that gives per-series entries precedence over global entries with the same source_term during translation.

Output: Migration making series_id nullable, repository methods for global/merged glossary, updated API routes, and translator.py using merged glossary.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-per-series-glossary/18-RESEARCH.md

@backend/db/models/translation.py
@backend/db/repositories/translation.py
@backend/db/repositories/base.py
@backend/db/translation.py
@backend/routes/profiles.py
@backend/translator.py
@backend/db/migrations/env.py
@backend/db/migrations/versions/fa890ea72dab_add_filter_presets.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB migration + model + repository methods for global glossary</name>
  <files>
    backend/db/models/translation.py
    backend/db/migrations/versions/make_glossary_series_id_nullable.py
    backend/db/repositories/translation.py
    backend/db/translation.py
  </files>
  <action>
1. **Model change** (backend/db/models/translation.py):
   - Change `series_id` from `Mapped[int]` to `Mapped[Optional[int]]` (Optional is already imported from typing)
   - Change `mapped_column(Integer, nullable=False)` to `mapped_column(Integer, nullable=True)`
   - Update docstring: "Per-series or global glossary for consistent term translation."

2. **Alembic migration** (backend/db/migrations/versions/make_glossary_series_id_nullable.py):
   - `revision` = generate a unique hex ID (e.g., "b2c3d4e5f6a7")
   - `down_revision = "fa890ea72dab"` (current HEAD)
   - In `upgrade()`: use `with op.batch_alter_table("glossary_entries") as batch_op:` then `batch_op.alter_column("series_id", existing_type=sa.Integer(), nullable=True)`
   - In `downgrade()`: first `op.execute("UPDATE glossary_entries SET series_id = 0 WHERE series_id IS NULL")`, then use batch_alter_table to set `nullable=False`
   - Follow existing migration pattern from fa890ea72dab_add_filter_presets.py

3. **Repository methods** (backend/db/repositories/translation.py):
   - Update `add_glossary_entry` signature: `series_id: int` becomes `series_id: Optional[int]` (Optional already imported)
   - Add `get_global_glossary()` method that queries GlossaryEntry where `series_id.is_(None)`, ordered by source_term asc, returns `[self._to_dict(e) for e in entries]`
   - Add `get_merged_glossary_for_series(self, series_id: int) -> list[dict]` method:
     - Query global entries (series_id IS NULL) selecting source_term and target_term, ordered by updated_at desc, limit 30
     - Query series-specific entries (series_id == series_id) selecting source_term and target_term, ordered by updated_at desc, limit 30
     - Merge into dict keyed by `source_term.lower()` -- global entries first, then series entries override (dict spread: `{**global_dict, **series_dict}`)
     - Return `list(merged.values())[:30]` as list of `{"source_term": ..., "target_term": ...}` dicts
   - Update `search_glossary_terms` signature: `series_id: int` becomes `series_id: Optional[int]`. When series_id is None, filter by `GlossaryEntry.series_id.is_(None)`. When series_id is an int, filter by `GlossaryEntry.series_id == series_id`.

4. **Facade module** (backend/db/translation.py):
   - Add `get_global_glossary()` function delegating to `_get_repo().get_global_glossary()`
   - Add `get_merged_glossary_for_series(series_id: int)` function delegating to `_get_repo().get_merged_glossary_for_series(series_id)`
   - Update `add_glossary_entry` signature: `series_id: int` becomes `series_id: Optional[int] = None`
   - Update `get_glossary_entries` to accept `series_id: Optional[int] = None`. When None, delegate to `get_global_glossary()`.
   - Update `search_glossary_terms` signature: `series_id: Optional[int] = None`
  </action>
  <verify>
    Run: `cd Z:/CC/Sublarr/backend && python -c "from db.models.translation import GlossaryEntry; print(GlossaryEntry)"` to confirm model loads.
    Run: `cd Z:/CC/Sublarr/backend && python -m pytest tests/ -x -q --tb=short` to check no tests break.
    Inspect migration file for correct batch_alter_table pattern.
  </verify>
  <done>
    GlossaryEntry.series_id is nullable in model.
    Migration file exists with correct down_revision (fa890ea72dab) and batch_alter_table pattern.
    Repository has get_global_glossary() and get_merged_glossary_for_series() methods.
    Facade module exposes both new functions.
    Existing tests pass (or only pre-existing failures remain).
  </done>
</task>

<task type="auto">
  <name>Task 2: API route updates + translator merge integration</name>
  <files>
    backend/routes/profiles.py
    backend/translator.py
  </files>
  <action>
1. **Route updates** (backend/routes/profiles.py):
   - **GET /glossary**: Make series_id query param optional. When absent (None), return global entries via `get_global_glossary()`. When present, behave as before. Update the import to include `get_global_glossary`. Response: `{"entries": entries, "series_id": series_id}` where series_id is null for global.
     Key change: Remove the `if not series_id: return 400` guard. Instead use `if series_id is not None:` to branch between per-series and global.
   - **POST /glossary**: Make series_id optional. When omitted or null in JSON body, create a global entry (series_id=None). Remove the series_id-required validation (`if not series_id: return 400`). Validate only source_term and target_term. Pass series_id (which may be None) to `add_glossary_entry`.
   - **OpenAPI docstrings**: Update GET to show series_id as optional (remove `required: true`). Update POST to show series_id as optional with description "Omit or null for global glossary entry".

2. **Translator merge integration** (backend/translator.py):
   - Replace the glossary loading block (lines ~183-193) to use merged glossary:
     - Import `get_merged_glossary_for_series` and `get_global_glossary` from `db.translation`
     - If `series_id`: use `get_merged_glossary_for_series(series_id)` which returns `[{source_term, target_term}]` already
     - Else (movies/standalone): use `get_global_glossary()`, extract `[{"source_term": e["source_term"], "target_term": e["target_term"]}]` from full dicts
     - If entries exist, set `glossary_entries = entries` with debug logging
     - Wrap in try/except as before for resilience
   - This ensures: (a) series translations get merged global+series glossary, (b) non-series translations get global glossary, (c) no glossary = None as before.
  </action>
  <verify>
    Run: `cd Z:/CC/Sublarr/backend && python -c "from routes.profiles import bp; print(bp)"` to confirm routes load.
    Run: `cd Z:/CC/Sublarr/backend && python -m pytest tests/ -x -q --tb=short` to confirm no regressions.
    Manual curl test (if dev server running):
      `curl -s http://localhost:5765/api/v1/glossary` should return global entries (empty list if none).
      `curl -s http://localhost:5765/api/v1/glossary?series_id=1` should return series 1 entries.
      `curl -X POST http://localhost:5765/api/v1/glossary -H "Content-Type: application/json" -d '{"source_term":"test","target_term":"Test"}'` should create a global entry.
  </verify>
  <done>
    GET /api/v1/glossary without series_id returns global entries.
    GET /api/v1/glossary?series_id=N returns per-series entries (unchanged behavior).
    POST /api/v1/glossary without series_id creates a global glossary entry.
    POST /api/v1/glossary with series_id creates a per-series entry (unchanged behavior).
    translator.py uses get_merged_glossary_for_series() for series translations.
    translator.py uses get_global_glossary() for non-series translations.
    All existing tests pass (or only pre-existing failures remain).
  </done>
</task>

</tasks>

<verification>
1. Model: GlossaryEntry.series_id is Mapped[Optional[int]] with nullable=True
2. Migration: File exists with down_revision = "fa890ea72dab", uses batch_alter_table
3. Repository: get_global_glossary() queries series_id IS NULL
4. Repository: get_merged_glossary_for_series(series_id) merges global + series, series overrides on same source_term (case-insensitive), limited to 30
5. Facade: get_global_glossary() and get_merged_glossary_for_series() exposed at module level
6. Routes: GET /glossary works without series_id (returns global), POST /glossary works without series_id (creates global)
7. Translator: Uses merged glossary for series, global glossary for non-series
8. All existing tests pass (or only pre-existing failures)
</verification>

<success_criteria>
- Global glossary entries (series_id=NULL) can be created and queried via the API
- Per-series glossary entries continue to work exactly as before (no regression)
- Translation pipeline loads merged glossary (global + series, series overrides global)
- Migration file is valid and follows existing Alembic patterns
</success_criteria>

<output>
After completion, create `.planning/phases/18-per-series-glossary/18-01-SUMMARY.md`
</output>
