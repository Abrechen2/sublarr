---
phase: 06-forced-signs-subs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/__init__.py
  - backend/forced_detection.py
  - backend/providers/base.py
  - backend/translator.py
  - backend/db/profiles.py
  - backend/db/wanted.py
autonomous: true

must_haves:
  truths:
    - "Forced subtitles have a distinct subtitle_type field in the database (full/forced/signs)"
    - "Language profiles include a forced_preference setting (disabled/separate/auto)"
    - "Existing subtitle files are analyzed using multi-signal detection (ffprobe + filename + stream title + ASS style)"
    - "detect_existing_target_for_lang recognizes .lang.forced.ext files"
    - "VideoQuery supports forced_only flag for provider search"
  artifacts:
    - path: "backend/db/__init__.py"
      provides: "Schema migrations for subtitle_type and forced_preference columns"
      contains: "subtitle_type TEXT DEFAULT 'full'"
    - path: "backend/forced_detection.py"
      provides: "Multi-signal forced subtitle detection engine"
      exports: ["detect_subtitle_type", "is_forced_external_sub", "FORCED_FILENAME_RE"]
    - path: "backend/providers/base.py"
      provides: "VideoQuery.forced_only field"
      contains: "forced_only"
    - path: "backend/translator.py"
      provides: "detect_existing_target_for_lang recognizes forced subtitle files"
      contains: ".forced."
    - path: "backend/db/profiles.py"
      provides: "forced_preference field in profile CRUD"
      contains: "forced_preference"
    - path: "backend/db/wanted.py"
      provides: "subtitle_type parameter in upsert_wanted_item"
      contains: "subtitle_type"
  key_links:
    - from: "backend/forced_detection.py"
      to: "backend/ass_utils.py"
      via: "classify_styles import for ASS-based detection signal"
      pattern: "from ass_utils import classify_styles"
    - from: "backend/db/wanted.py"
      to: "backend/db/__init__.py"
      via: "subtitle_type column in wanted_items table"
      pattern: "subtitle_type"
    - from: "backend/translator.py"
      to: "backend/forced_detection.py"
      via: "is_forced_external_sub for path detection"
      pattern: "from forced_detection import"
---

<objective>
Add forced/signs subtitle data model, multi-signal detection engine, and extend core abstractions.

Purpose: Foundation for the entire forced/signs subtitle feature -- database schema, detection logic, and extended data structures that Plans 02 and 03 build upon.
Output: DB migrations, forced_detection.py module, extended VideoQuery/profiles/wanted, updated detect_existing_target_for_lang.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-forced-signs-subs/06-RESEARCH.md
@backend/db/__init__.py
@backend/providers/base.py
@backend/ass_utils.py
@backend/translator.py
@backend/db/profiles.py
@backend/db/wanted.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema + forced_detection.py module</name>
  <files>backend/db/__init__.py, backend/forced_detection.py</files>
  <action>
    1. In `backend/db/__init__.py`, add three schema migrations to `_run_migrations()`:
       - Add `subtitle_type TEXT DEFAULT 'full'` to `wanted_items` (if not exists)
       - Add `subtitle_type TEXT DEFAULT 'full'` to `subtitle_downloads` (if not exists)
       - Add `forced_preference TEXT DEFAULT 'disabled'` to `language_profiles` (if not exists)
       Follow exact pattern of existing migrations (PRAGMA table_info check, ALTER TABLE ADD COLUMN).

    2. Create `backend/forced_detection.py` -- multi-signal forced subtitle detection module:

       Constants:
       - `SUBTITLE_TYPES = ("full", "forced", "signs")` -- valid enum values
       - `FORCED_FILENAME_RE = re.compile(r'\.(?:forced|signs?|foreign)\.(?:ass|srt|ssa|vtt)$', re.IGNORECASE)` -- standard naming pattern
       - `FORCED_STREAM_TITLE_RE = re.compile(r'\b(?:forced|signs?|songs?|foreign)\b', re.IGNORECASE)` -- stream title keywords

       Functions:
       - `detect_subtitle_type(stream_info=None, file_path=None, ass_content=None) -> tuple[str, float]`:
         Multi-signal detection returning (type, confidence).
         Signals in priority order:
           1. ffprobe disposition.forced == 1 -> ("forced", 1.0)
           2. Filename pattern (.forced. / .signs. / .foreign.) -> ("forced"|"signs", 0.9)
           3. Stream title keywords ("forced", "signs", "songs") -> ("forced"|"signs", 0.8)
           4. ASS all-signs heuristic: if ass_content provided, use classify_styles(). If signs_styles exist but dialog_styles is empty -> ("signs", 0.7)
           5. No signals -> ("full", 1.0)
         Use multi-signal agreement: if 2+ signals agree on type, return that type. If only 1 signal, still return it but with its confidence. Never classify based solely on line count (avoids false positives per research pitfall #1).

       - `is_forced_external_sub(file_path: str) -> bool`:
         Check if filename matches FORCED_FILENAME_RE. Simple filename-only check for fast scanning.

       - `classify_forced_result(result_filename: str, provider_data: dict = None) -> str`:
         Classify a provider search result as 'full', 'forced', or 'signs'.
         Checks result_filename for forced/signs patterns.
         If provider_data has 'foreign_parts_only' key (OpenSubtitles), use that.
         Returns 'full' by default.

       Import classify_styles from ass_utils only when ass_content is provided (lazy import inside function body to avoid circular imports -- ass_utils does not import forced_detection).
  </action>
  <verify>
    `cd backend && python -c "from forced_detection import detect_subtitle_type, is_forced_external_sub, classify_forced_result, SUBTITLE_TYPES; print('OK')"` succeeds.
    `cd backend && python -c "from db import get_db; get_db()"` succeeds (migrations run without error).
  </verify>
  <done>
    Schema migrations add subtitle_type to wanted_items and subtitle_downloads, forced_preference to language_profiles.
    forced_detection.py exports detect_subtitle_type, is_forced_external_sub, classify_forced_result with multi-signal logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend VideoQuery, profiles CRUD, wanted upsert, and detect_existing_target</name>
  <files>backend/providers/base.py, backend/db/profiles.py, backend/db/wanted.py, backend/translator.py</files>
  <action>
    1. In `backend/providers/base.py`, add `forced_only: bool = False` field to VideoQuery dataclass, after the `languages` field (line ~79). This flag tells providers to filter for forced/signs subtitles.

    2. In `backend/db/profiles.py`:
       - Update `_row_to_profile()` to include `forced_preference` field: `d["forced_preference"] = d.get("forced_preference", "disabled")`.
       - Update `create_language_profile()` to accept optional `forced_preference: str = "disabled"` parameter and include it in the INSERT statement.
       - Update `update_language_profile()` to accept optional `forced_preference` parameter and include it in the UPDATE statement. If not provided, keep existing value.
       - Validate forced_preference is one of ("disabled", "separate", "auto") in both create and update -- raise ValueError if invalid.

    3. In `backend/db/wanted.py`:
       - Add `subtitle_type: str = "full"` parameter to `upsert_wanted_item()`.
       - Change the uniqueness check from matching on `file_path + target_language` to `file_path + target_language + subtitle_type`. This means:
         - If target_language is set: `WHERE file_path=? AND target_language=? AND subtitle_type=?`
         - If no target_language: `WHERE file_path=? AND (target_language='' OR target_language IS NULL) AND subtitle_type=?`
       - Include subtitle_type in both INSERT and UPDATE SQL statements.
       - This enables parallel tracking: one file can have TWO wanted items (full + forced) for the same language.

    4. In `backend/translator.py`, update `detect_existing_target_for_lang()`:
       - After checking `{base}.{tag}.ass`, also check for `{base}.{tag}.forced.ass` pattern.
       - After checking `{base}.{tag}.srt`, also check for `{base}.{tag}.forced.srt` pattern.
       - Add optional parameter `subtitle_type: str = "full"`.
       - When subtitle_type is "forced", ONLY check for .forced. pattern files (not regular files).
       - When subtitle_type is "full" (default), keep existing behavior (check non-forced files).
       - This prevents forced subs from being invisible to the scanner (research pitfall #6).
       - Also add `get_forced_output_path(mkv_path, fmt="ass", target_language=None) -> str`:
         Returns `{base}.{lang}.forced.{fmt}` path following Plex/Jellyfin/Emby/Kodi standard naming.
  </action>
  <verify>
    `cd backend && python -c "from providers.base import VideoQuery; q = VideoQuery(forced_only=True); print(q.forced_only)"` prints True.
    `cd backend && python -c "from db.profiles import create_language_profile; print('OK')"` succeeds.
    `cd backend && python -c "from translator import detect_existing_target_for_lang, get_forced_output_path; print('OK')"` succeeds.
  </verify>
  <done>
    VideoQuery has forced_only field. Profile CRUD handles forced_preference. Wanted upsert matches on file_path + target_language + subtitle_type. detect_existing_target_for_lang handles forced subtitle file paths. get_forced_output_path generates standard forced naming.
  </done>
</task>

</tasks>

<verification>
- All imports succeed without errors
- DB migrations create the three new columns on fresh and existing databases
- forced_detection module correctly identifies forced filenames: `is_forced_external_sub("movie.en.forced.ass")` returns True
- detect_existing_target_for_lang with subtitle_type="forced" only finds .forced. files
- VideoQuery(forced_only=True).forced_only == True
- Profile with forced_preference="separate" round-trips through create/read
- Two wanted items for same file+language but different subtitle_type can coexist
</verification>

<success_criteria>
- Database has subtitle_type on wanted_items and subtitle_downloads, forced_preference on language_profiles
- forced_detection.py provides multi-signal detection with confidence scoring
- VideoQuery, profiles, wanted, and translator all understand subtitle_type/forced concepts
- No existing tests broken (no behavioral change to default "full" path)
</success_criteria>

<output>
After completion, create `.planning/phases/06-forced-signs-subs/06-01-SUMMARY.md`
</output>
