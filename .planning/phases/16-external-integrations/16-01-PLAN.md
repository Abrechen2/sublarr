---
phase: 16-external-integrations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/bazarr_migrator.py
  - backend/sonarr_client.py
  - backend/radarr_client.py
  - backend/jellyfin_client.py
  - backend/mediaserver/plex.py
  - backend/mediaserver/kodi.py
autonomous: true

must_haves:
  truths:
    - "Sonarr/Radarr extended health check returns connection, API version, library access, webhook status, and health issues"
    - "Jellyfin/Emby extended health check returns connection, server info, library access, and health issues"
    - "Plex extended health check returns connection, version, library sections, and remote access status"
    - "Kodi extended health check returns connection, version, video library sources, and JSON-RPC version"
    - "Bazarr migration reads table_history, table_shows, table_movies in addition to existing tables"
    - "Bazarr mapping report provides detailed per-table row counts and field summaries before import"
  artifacts:
    - path: "backend/sonarr_client.py"
      provides: "extended_health_check() method on SonarrClient"
      contains: "def extended_health_check"
    - path: "backend/radarr_client.py"
      provides: "extended_health_check() method on RadarrClient"
      contains: "def extended_health_check"
    - path: "backend/jellyfin_client.py"
      provides: "extended_health_check() method on JellyfinClient"
      contains: "def extended_health_check"
    - path: "backend/mediaserver/plex.py"
      provides: "extended_health_check() method on PlexServer"
      contains: "def extended_health_check"
    - path: "backend/mediaserver/kodi.py"
      provides: "extended_health_check() method on KodiServer"
      contains: "def extended_health_check"
    - path: "backend/bazarr_migrator.py"
      provides: "generate_mapping_report() and extended DB reading"
      contains: "def generate_mapping_report"
  key_links:
    - from: "backend/sonarr_client.py"
      to: "/api/v3/system/status, /api/v3/health, /api/v3/notification"
      via: "HTTP GET requests"
      pattern: "_get.*system/status|_get.*health|_get.*notification"
    - from: "backend/jellyfin_client.py"
      to: "/System/Info, /Library/VirtualFolders"
      via: "HTTP GET requests"
      pattern: "_get.*System/Info|_get.*VirtualFolders"
---

<objective>
Extend all external service clients with extended_health_check() methods returning structured diagnostic reports (INTG-03, INTG-04), and deepen Bazarr migration with additional table reading and mapping report generation (INTG-01).

Purpose: Rich diagnostics help users troubleshoot integration issues; extended Bazarr migration enables informed decisions before data import.
Output: Extended methods on SonarrClient, RadarrClient, JellyfinClient, PlexServer, KodiServer; enhanced bazarr_migrator.py with generate_mapping_report().
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-external-integrations/16-RESEARCH.md
@backend/sonarr_client.py
@backend/radarr_client.py
@backend/jellyfin_client.py
@backend/mediaserver/plex.py
@backend/mediaserver/kodi.py
@backend/bazarr_migrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add extended_health_check() to Sonarr, Radarr, Jellyfin, Plex, and Kodi clients</name>
  <files>
    backend/sonarr_client.py
    backend/radarr_client.py
    backend/jellyfin_client.py
    backend/mediaserver/plex.py
    backend/mediaserver/kodi.py
  </files>
  <action>
Add an extended_health_check(self) -> dict method to each client class. Each method returns a structured diagnostic dict. Do NOT modify the existing health_check() method -- add this as a NEW method.

SonarrClient.extended_health_check() returns dict with keys:
- connection: {healthy: bool, message: str}
- api_version: {version: str, branch: str, app_name: str}
- library_access: {series_count: int, accessible: bool}
- webhook_status: {configured: bool, sublarr_webhooks: list}
- health_issues: [{type: str, message: str}]

Implementation:
1. Call self._get("/system/status"). If None, set connection.healthy=False with message and return early.
2. Extract version/branch/appName from status response.
3. Call self._get("/series") and count items for library_access. Set accessible=True if response is not None.
4. Call self._get("/notification") wrapped in try/except. Filter notifications where "sublarr" appears (case-insensitive) in name or implementation fields. Set configured=True if notification list is not None.
5. Call self._get("/health") wrapped in try/except. Map each item to {type, message}.

RadarrClient.extended_health_check() -- same structure, but:
- library_access uses self._get("/movie") and counts movies. Key is "movie_count" instead of "series_count".
- All else identical to Sonarr pattern.

JellyfinClient.extended_health_check() returns dict with keys:
- connection: {healthy: bool, message: str}
- server_info: {server_name: str, version: str, product_name: str, os: str}
- library_access: {library_count: int, libraries: list, accessible: bool}
- health_issues: list

Implementation:
1. Call self._get("/System/Info/Public"). If None, set connection.healthy=False and return early.
2. Extract ServerName, Version, ProductName, OperatingSystem using .get() defaults.
3. Call self._get("/Library/VirtualFolders") wrapped in try/except. Extract list of {name, collectionType} per folder.
4. Try self._get("/System/Info") for extended info. If HasPendingRestart or HasUpdateAvailable is True, add health_issue.

PlexServer.extended_health_check() returns dict with keys:
- connection: {healthy: bool, message: str}
- server_info: {friendly_name: str, version: str, platform: str}
- library_access: {section_count: int, sections: list, accessible: bool}
- health_issues: list

Implementation:
1. Check _HAS_PLEXAPI. If False, return connection unhealthy with "plexapi not installed".
2. Try self._get_server(). On failure, return connection unhealthy.
3. Get server.friendlyName, server.version, server.platform.
4. Get server.library.sections(). Map to [{title, type}] (skip totalSize to keep it fast).

KodiServer.extended_health_check() returns dict with keys:
- connection: {healthy: bool, message: str}
- server_info: {name: str, version: str, jsonrpc_version: str}
- library_access: {video_sources_count: int, video_sources: list, accessible: bool}
- health_issues: list

Implementation:
1. Try self._rpc("JSONRPC.Ping"). If not "pong" or exception, return connection unhealthy.
2. Get Application.GetProperties for name/version.
3. Get JSONRPC.Version for protocol version (major.minor.patch from response).
4. Get Files.GetSources with media=video wrapped in try/except.

All methods must wrap each sub-query in try/except and degrade gracefully. Use .get() for all dict access.
  </action>
  <verify>
Import each class and verify extended_health_check exists as attribute on each of the 5 classes.
  </verify>
  <done>All 5 client classes have extended_health_check() methods returning structured dicts with connection, version/info, library access, and health issues. Existing health_check() methods remain unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Extend Bazarr migration with deeper DB reading and mapping report</name>
  <files>
    backend/bazarr_migrator.py
  </files>
  <action>
Extend bazarr_migrator.py with additional table reading and a generate_mapping_report() function. Do NOT modify existing function signatures or return structures -- only ADD new capabilities.

1. Add _get_table_info(conn, table_name) -> list utility:
   Returns list of column names from PRAGMA table_info(table_name).
   Returns empty list if table does not exist (catches OperationalError).

2. Add _read_history(conn, warnings) -> list:
   Use _get_table_info to discover columns before querying.
   Read from table_history. Extract: provider, score, subs_id, video_path, language, timestamp.
   Limit to 1000 rows (ORDER BY timestamp DESC LIMIT 1000). Wrap in try/except OperationalError.

3. Add _read_shows(conn, warnings) -> list:
   Read from table_shows. Extract: title, path, profileId, audio_language, sonarrSeriesId.
   Use _get_table_info for column discovery. Wrap in try/except.

4. Add _read_movies(conn, warnings) -> list:
   Read from table_movies. Extract: title, path, profileId, audio_language, radarrId, tmdbId.
   Use _get_table_info for column discovery. Wrap in try/except.

5. Extend migrate_bazarr_db() -- add three new keys to return dict (backward compatible):
   "history": _read_history(conn, result["warnings"])
   "shows": _read_shows(conn, result["warnings"])
   "movies": _read_movies(conn, result["warnings"])

6. Add generate_mapping_report(db_path: str) -> dict:
   Opens Bazarr DB read-only. Returns:
   - tables_found: all table names from sqlite_master
   - table_details: per-table {row_count, columns, sample_row} (secrets masked)
   - migration_summary: {profiles_count, blacklist_count, shows_count, movies_count, history_count, has_sonarr_config, has_radarr_config}
   - compatibility: {bazarr_version, schema_version}
   - warnings: list of strings
   All access wrapped in try/except OperationalError.

7. Update preview_migration() -- add shows_count, movies_count, history_count from db_data.
  </action>
  <verify>
Import generate_mapping_report and verify it exists.
Import migrate_bazarr_db, call with nonexistent path, verify history/shows/movies keys present.
  </verify>
  <done>bazarr_migrator.py has generate_mapping_report() producing detailed per-table analysis, migrate_bazarr_db() returns history/shows/movies data, preview_migration() includes extended counts, all operations handle missing tables gracefully.</done>
</task>

</tasks>

<verification>
- All 5 client classes import and have extended_health_check() method.
- bazarr_migrator.py has generate_mapping_report() function.
- migrate_bazarr_db() returns dict with history, shows, movies keys.
- No existing health_check() signatures changed.
- All new code handles missing/unavailable services gracefully.
</verification>

<success_criteria>
- Extended health checks return structured dicts for each service type.
- Bazarr mapping report provides table inventory, row counts, and compatibility info.
- All methods degrade gracefully on API failures or missing tables.
- Existing functionality (health_check, migrate_bazarr_db) unchanged.
</success_criteria>

<output>
After completion, create .planning/phases/16-external-integrations/16-01-SUMMARY.md
</output>
