---
phase: 16-external-integrations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/compat_checker.py
  - backend/export_manager.py
  - backend/routes/integrations.py
  - backend/routes/__init__.py
autonomous: true

must_haves:
  truths:
    - "Plex compatibility checker validates subtitle naming and placement against Plex conventions"
    - "Kodi compatibility checker validates subtitle naming against Kodi conventions"
    - "Export manager produces Bazarr-compatible, Plex manifest, Kodi, and generic JSON formats"
    - "Integrations API blueprint exposes endpoints for compat check, export, extended health, and mapping report"
  artifacts:
    - path: "backend/compat_checker.py"
      provides: "Plex and Kodi subtitle naming/placement validation"
      contains: "def check_plex_compatibility"
    - path: "backend/export_manager.py"
      provides: "Multi-format config/subtitle data export"
      contains: "def export_config"
    - path: "backend/routes/integrations.py"
      provides: "Flask Blueprint for all Phase 16 API endpoints"
      contains: "bp = Blueprint"
  key_links:
    - from: "backend/routes/integrations.py"
      to: "backend/compat_checker.py"
      via: "import and call check_plex_compatibility/check_kodi_compatibility"
      pattern: "from compat_checker import"
    - from: "backend/routes/integrations.py"
      to: "backend/export_manager.py"
      via: "import and call export_config"
      pattern: "from export_manager import"
    - from: "backend/routes/__init__.py"
      to: "backend/routes/integrations.py"
      via: "Blueprint registration"
      pattern: "from routes.integrations import bp"
---

<objective>
Create the compatibility checker module (INTG-02), export manager module (INTG-05), and integrations API blueprint that ties together all Phase 16 backend functionality.

Purpose: Compat checker catches subtitle naming issues before they cause playback failures; export manager enables migration TO other tools; API blueprint exposes all integration features to the frontend.
Output: compat_checker.py, export_manager.py, routes/integrations.py (registered in routes/__init__.py).
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-external-integrations/16-RESEARCH.md
@backend/routes/__init__.py
@backend/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compat_checker.py and export_manager.py modules</name>
  <files>
    backend/compat_checker.py
    backend/export_manager.py
  </files>
  <action>
Create two new backend modules as pure-function libraries (no Flask dependencies).

**compat_checker.py** -- Stateless validation functions for subtitle file naming/placement.

Functions to create:

check_plex_compatibility(subtitle_path: str, video_path: str) -> dict:
  Returns {compatible: bool, issues: list, warnings: list, recommendations: list}.
  Validates:
  a. Language code format: must be ISO 639-1 (2-letter) or 639-2 (3-letter), lowercase on Linux. Extract lang code from filename pattern: basename.lang_code.ext or basename.lang_code.forced.ext or basename.lang_code.sdh.ext.
  b. File extension: must be one of .srt, .ass, .ssa, .vtt, .smi. If not, add issue.
  c. Placement: subtitle must be in same directory as video OR in a "Subtitles" or "Subs" subfolder relative to video. Validate using os.path.dirname comparison (relative positioning, NOT absolute paths per research pitfall 6).
  d. Naming match: subtitle basename (before lang code) must match video basename (before extension). Example: "Movie (2024).en.srt" matches "Movie (2024).mkv".
  e. If language code is uppercase, add warning recommending lowercase for Linux compatibility.

check_kodi_compatibility(subtitle_path: str, video_path: str) -> dict:
  Returns {compatible: bool, issues: list, warnings: list, recommendations: list}.
  Validates:
  a. Language code: accepts ISO 639-1, ISO 639-2, BCP 47 (with _ separator, not -), or English language name.
  b. File extension: .srt, .ass, .ssa, .sub, .smi.
  c. Placement: must be same directory as video (Kodi does not support subfolder placement).
  d. Naming match: same logic as Plex.

batch_check_compatibility(subtitle_paths: list, video_path: str, target: str = "plex") -> dict:
  Runs the appropriate checker on each subtitle_path. Returns {results: list, summary: {total, compatible, incompatible}}.

Helper functions (private):
  _extract_lang_code(subtitle_filename: str) -> str or None
  _is_valid_iso639(code: str) -> bool (check against known ISO 639-1/2 codes -- use a reasonable hardcoded set of ~50 common codes, not an external dependency)
  _check_naming_match(sub_basename: str, video_basename: str) -> bool

**export_manager.py** -- Multi-format export with strategy pattern.

Functions to create:

export_config(format: str, include_secrets: bool = False) -> dict:
  Main dispatcher. format is one of: "bazarr", "plex", "kodi", "json".
  Returns {format: str, data: dict or str, filename: str, content_type: str, warnings: list}.
  Uses lazy imports for db.config.get_all_config_entries, db.profiles, etc.

_export_bazarr_format(include_secrets) -> dict:
  Produces a Bazarr-compatible config dict. Maps Sublarr config keys to Bazarr section structure:
  - sonarr section: sonarr_url -> ip, sonarr_api_key -> apikey
  - radarr section: same pattern
  - general section: source_language, target_language
  - Label as "Bazarr-compatible" in metadata (not guaranteed exact match per research pitfall 5).
  Masks secrets unless include_secrets=True.

_export_plex_format() -> dict:
  Produces a Plex subtitle manifest: list of subtitle files found in media_path with Plex naming validation results.
  Walks media_path, finds .srt/.ass/.ssa/.vtt files, runs check_plex_compatibility on each.
  Returns {media_path: str, subtitles: [{path, language, format, plex_compatible, issues}]}.

_export_kodi_format() -> dict:
  Same as Plex but using check_kodi_compatibility.

_export_json_format(include_secrets) -> dict:
  Full Sublarr config dump as generic JSON. Includes:
  - config_entries (all key-value pairs, secrets masked unless include_secrets)
  - language_profiles (from db.profiles)
  - provider_stats (summary)
  - version info
  This is the recommended primary export format per research.

export_to_zip(formats: list, include_secrets: bool = False) -> bytes:
  Creates a ZIP archive containing exports in all requested formats.
  Uses zipfile stdlib. Returns bytes of the ZIP file.
  Each format is a separate JSON file in the ZIP (e.g., bazarr_export.json, plex_manifest.json, etc.).
  </action>
  <verify>
Import both modules: cd backend and python -c "from compat_checker import check_plex_compatibility, check_kodi_compatibility; print('compat OK')"
Import export: cd backend and python -c "from export_manager import export_config, export_to_zip; print('export OK')"
  </verify>
  <done>compat_checker.py validates subtitle naming/placement for Plex and Kodi conventions. export_manager.py exports config in 4 formats (bazarr, plex, kodi, json) with ZIP bundling support.</done>
</task>

<task type="auto">
  <name>Task 2: Create integrations API blueprint and register it</name>
  <files>
    backend/routes/integrations.py
    backend/routes/__init__.py
  </files>
  <action>
Create backend/routes/integrations.py as a Flask Blueprint providing all Phase 16 API endpoints. Then register it in routes/__init__.py.

**Blueprint:** bp = Blueprint("integrations", __name__, url_prefix="/api/v1/integrations")

**Endpoints to create:**

1. POST /api/v1/integrations/bazarr/mapping-report
   Accepts JSON: {db_path: str}
   Calls generate_mapping_report(db_path) from bazarr_migrator.
   Returns the mapping report dict.
   Validates db_path exists and is a file.

2. POST /api/v1/integrations/compat-check
   Accepts JSON: {subtitle_paths: list, video_path: str, target: "plex"|"kodi"}
   Calls batch_check_compatibility from compat_checker.
   Returns compatibility results.
   Validates target is "plex" or "kodi".

3. POST /api/v1/integrations/compat-check/single
   Accepts JSON: {subtitle_path: str, video_path: str, target: "plex"|"kodi"}
   Calls check_plex_compatibility or check_kodi_compatibility.
   Returns single result dict.

4. GET /api/v1/integrations/health/sonarr
   Gets all Sonarr instances via get_sonarr_instances from config.
   For each instance, creates SonarrClient and calls extended_health_check().
   Returns {instances: [{name, ...extended_health_check_result}]}.

5. GET /api/v1/integrations/health/radarr
   Same pattern as Sonarr but with RadarrClient.

6. GET /api/v1/integrations/health/jellyfin
   Gets JellyfinClient (legacy singleton) and calls extended_health_check().
   Returns the extended health result.

7. GET /api/v1/integrations/health/mediaservers
   Gets all media server instances from MediaServerManager (lazy import from mediaserver).
   For each instance that has extended_health_check, calls it.
   Returns {instances: [{name, type, ...result}]}.

8. POST /api/v1/integrations/export
   Accepts JSON: {format: "bazarr"|"plex"|"kodi"|"json", include_secrets: bool}
   Calls export_config from export_manager.
   Returns the export data.

9. POST /api/v1/integrations/export/zip
   Accepts JSON: {formats: list, include_secrets: bool}
   Calls export_to_zip from export_manager.
   Returns ZIP file as application/zip download with Content-Disposition header.

10. GET /api/v1/integrations/health/all
    Aggregates extended health from all configured services (Sonarr instances, Radarr instances, Jellyfin, media servers).
    Returns {sonarr: [...], radarr: [...], jellyfin: {...}, media_servers: [...]}.

All endpoints use try/except with appropriate error responses (400 for bad input, 500 for server errors). Use lazy imports for all backend modules (bazarr_migrator, compat_checker, export_manager, sonarr_client, radarr_client, jellyfin_client).

**Register in routes/__init__.py:**
Add import: from routes.integrations import bp as integrations_bp
Add integrations_bp to the blueprint list.
  </action>
  <verify>
Import the blueprint: cd backend and python -c "from routes.integrations import bp; print(bp.name)"
Verify registration: grep "integrations" backend/routes/__init__.py
  </verify>
  <done>routes/integrations.py Blueprint with 10 endpoints covering mapping report, compat check, extended health (all services), export (4 formats + ZIP), registered in routes/__init__.py.</done>
</task>

</tasks>

<verification>
- compat_checker.py importable with check_plex_compatibility and check_kodi_compatibility.
- export_manager.py importable with export_config and export_to_zip.
- routes/integrations.py Blueprint registered and importable.
- All 10 API endpoints defined with proper error handling.
- routes/__init__.py updated with integrations_bp.
</verification>

<success_criteria>
- Plex compat checker validates language codes, extensions, placement, and naming.
- Kodi compat checker validates same with Kodi-specific rules.
- Export manager produces 4 formats with optional secret masking.
- ZIP export bundles multiple formats.
- API blueprint exposes all functionality with proper validation and error handling.
</success_criteria>

<output>
After completion, create .planning/phases/16-external-integrations/16-02-SUMMARY.md
</output>
