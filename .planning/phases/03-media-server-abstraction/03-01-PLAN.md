---
phase: 03-media-server-abstraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/mediaserver/__init__.py
  - backend/mediaserver/base.py
  - backend/mediaserver/jellyfin.py
  - backend/mediaserver/plex.py
  - backend/mediaserver/kodi.py
  - backend/requirements.txt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "MediaServer ABC defines refresh_item, refresh_library, health_check, get_config_fields contract"
    - "MediaServerManager registers backend classes, creates instances lazily from config_entries"
    - "JellyfinEmby backend preserves all existing jellyfin_client.py behavior (health_check, refresh_item, search_item_by_path, refresh_library)"
    - "Plex backend connects via plexapi, finds items by file path, triggers metadata refresh"
    - "Kodi backend sends JSON-RPC 2.0 requests for health check, library scan, and item refresh"
    - "Manager.refresh_all dispatches to ALL configured servers (not fallback chain)"
  artifacts:
    - path: "backend/mediaserver/base.py"
      provides: "MediaServer ABC + RefreshResult dataclass"
      contains: "class MediaServer(ABC)"
    - path: "backend/mediaserver/__init__.py"
      provides: "MediaServerManager singleton with register/refresh_all/health_check_all"
      exports: ["get_media_server_manager", "invalidate_media_server_manager"]
    - path: "backend/mediaserver/jellyfin.py"
      provides: "JellyfinEmbyServer implementing MediaServer ABC"
      contains: "class JellyfinEmbyServer(MediaServer)"
    - path: "backend/mediaserver/plex.py"
      provides: "PlexServer implementing MediaServer ABC"
      contains: "class PlexServer(MediaServer)"
    - path: "backend/mediaserver/kodi.py"
      provides: "KodiServer implementing MediaServer ABC"
      contains: "class KodiServer(MediaServer)"
  key_links:
    - from: "backend/mediaserver/__init__.py"
      to: "backend/mediaserver/base.py"
      via: "import MediaServer, RefreshResult"
      pattern: "from mediaserver\\.base import"
    - from: "backend/mediaserver/__init__.py"
      to: "backend/circuit_breaker.py"
      via: "CircuitBreaker per instance"
      pattern: "from circuit_breaker import CircuitBreaker"
    - from: "backend/mediaserver/__init__.py"
      to: "backend/db/config.py"
      via: "config_entries loading with mediaserver.* prefix"
      pattern: "get_all_config_entries"
---

<objective>
Create the MediaServer ABC, MediaServerManager singleton, and all four backend implementations (Jellyfin/Emby, Plex, Kodi) as a self-contained backend package.

Purpose: Establishes the media server abstraction layer that mirrors the proven TranslationBackend pattern from Phase 2. All backends are implemented here; wiring into the application happens in Plan 02.

Output: `backend/mediaserver/` package with ABC, manager, and 4 backend classes. PlexAPI added to requirements.txt.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-media-server-abstraction/03-RESEARCH.md

# Pattern references (read these for the exact pattern to follow)
@backend/translation/base.py
@backend/translation/__init__.py
@backend/jellyfin_client.py
@backend/circuit_breaker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: MediaServer ABC, Manager, and JellyfinEmby backend</name>
  <files>
    backend/mediaserver/__init__.py
    backend/mediaserver/base.py
    backend/mediaserver/jellyfin.py
  </files>
  <action>
**1. Create `backend/mediaserver/base.py`** -- MediaServer ABC and RefreshResult dataclass.

Mirror `translation/base.py` pattern exactly:
- `RefreshResult` dataclass: `success: bool`, `message: str`, `server_name: str = ""`, `item_id: Optional[str] = None`
- `MediaServer(ABC)` with class-level attributes:
  - `name: str = "unknown"` (lowercase identifier, e.g. "jellyfin", "plex", "kodi")
  - `display_name: str = "Unknown"` (human-readable for UI)
  - `config_fields: list[dict] = []` (same schema as TranslationBackend: key, label, type, required, default, help)
- Constructor: `__init__(self, **config)` storing `self.config = config`
- Abstract methods:
  - `health_check(self) -> tuple[bool, str]` -- returns (is_healthy, message)
  - `refresh_item(self, file_path: str, item_type: str = "") -> RefreshResult` -- refresh by file path
  - `refresh_library(self) -> RefreshResult` -- full library scan fallback
  - `get_config_fields(self) -> list[dict]` -- return config_fields class attribute
- Concrete method:
  - `apply_path_mapping(self, file_path: str) -> str` -- transforms file_path using optional `path_mapping` from self.config. If `path_mapping` is set as "from_path:to_path", replace from_path prefix with to_path. If not set, return file_path unchanged.

**2. Create `backend/mediaserver/__init__.py`** -- MediaServerManager singleton.

Mirror `translation/__init__.py` pattern:
- `MediaServerManager` class:
  - `_server_classes: dict[str, type[MediaServer]]` -- registered backend classes
  - `_instances: dict[str, MediaServer]` -- lazily created instances keyed by "{type}_{index}" (e.g. "jellyfin_0", "plex_1")
  - `_circuit_breakers: dict[str, CircuitBreaker]` -- per-instance circuit breakers
  - `register_server_type(cls)` -- register a backend class by cls.name
  - `get_all_server_types() -> list[dict]` -- return info about registered types (name, display_name, config_fields)
  - `load_instances()` -- read `media_servers_json` from config_entries, parse JSON array, create instances. Each entry: `{"type": "jellyfin", "name": "My Jellyfin", "enabled": true, ...config_keys}`. Clear old instances before loading.
  - `refresh_all(file_path: str, item_type: str = "") -> list[RefreshResult]` -- iterate ALL enabled instances, skip those with OPEN circuit breakers, call refresh_item on each, record success/failure. This is fire-and-forget style: never raise, always return results list. Try item-specific refresh first; if it fails (item not found), fall back to refresh_library for that instance.
  - `health_check_all() -> list[dict]` -- call health_check on each instance, return list of {name, type, healthy, message}
  - `invalidate_instances()` -- clear cached instances (for config reload)
  - `_get_circuit_breaker(instance_key)` -- same pattern as TranslationManager
- Singleton functions:
  - `get_media_server_manager() -> MediaServerManager`
  - `invalidate_media_server_manager()` -- destroy singleton
  - `_register_builtin_servers(manager)` -- register JellyfinEmbyServer, PlexServer (guarded with try/except ImportError for plexapi), KodiServer

CRITICAL DIFFERENCE from TranslationManager: Media servers use `refresh_all` (notify ALL servers), not `translate_with_fallback` (try until one succeeds). Config is stored as a JSON array in a single `media_servers_json` config_entries key, not as individual `mediaserver.<name>.<key>` entries. This is because users configure multiple named instances (e.g., "Living Room Kodi", "Bedroom Plex"), not just one instance per type.

**3. Create `backend/mediaserver/jellyfin.py`** -- JellyfinEmbyServer.

Migrate from `jellyfin_client.py` into the MediaServer ABC:
- Class `JellyfinEmbyServer(MediaServer)`:
  - `name = "jellyfin"`, `display_name = "Jellyfin / Emby"`
  - `config_fields`: url (text, required), api_key (password, required), server_type (text, default "jellyfin", help "jellyfin or emby"), path_mapping (text, optional, help "from_path:to_path for Docker volume mapping")
  - Constructor creates `requests.Session()` with `X-MediaBrowser-Token` header (works for both Jellyfin and Emby)
  - `_get(path, params)` and `_post(path, data)` with retry logic (same as existing JellyfinClient._get/_post with MAX_RETRIES=2, BACKOFF_BASE=2, timeout=15s, 429 rate limit handling)
  - `health_check()` -- GET /System/Info/Public, return (True, "{ServerName} v{Version}") or (False, error)
  - `refresh_item(file_path, item_type)` -- apply_path_mapping, then search_item_by_path (GET /Items with searchTerm), then POST /Items/{id}/Refresh. Return RefreshResult.
  - `refresh_library()` -- POST /Library/Refresh. Return RefreshResult.
  - `_search_item_by_path(file_path)` -- same logic as existing JellyfinClient.search_item_by_path (search by basename, match by path)

Preserve ALL existing retry logic, rate limit handling, and error logging from jellyfin_client.py. The implementation should be nearly identical, just wrapped in the MediaServer ABC interface.
  </action>
  <verify>
```bash
cd backend && python -c "
from mediaserver.base import MediaServer, RefreshResult
from mediaserver.jellyfin import JellyfinEmbyServer
from mediaserver import MediaServerManager, get_media_server_manager

# Verify ABC contract
assert hasattr(MediaServer, 'health_check')
assert hasattr(MediaServer, 'refresh_item')
assert hasattr(MediaServer, 'refresh_library')

# Verify JellyfinEmby
assert JellyfinEmbyServer.name == 'jellyfin'
assert len(JellyfinEmbyServer.config_fields) >= 3

# Verify Manager singleton
mgr = get_media_server_manager()
types = mgr.get_all_server_types()
print(f'Registered types: {[t[\"name\"] for t in types]}')
assert any(t['name'] == 'jellyfin' for t in types)
print('All imports and basic checks passed')
"
```
  </verify>
  <done>MediaServer ABC defines the contract. JellyfinEmbyServer implements it with full retry logic from jellyfin_client.py. MediaServerManager singleton registers types, loads instances from config, dispatches refresh_all to all servers. All classes importable without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Plex and Kodi backends + requirements.txt</name>
  <files>
    backend/mediaserver/plex.py
    backend/mediaserver/kodi.py
    backend/requirements.txt
  </files>
  <action>
**1. Create `backend/mediaserver/plex.py`** -- PlexServer backend using plexapi library.

- Class `PlexServer(MediaServer)`:
  - `name = "plex"`, `display_name = "Plex"`
  - `config_fields`: url (text, required, default "http://localhost:32400"), token (password, required, help "X-Plex-Token from Plex Settings > Troubleshooting > View XML"), path_mapping (text, optional)
  - Constructor: Store url and token from config. Do NOT create PlexServer connection in __init__ (lazy).
  - `_get_server()` -- lazily create `plexapi.server.PlexServer(url, token)`. Cache on self._server. Raise on connection failure.
  - `health_check()` -- call `_get_server()`, access `.friendlyName` and `.version`. Return (True, "{friendlyName} v{version}") or (False, error string). Wrap in try/except for plexapi.exceptions.Unauthorized and requests.ConnectionError.
  - `refresh_item(file_path, item_type)` -- apply_path_mapping, then search library sections for the item:
    - Determine section type: if item_type == "episode" search show sections, if "movie" search movie sections, otherwise search all.
    - For each relevant section, use `section.search(filters={"Media__Part__file__startswith": mapped_path_dir})` to find candidate items.
    - For each result, check if `mapped_file_path` appears in `item.locations` (for movies) or iterate episodes checking media parts for file path match.
    - Once found: call `item.refresh()`. Return RefreshResult(success=True).
    - If not found in any section: fall back to refresh_library().
  - `refresh_library()` -- iterate `_get_server().library.sections()`, call `section.update()` on each. Return RefreshResult.

Guard the entire class with `try: from plexapi.server import PlexServer as _PlexServer; from plexapi import exceptions as plex_exceptions; except ImportError: ...` at module level. If plexapi is not installed, the class should still be importable but `_get_server` should raise a clear error ("plexapi package not installed. Install with: pip install PlexAPI").

**2. Create `backend/mediaserver/kodi.py`** -- KodiServer backend using raw JSON-RPC.

- Class `KodiServer(MediaServer)`:
  - `name = "kodi"`, `display_name = "Kodi"`
  - `config_fields`: url (text, required, default "http://localhost:8080", help "Kodi web interface URL"), username (text, optional, help "HTTP Basic Auth username (if enabled)"), password (password, optional, help "HTTP Basic Auth password"), path_mapping (text, optional)
  - `_rpc(method, params=None)` -- send JSON-RPC 2.0 POST to `{url}/jsonrpc` with `{"jsonrpc": "2.0", "method": method, "params": params, "id": 1}`. Use `requests.post` with timeout=15, auth=(username, password) if username is set, Content-Type application/json. Check for "error" in response JSON. Return result["result"].
  - `health_check()` -- call `_rpc("JSONRPC.Ping")`. Expected result: "pong". Also call `_rpc("Application.GetProperties", {"properties": ["name", "version"]})` for display. Return (True, "Kodi {name} v{major}.{minor}") or (False, error). Handle ConnectionError (Kodi web server not enabled) and 401 (auth required).
  - `refresh_item(file_path, item_type)` -- apply_path_mapping, then use `VideoLibrary.Scan` with `{"directory": parent_directory}` where parent_directory is `os.path.dirname(mapped_file_path) + "/"`. This scans just the parent directory, not the whole library. Return RefreshResult.
  - `refresh_library()` -- call `_rpc("VideoLibrary.Scan")` with no params (full library scan). Return RefreshResult.

**3. Update `backend/requirements.txt`** -- add `PlexAPI>=4.18.0` after the existing `requests` line.

Place it near the other API client libraries. Do NOT change any existing entries.
  </action>
  <verify>
```bash
cd backend && python -c "
from mediaserver.plex import PlexServer
from mediaserver.kodi import KodiServer
from mediaserver import get_media_server_manager

# Verify Plex
assert PlexServer.name == 'plex'
assert len(PlexServer.config_fields) >= 2
print(f'Plex config_fields: {[f[\"key\"] for f in PlexServer.config_fields]}')

# Verify Kodi
assert KodiServer.name == 'kodi'
assert len(KodiServer.config_fields) >= 2
print(f'Kodi config_fields: {[f[\"key\"] for f in KodiServer.config_fields]}')

# Verify all 3 registered in manager
mgr = get_media_server_manager()
types = mgr.get_all_server_types()
names = [t['name'] for t in types]
assert 'jellyfin' in names
assert 'plex' in names
assert 'kodi' in names
print(f'All 3 server types registered: {names}')
" && grep -q "PlexAPI" requirements.txt && echo "PlexAPI in requirements.txt: OK"
```
  </verify>
  <done>PlexServer and KodiServer implement MediaServer ABC. PlexAPI added to requirements.txt. All 3 backend types (jellyfin, plex, kodi) registered in the MediaServerManager. Plex uses plexapi library with lazy connection and file path search. Kodi uses raw JSON-RPC with optional auth and directory-scoped scan.</done>
</task>

</tasks>

<verification>
```bash
cd backend && python -c "
from mediaserver.base import MediaServer, RefreshResult
from mediaserver import get_media_server_manager, invalidate_media_server_manager

mgr = get_media_server_manager()
types = mgr.get_all_server_types()
assert len(types) == 3, f'Expected 3 server types, got {len(types)}'

for t in types:
    assert 'name' in t
    assert 'display_name' in t
    assert 'config_fields' in t
    assert len(t['config_fields']) >= 2
    print(f'{t[\"display_name\"]}: {len(t[\"config_fields\"])} config fields')

# Verify RefreshResult
r = RefreshResult(success=True, message='test')
assert r.success and r.message == 'test'

# Verify path mapping
from mediaserver.jellyfin import JellyfinEmbyServer
srv = JellyfinEmbyServer(url='http://test:8096', api_key='test123', path_mapping='/media:/data')
assert srv.apply_path_mapping('/media/Anime/show.mkv') == '/data/Anime/show.mkv'

print('All verification checks passed')
"
```
</verification>

<success_criteria>
- backend/mediaserver/ package exists with base.py, __init__.py, jellyfin.py, plex.py, kodi.py
- MediaServer ABC defines health_check, refresh_item, refresh_library, get_config_fields, apply_path_mapping
- MediaServerManager registers 3 types, provides get_all_server_types, refresh_all, health_check_all, load_instances
- JellyfinEmbyServer preserves all jellyfin_client.py retry/rate-limit logic in new ABC form
- PlexServer uses plexapi with lazy connection, file path search via Media__Part__file__startswith
- KodiServer uses JSON-RPC 2.0 with optional Basic Auth and directory-scoped VideoLibrary.Scan
- PlexAPI>=4.18.0 added to requirements.txt
- All imports succeed, no circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-media-server-abstraction/03-01-SUMMARY.md`
</output>
