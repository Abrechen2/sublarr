---
phase: 15-api-key-mgmt-notifications-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/routes/api_keys.py
  - backend/bazarr_migrator.py
  - backend/routes/__init__.py
autonomous: true

must_haves:
  truths:
    - "API returns a list of all registered services with their key status and masked values"
    - "User can test an API key connection for any service that has a test function"
    - "User can rotate an API key and the corresponding singleton client is invalidated"
    - "Config can be exported as a ZIP containing config entries, language profiles, and glossaries"
    - "Config can be imported from a Sublarr ZIP export or a CSV of API keys"
    - "Bazarr migration tool parses both YAML and INI config formats and imports settings, profiles, and blacklist"
  artifacts:
    - path: "backend/routes/api_keys.py"
      provides: "API key registry, CRUD, test, export/import, Bazarr migration endpoints"
      exports: ["bp"]
    - path: "backend/bazarr_migrator.py"
      provides: "Bazarr config/DB parser with dual-format support"
      exports: ["parse_bazarr_config", "migrate_bazarr_db"]
  key_links:
    - from: "backend/routes/api_keys.py"
      to: "backend/routes/config.py"
      via: "config_entries read/write for key values"
      pattern: "get_config_entry|save_config_entry"
    - from: "backend/routes/api_keys.py"
      to: "backend/notifier.py"
      via: "invalidate_notifier on key rotation"
      pattern: "invalidate_notifier"
    - from: "backend/routes/__init__.py"
      to: "backend/routes/api_keys.py"
      via: "blueprint registration"
      pattern: "api_keys_bp"
---

<objective>
Backend API for centralized API key management, export/import, and Bazarr migration.

Purpose: Provides the /api/v1/api-keys/* endpoints for viewing, testing, rotating, exporting, and importing API keys, plus a Bazarr migration tool that can read both YAML and INI config formats and import Bazarr database contents.
Output: api_keys.py Blueprint + bazarr_migrator.py module, registered in app
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-api-key-mgmt-notifications-cleanup/15-RESEARCH.md

@backend/routes/__init__.py
@backend/routes/config.py
@backend/config.py
@backend/notifier.py
@backend/db/repositories/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: API Key Registry Blueprint with test, rotate, list, export/import</name>
  <files>backend/routes/api_keys.py, backend/routes/__init__.py</files>
  <action>
Create backend/routes/api_keys.py with a Flask Blueprint at url_prefix="/api/v1/api-keys".

Define API_KEY_REGISTRY as a dict mapping service names to their config_entries keys and optional test functions:
- "sublarr": keys=["api_key"], test_fn=None
- "sonarr": keys=["sonarr_api_key"], test via sonarr_client.test_connection if available
- "radarr": keys=["radarr_api_key"], test via radarr_client.test_connection
- "opensubtitles": keys=["opensubtitles_api_key", "opensubtitles_username", "opensubtitles_password"], test via providers test endpoint
- "jimaku": keys=["jimaku_api_key"], test via providers
- "subdl": keys=["subdl_api_key"], test via providers
- "tmdb": keys=["tmdb_api_key"], test_fn=None
- "tvdb": keys=["tvdb_api_key"], test_fn=None
- "deepl": keys=["deepl_api_key"], test via translation backend
- "apprise": keys=["notification_urls_json"], test via notifier.test_notification

Endpoints:
1. GET / -- List all services with status (configured/missing per key), masked values (show first 4 + last 4 chars, mask middle with ***), and last_updated from config_entries
2. GET /<service> -- Single service detail
3. PUT /<service> -- Update keys for a service. Body: dict of key->value. After save, call appropriate invalidation (invalidate_notifier, reload_settings, etc.) based on service. Return updated service info.
4. POST /<service>/test -- Test connection for a service. Return {success, message}. Use lazy imports for client modules to avoid circular imports.
5. POST /export -- Extended export as ZIP (using BytesIO + zipfile). Include: config entries (masked secrets via get_safe_config), language profiles (from db.profiles), glossary entries (from db.repositories). Content-Type: application/zip.
6. POST /import -- Accept multipart file upload. Support two formats:
   - ZIP (Sublarr export): extract config.json, profiles.json, glossary.json and import
   - CSV: parse rows as service,key_name,key_value and save to config_entries
   Skip secrets that are masked (contain ***). Validate before import.
7. POST /import/bazarr -- Accept multipart file upload of Bazarr config directory (as ZIP or individual files). Delegates to bazarr_migrator. Returns preview of what will be imported. Body param "confirm": true triggers actual import.

Use helper function _mask_value(val) that shows first 4 + "***" + last 4 chars (or all "***" if len <= 8).

Register blueprint in routes/__init__.py: import api_keys_bp, add to registration list.
  </action>
  <verify>
Run: cd backend && python -c "from routes.api_keys import bp; print(bp.name, bp.url_prefix)"
Expect: "api_keys /api/v1/api-keys"
  </verify>
  <done>Blueprint importable, all 7 endpoints defined, registered in routes/__init__.py</done>
</task>

<task type="auto">
  <name>Task 2: Bazarr Migration Module</name>
  <files>backend/bazarr_migrator.py</files>
  <action>
Create backend/bazarr_migrator.py with dual-format Bazarr config parsing and DB migration.

Functions:
1. parse_bazarr_config(file_content: str, filename: str) -> dict:
   - Detect format by filename extension (.yaml/.yml = YAML, .ini/.cfg = INI)
   - If detection fails, try YAML first (yaml.safe_load), then INI (configparser)
   - Normalize both formats to a common dict structure with keys: sonarr, radarr, general, raw
   - For YAML: keys are top-level sections
   - For INI: sections map directly

2. migrate_bazarr_db(db_path: str) -> dict:
   - Open Bazarr SQLite DB read-only using sqlite3
   - Read table_languages_profiles: extract language configs, map to Sublarr profile format
   - Read table_blacklist: extract provider, subtitle_id, timestamp
   - Read table_settings_sonarr and table_settings_radarr for connection info
   - Wrap each table read in try/except (tables may not exist in all versions)
   - Return dict with profiles, blacklist, sonarr_config, radarr_config

3. preview_migration(config_data: dict, db_data: dict) -> dict:
   - Generate a human-readable preview of what will be imported
   - Show current values so user can see what would change

4. apply_migration(config_data: dict, db_data: dict) -> dict:
   - Import config entries via save_config_entry
   - Import profiles via ProfileRepository
   - Import blacklist via BlacklistRepository
   - Return summary counts

Use lazy imports for db.repositories to avoid circular imports. Handle all edge cases with try/except and return warnings list alongside results.
  </action>
  <verify>
Run: cd backend && python -c "from bazarr_migrator import parse_bazarr_config, migrate_bazarr_db; print('OK')"
  </verify>
  <done>Module parses YAML and INI Bazarr configs, reads Bazarr SQLite DB, and can preview/apply migrations</done>
</task>

</tasks>

<verification>
- Import test: from routes.api_keys import bp
- Import test: from bazarr_migrator import parse_bazarr_config
- Verify routes/__init__.py includes api_keys_bp in the registration list
</verification>

<success_criteria>
- API key list endpoint returns all registered services with masked values
- Test endpoint delegates to appropriate client test functions
- Export produces a valid ZIP with config, profiles, glossaries
- Import handles both ZIP and CSV formats
- Bazarr migrator parses YAML and INI config formats
- Bazarr DB reader extracts profiles and blacklist with graceful table-missing handling
</success_criteria>

<output>
After completion, create .planning/phases/15-api-key-mgmt-notifications-cleanup/15-01-SUMMARY.md
</output>
