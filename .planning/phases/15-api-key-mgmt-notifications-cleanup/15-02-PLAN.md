---
phase: 15-api-key-mgmt-notifications-cleanup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/db/models/notifications.py
  - backend/db/models/__init__.py
  - backend/db/repositories/notifications.py
  - backend/db/repositories/__init__.py
  - backend/routes/notifications_mgmt.py
  - backend/routes/__init__.py
  - backend/notifier.py
autonomous: true

must_haves:
  truths:
    - "User can create notification templates with Jinja2 syntax and preview them with sample data"
    - "Templates can be assigned per event type and per service for granular control"
    - "Advanced event filters support include/exclude lists and content-based filtering"
    - "Quiet hours prevent notifications during configured time windows with exception events"
    - "Notification history records all sent notifications with re-send capability"
    - "Notifier renders templates via Jinja2 SandboxedEnvironment before sending via Apprise"
  artifacts:
    - path: "backend/db/models/notifications.py"
      provides: "NotificationTemplate, NotificationHistory, QuietHoursConfig ORM models"
      exports: ["NotificationTemplate", "NotificationHistory", "QuietHoursConfig"]
    - path: "backend/db/repositories/notifications.py"
      provides: "NotificationRepository with CRUD for templates, history, quiet hours"
      exports: ["NotificationRepository"]
    - path: "backend/routes/notifications_mgmt.py"
      provides: "Blueprint for /api/v1/notifications/* endpoints"
      exports: ["bp"]
  key_links:
    - from: "backend/notifier.py"
      to: "backend/db/repositories/notifications.py"
      via: "template lookup and quiet hours check before sending"
      pattern: "NotificationRepository"
    - from: "backend/routes/notifications_mgmt.py"
      to: "backend/db/repositories/notifications.py"
      via: "CRUD operations for templates, history, quiet hours"
      pattern: "NotificationRepository"
    - from: "backend/notifier.py"
      to: "backend/events/catalog.py"
      via: "EVENT_CATALOG payload_keys for template variable validation"
      pattern: "EVENT_CATALOG"
---

<objective>
Backend notification management: templates, quiet hours, event filters, and history.

Purpose: Extends the existing notifier.py with Jinja2 template rendering, quiet hours suppression, event filtering, and notification history logging. Adds DB models, repository, and API endpoints for full CRUD management.
Output: Notification models + repository + API Blueprint + enhanced notifier.py
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-api-key-mgmt-notifications-cleanup/15-RESEARCH.md

@backend/notifier.py
@backend/events/catalog.py
@backend/db/models/__init__.py
@backend/db/repositories/__init__.py
@backend/routes/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification DB Models and Repository</name>
  <files>backend/db/models/notifications.py, backend/db/models/__init__.py, backend/db/repositories/notifications.py, backend/db/repositories/__init__.py</files>
  <action>
Create backend/db/models/notifications.py with three SQLAlchemy ORM models following the exact pattern from db/models/core.py (inherit from db.Model, use Mapped types, Text for timestamps):

1. NotificationTemplate:
   - id (Integer PK autoincrement)
   - name (String(100), unique, not null)
   - title_template (Text, not null, default="")
   - body_template (Text, not null, default="")
   - event_type (String(50), nullable -- null means "all events")
   - service_name (String(50), nullable -- null means "all services")
   - enabled (Integer, default=1)
   - created_at (Text, not null)
   - updated_at (Text, not null)

2. NotificationHistory:
   - id (Integer PK autoincrement)
   - event_type (String(50), not null)
   - title (Text, not null)
   - body (Text, not null)
   - template_id (Integer, nullable)
   - service_urls (Text, nullable)
   - status (String(20), default="sent")
   - error (Text, default="")
   - sent_at (Text, not null)
   - Indexes on event_type and sent_at

3. QuietHoursConfig:
   - id (Integer PK autoincrement)
   - name (String(100), not null)
   - start_time (String(5), not null) -- "HH:MM" format
   - end_time (String(5), not null) -- "HH:MM" format
   - days_of_week (Text, default="[0,1,2,3,4,5,6]") -- JSON array of day numbers
   - exception_events (Text, default='["error"]') -- JSON array of event types that bypass quiet hours
   - enabled (Integer, default=1)
   - created_at (Text, not null)
   - updated_at (Text, not null)

Register all three models in db/models/__init__.py (import + add to __all__).

Create backend/db/repositories/notifications.py with NotificationRepository(BaseRepository):
- Template CRUD: create_template, get_template, get_templates, update_template, delete_template
- find_template_for_event(event_type, service_name) -- fallback chain: specific (service+event) then event-only then default (event_type=None, service_name=None)
- History: log_notification, get_history(page, per_page, event_type filter), get_notification(id)
- Quiet hours CRUD: create_quiet_hours, get_quiet_hours_configs, update_quiet_hours, delete_quiet_hours
- is_quiet_hours(event_type) -- check all enabled quiet hour configs against current local time, respecting days_of_week and exception_events. Overnight ranges (start > end like 22:00-07:00) must work correctly.

Register in db/repositories/__init__.py (import + add to __all__ + add convenience functions).
  </action>
  <verify>
Run: cd backend && python -c "from db.models.notifications import NotificationTemplate, NotificationHistory, QuietHoursConfig; print('models OK')"
Run: cd backend && python -c "from db.repositories.notifications import NotificationRepository; print('repo OK')"
  </verify>
  <done>Three ORM models and NotificationRepository with full CRUD + quiet hours logic are importable</done>
</task>

<task type="auto">
  <name>Task 2: Notifications API Blueprint and Notifier Enhancement</name>
  <files>backend/routes/notifications_mgmt.py, backend/routes/__init__.py, backend/notifier.py</files>
  <action>
Create backend/routes/notifications_mgmt.py with Flask Blueprint at url_prefix="/api/v1/notifications".

Endpoints:
1. Templates CRUD:
   - GET /templates -- list all templates (with optional event_type filter)
   - POST /templates -- create template (validate Jinja2 syntax on save)
   - GET /templates/<id> -- get single template
   - PUT /templates/<id> -- update template
   - DELETE /templates/<id> -- delete template
   - POST /templates/<id>/preview -- render template with sample payload from EVENT_CATALOG payload_keys, return {title, body}

2. Template Variables:
   - GET /variables -- list all available template variables grouped by event type (derived from EVENT_CATALOG)
   - GET /variables/<event_type> -- variables for specific event

3. Quiet Hours:
   - GET /quiet-hours -- list all quiet hours configs
   - POST /quiet-hours -- create config
   - PUT /quiet-hours/<id> -- update
   - DELETE /quiet-hours/<id> -- delete

4. History:
   - GET /history -- paginated notification history (page, per_page, event_type filter)
   - POST /history/<id>/resend -- re-send a historical notification
   - DELETE /history -- clear history (with optional before_date)

5. Event Filters:
   - GET /filters -- get current notification filter config (stored as config_entries with notification_filter_* prefix)
   - PUT /filters -- update filter config: include_events (list), exclude_events (list), content_filters (list of {field, operator, value})

For template syntax validation: use jinja2.Environment().parse(template_str) in a try/except to catch TemplateSyntaxError before saving.

Register blueprint in routes/__init__.py.

Enhance backend/notifier.py send_notification function:
- Before sending, call NotificationRepository.is_quiet_hours(event_type) -- if True and event not in exceptions, suppress with log message
- Look up matching template via find_template_for_event(event_type, service_name=None). If found and enabled, render title and body via Jinja2 SandboxedEnvironment (from jinja2.sandbox import SandboxedEnvironment). Pass event payload as template variables.
- If no template found, use the passed title/body as-is (backward compatible)
- After sending (success or failure), log to notification history via log_notification
- Add new function render_template(template_str: str, variables: dict) -> str using SandboxedEnvironment
- Add new function get_sample_payload(event_type: str) -> dict that returns sample data for each EVENT_CATALOG event based on payload_keys
  </action>
  <verify>
Run: cd backend && python -c "from routes.notifications_mgmt import bp; print(bp.name, bp.url_prefix)"
Expect: "notifications_mgmt /api/v1/notifications"
  </verify>
  <done>Blueprint registered with all template/quiet-hours/history/filter endpoints, notifier.py renders templates and checks quiet hours before sending</done>
</task>

</tasks>

<verification>
- Import test: from db.models.notifications import NotificationTemplate, NotificationHistory, QuietHoursConfig
- Import test: from db.repositories.notifications import NotificationRepository
- Import test: from routes.notifications_mgmt import bp
- Verify notifier.py imports and uses SandboxedEnvironment
- Verify routes/__init__.py includes notifications_mgmt_bp
</verification>

<success_criteria>
- Template CRUD endpoints work with Jinja2 syntax validation
- Template preview renders with sample EVENT_CATALOG data
- Quiet hours checking supports overnight ranges and day-of-week
- Notification history logged on every send attempt
- Notifier backward-compatible (no template = use passed title/body)
- SandboxedEnvironment prevents template injection
</success_criteria>

<output>
After completion, create .planning/phases/15-api-key-mgmt-notifications-cleanup/15-02-SUMMARY.md
</output>
