---
phase: 10-performance-scalability
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/db/repositories/__init__.py
  - backend/db/repositories/base.py
  - backend/db/repositories/config.py
  - backend/db/repositories/blacklist.py
  - backend/db/repositories/cache.py
  - backend/db/repositories/plugins.py
  - backend/db/repositories/scoring.py
  - backend/db/repositories/library.py
  - backend/db/repositories/whisper.py
  - backend/db/repositories/translation.py
autonomous: true

must_haves:
  truths:
    - "Repository classes provide identical functionality to existing db/ domain modules using SQLAlchemy sessions"
    - "All repository methods return dicts (same shape as existing functions) for API compatibility"
    - "Repository pattern enables switching between SQLite and PostgreSQL without changing business logic"
  artifacts:
    - path: "backend/db/repositories/base.py"
      provides: "BaseRepository with session property and common CRUD helpers"
      contains: "class BaseRepository"
    - path: "backend/db/repositories/config.py"
      provides: "ConfigRepository replacing db/config.py functions"
      exports: ["save_config_entry", "get_config_entry", "get_all_config_entries"]
    - path: "backend/db/repositories/blacklist.py"
      provides: "BlacklistRepository replacing db/blacklist.py functions"
      min_lines: 60
    - path: "backend/db/repositories/cache.py"
      provides: "CacheRepository replacing db/cache.py functions"
      min_lines: 120
    - path: "backend/db/repositories/scoring.py"
      provides: "ScoringRepository replacing db/scoring.py functions"
      min_lines: 100
    - path: "backend/db/repositories/translation.py"
      provides: "TranslationRepository replacing db/translation.py functions"
      min_lines: 200
  key_links:
    - from: "backend/db/repositories/base.py"
      to: "backend/extensions.py"
      via: "db.session import"
      pattern: "from extensions import db"
    - from: "backend/db/repositories/config.py"
      to: "backend/db/models/core.py"
      via: "ConfigEntry model import"
      pattern: "from db.models.core import ConfigEntry"
---

<objective>
Convert the 8 simpler db/ domain modules to the Repository pattern using SQLAlchemy ORM sessions. Each repository class replaces the raw sqlite3 queries in its corresponding db/ module with SQLAlchemy ORM operations.

Purpose: These 8 modules (config, blacklist, cache, plugins, scoring, library, whisper, translation) have 38-408 lines each and relatively straightforward CRUD operations. Converting them first establishes the repository pattern and validates it before tackling the more complex modules in Plan 03.

Output: backend/db/repositories/ package with 8 repository classes plus base class and convenience module-level functions that delegate to the repository.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-performance-scalability/10-RESEARCH.md
@.planning/phases/10-performance-scalability/10-01-SUMMARY.md
@backend/db/config.py
@backend/db/blacklist.py
@backend/db/cache.py
@backend/db/plugins.py
@backend/db/scoring.py
@backend/db/library.py
@backend/db/whisper.py
@backend/db/translation.py
@backend/db/models/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Base repository + config, blacklist, cache, plugins repositories</name>
  <files>
    backend/db/repositories/__init__.py
    backend/db/repositories/base.py
    backend/db/repositories/config.py
    backend/db/repositories/blacklist.py
    backend/db/repositories/cache.py
    backend/db/repositories/plugins.py
  </files>
  <action>
1. Create backend/db/repositories/__init__.py:
   - Re-export all repository classes.
   - IMPORTANT: Also provide module-level convenience functions that mirror the existing db/ module APIs. These functions internally create a repository instance (using Flask-SQLAlchemy db.session) and call the method. This is the bridge pattern: `def save_config_entry(key, value): return ConfigRepository().save_config_entry(key, value)`.

2. Create backend/db/repositories/base.py:
   - class BaseRepository:
     - Property `session` that returns `db.session` from extensions (Flask-SQLAlchemy request-scoped session).
     - Helper `_commit()` that calls `self.session.commit()`.
     - Helper `_to_dict(model_instance, columns)` that converts SQLAlchemy model to dict (matching existing return shapes).
     - Helper `_now()` returning `datetime.utcnow().isoformat()`.
   - Import: `from extensions import db`

3. Create backend/db/repositories/config.py (replacing 38-line db/config.py):
   - class ConfigRepository(BaseRepository):
     - save_config_entry(key, value): Use `db.session.merge()` with ConfigEntry model (INSERT OR REPLACE).
     - get_config_entry(key) -> Optional[str]: `db.session.get(ConfigEntry, key)`.
     - get_all_config_entries() -> dict: `db.session.execute(select(ConfigEntry)).scalars().all()` -> dict comprehension.
   - CRITICAL: Return types MUST match existing functions exactly. get_config_entry returns Optional[str] (the value, not the model). get_all_config_entries returns {key: value} dict.

4. Create backend/db/repositories/blacklist.py (replacing 83-line db/blacklist.py):
   - class BlacklistRepository(BaseRepository):
     - add_blacklist_entry(provider_name, subtitle_id, language, file_path, title, reason) -> dict
     - get_blacklist_entries(limit, offset) -> list[dict]
     - get_blacklist_count() -> int
     - is_blacklisted(provider_name, subtitle_id) -> bool
     - delete_blacklist_entry(entry_id) -> bool
     - clear_blacklist() -> int
   - Read existing db/blacklist.py to match exact return shapes and query logic.

5. Create backend/db/repositories/cache.py (replacing 241-line db/cache.py):
   - class CacheRepository(BaseRepository):
     - get_cached_results(provider_name, query_hash) -> Optional[list]: Check expiry, return parsed JSON.
     - save_cache_results(provider_name, query_hash, results, ttl_minutes)
     - clear_expired_cache() -> int
     - clear_provider_cache(provider_name) -> int
     - clear_all_cache() -> int
     - get_cache_stats() -> dict
     - record_download(provider_name, subtitle_id, language, fmt, file_path, score, subtitle_type)
     - get_downloads(limit, offset, provider_name) -> list[dict]
     - get_download_count(provider_name) -> int
     - get_downloads_by_provider() -> list[dict]
   - Read existing db/cache.py to match exact return shapes.

6. Create backend/db/repositories/plugins.py (replacing 118-line db/plugins.py):
   - class PluginRepository(BaseRepository):
     - get_plugin_config(plugin_name, key) -> Optional[str]
     - set_plugin_config(plugin_name, key, value)
     - get_all_plugin_configs(plugin_name) -> dict
     - delete_plugin_configs(plugin_name) -> int
   - Plugin config uses config_entries table with "plugin.{name}.{key}" namespacing. Same model (ConfigEntry), different key pattern.
  </action>
  <verify>
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.config import ConfigRepository; print('ConfigRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.blacklist import BlacklistRepository; print('BlacklistRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.cache import CacheRepository; print('CacheRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.plugins import PluginRepository; print('PluginRepository OK')"`.
  </verify>
  <done>BaseRepository pattern established. Config, blacklist, cache, and plugins repositories created with identical API shapes to existing db/ modules.</done>
</task>

<task type="auto">
  <name>Task 2: Scoring, library, whisper, translation repositories</name>
  <files>
    backend/db/repositories/scoring.py
    backend/db/repositories/library.py
    backend/db/repositories/whisper.py
    backend/db/repositories/translation.py
  </files>
  <action>
1. Create backend/db/repositories/scoring.py (replacing 192-line db/scoring.py):
   - class ScoringRepository(BaseRepository):
     - get_scoring_weights() -> dict: Return {score_type: {weight_key: weight_value}} structure.
     - save_scoring_weight(score_type, weight_key, weight_value)
     - get_provider_modifiers() -> dict: Return {provider_name: modifier} structure.
     - save_provider_modifier(provider_name, modifier)
     - reset_scoring_to_defaults() -> clears scoring_weights and provider_score_modifiers tables.
     - get_effective_weights() -> dict: Returns merged defaults + DB overrides (matching existing logic).
   - Read existing db/scoring.py carefully to preserve the merge-with-defaults logic.

2. Create backend/db/repositories/library.py (replacing 129-line db/library.py):
   - class LibraryRepository(BaseRepository):
     - get_library_stats() -> dict: Counts from jobs, wanted_items, subtitle_downloads, daily_stats.
     - get_daily_stats(days) -> list[dict]: Last N days of stats.
     - get_recent_jobs(limit) -> list[dict]
     - get_recent_downloads(limit) -> list[dict]
   - This module does cross-table aggregate queries. Use SQLAlchemy func.count(), func.sum() etc.

3. Create backend/db/repositories/whisper.py (replacing 163-line db/whisper.py):
   - class WhisperRepository(BaseRepository):
     - create_whisper_job(job_id, file_path, language) -> dict
     - update_whisper_job(job_id, **kwargs): Update any subset of fields.
     - get_whisper_job(job_id) -> Optional[dict]
     - get_whisper_jobs(status, limit) -> list[dict]
     - get_pending_whisper_count() -> int
     - delete_whisper_job(job_id) -> bool
     - clean_stale_whisper_jobs(max_age_hours) -> int
   - Read existing db/whisper.py for exact return shapes and update logic.

4. Create backend/db/repositories/translation.py (replacing 394-line db/translation.py):
   - class TranslationRepository(BaseRepository):
     - record_translation_config(config_hash, ollama_model, prompt_template, target_language)
     - get_translation_config_history() -> list[dict]
     - create_glossary_entry(series_id, source_term, target_term, notes) -> dict
     - get_glossary_entries(series_id) -> list[dict]
     - update_glossary_entry(entry_id, source_term, target_term, notes) -> bool
     - delete_glossary_entry(entry_id) -> bool
     - create_prompt_preset(name, prompt_template, is_default) -> dict
     - get_prompt_presets() -> list[dict]
     - get_default_prompt_preset() -> Optional[dict]
     - update_prompt_preset(preset_id, name, prompt_template, is_default) -> bool
     - delete_prompt_preset(preset_id) -> bool
     - record_backend_stats(backend_name, success, response_time_ms, characters, error)
     - get_backend_stats(backend_name) -> Optional[dict]
     - get_all_backend_stats() -> list[dict]
     - clear_backend_stats(backend_name) -> bool
   - Read existing db/translation.py line by line. The backend_stats functions use weighted running average for avg_response_time_ms (preserve this logic exactly).

5. Update backend/db/repositories/__init__.py to re-export all new repositories.

IMPORTANT for all repositories: Use `select()` and `db.session.execute()` (SQLAlchemy 2.0 style), NOT `db.session.query()` (legacy 1.x pattern). Use `db.session.get(Model, pk)` for primary key lookups. Use `db.session.merge()` for upsert operations.
  </action>
  <verify>
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.scoring import ScoringRepository; print('ScoringRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.library import LibraryRepository; print('LibraryRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.whisper import WhisperRepository; print('WhisperRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories.translation import TranslationRepository; print('TranslationRepository OK')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from db.repositories import *; print('All repositories importable')"`.
  </verify>
  <done>All 8 simpler repository classes created with identical API shapes to their db/ module counterparts. SQLAlchemy 2.0 query syntax used throughout. Return types verified against existing code.</done>
</task>

</tasks>

<verification>
1. All 8 repository classes importable: `python -c "from db.repositories import *"`
2. BaseRepository provides session, commit, to_dict helpers
3. Each repository method signature matches its db/ module counterpart exactly
4. No existing code changed (repositories are purely additive alongside existing db/ modules)
5. SQLAlchemy 2.0 patterns used (select().where(), not Query.filter())
</verification>

<success_criteria>
- 8 repository classes + base class exist in backend/db/repositories/
- All repository methods return identical dict shapes to existing db/ module functions
- Repositories use SQLAlchemy ORM sessions (not raw SQL)
- Convenience functions in __init__.py mirror existing API for easy swapover in Plan 05
</success_criteria>

<output>
After completion, create `.planning/phases/10-performance-scalability/10-02-SUMMARY.md`
</output>
