---
phase: 10-performance-scalability
plan: 06
type: execute
wave: 4
depends_on: ["10-05"]
files_modified:
  - backend/database_backup.py
  - backend/database_health.py
  - docker-compose.yml
  - docker-compose.postgres.yml
  - Dockerfile
autonomous: true

must_haves:
  truths:
    - "Database backup works for both SQLite (backup API) and PostgreSQL (pg_dump subprocess)"
    - "Database health checks are dialect-aware (PRAGMAs for SQLite, pg_stat queries for PostgreSQL)"
    - "Docker Compose example shows optional PostgreSQL and Redis alongside Sublarr"
    - "Dockerfile includes psycopg2-binary for PostgreSQL support"
  artifacts:
    - path: "backend/database_backup.py"
      provides: "Dialect-aware backup: SQLite backup API or pg_dump for PostgreSQL"
      contains: "pg_dump"
    - path: "backend/database_health.py"
      provides: "Dialect-aware health: SQLite PRAGMAs or PostgreSQL pg_stat_* queries"
      contains: "dialect"
    - path: "docker-compose.postgres.yml"
      provides: "Example docker-compose with PostgreSQL and Redis services"
      contains: "postgres"
  key_links:
    - from: "backend/database_backup.py"
      to: "backend/extensions.py"
      via: "db.engine for dialect detection"
      pattern: "db\\.engine\\.dialect"
    - from: "backend/database_health.py"
      to: "backend/extensions.py"
      via: "db.engine for dialect-specific health queries"
      pattern: "db\\.engine"
---

<objective>
Make database backup, health checks, and Docker configuration aware of the new PostgreSQL + Redis options. This ensures operational tooling works correctly regardless of which database backend is in use.

Purpose: Users switching to PostgreSQL need their backup/restore and health monitoring to work. The Docker setup needs examples showing how to run with PostgreSQL and Redis. This is the operational completeness for the database migration.

Output: Updated database_backup.py and database_health.py with dialect detection, new docker-compose.postgres.yml example, updated Dockerfile.
</objective>

<execution_context>
@C:/Users/Dennis Wittke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Dennis Wittke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-performance-scalability/10-RESEARCH.md
@.planning/phases/10-performance-scalability/10-05-SUMMARY.md
@backend/database_backup.py
@backend/database_health.py
@docker-compose.yml
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dialect-aware database backup and health checks</name>
  <files>
    backend/database_backup.py
    backend/database_health.py
  </files>
  <action>
1. Update backend/database_backup.py:
   - Add dialect detection at the start of backup operations:
     ```python
     from extensions import db

     def _is_postgresql():
         return db.engine.dialect.name == "postgresql"
     ```
   - For SQLite backup: Keep existing SQLite backup() API logic unchanged. It uses the sqlite3 connection's backup() method to create a consistent backup file.
   - For PostgreSQL backup: Add a new function `_backup_postgresql(backup_path)`:
     - Use subprocess to call `pg_dump` with the DATABASE_URL.
     - Parse the URL to extract host, port, dbname, user, password.
     - Set PGPASSWORD environment variable for auth.
     - Run: `pg_dump -h {host} -p {port} -U {user} -Fc {dbname} > {backup_path}` (custom format for compression).
     - Log the backup file size.
     - On error: log warning and return False.
   - For PostgreSQL restore: Add `_restore_postgresql(backup_path)`:
     - Run: `pg_restore -h {host} -p {port} -U {user} -d {dbname} --clean --if-exists {backup_path}`.
   - Update the main `create_backup()` function to dispatch based on dialect:
     ```python
     def create_backup(backup_dir=None, label=""):
         if _is_postgresql():
             return _backup_postgresql(backup_dir, label)
         return _backup_sqlite(backup_dir, label)  # existing logic
     ```
   - Update `restore_backup()` similarly.
   - Keep existing backup rotation logic (works for both -- just different file formats).
   - ZIP backup/restore (from Phase 8): Update to include dialect info in the manifest so restore knows which format to expect.

2. Update backend/database_health.py:
   - Add dialect detection (same pattern as backup).
   - For SQLite health checks (existing):
     - Keep PRAGMA integrity_check, PRAGMA table_info, PRAGMA database_list, etc.
     - Keep page_count, page_size, freelist_count for size stats.
     - Keep VACUUM recommendation logic.
   - For PostgreSQL health checks (new):
     - Connection pool stats: `db.engine.pool.status()` -- returns pool size, checked_in, checked_out, overflow.
     - Database size: `SELECT pg_database_size(current_database())`.
     - Table sizes: `SELECT relname, pg_relation_size(oid) FROM pg_class WHERE relkind='r'`.
     - Active connections: `SELECT count(*) FROM pg_stat_activity WHERE datname=current_database()`.
     - Index usage: `SELECT indexrelname, idx_scan FROM pg_stat_user_indexes ORDER BY idx_scan DESC LIMIT 10`.
     - Slow queries (if pg_stat_statements available): basic stats.
   - Update the main `get_health_report()` to dispatch:
     ```python
     def get_health_report():
         if _is_postgresql():
             return _pg_health_report()
         return _sqlite_health_report()  # existing logic
     ```
   - Both reports return the same top-level dict shape: {"status": "healthy", "backend": "sqlite"|"postgresql", "details": {...}}.
   - Add connection pool metrics (for PostgreSQL only -- SQLite uses StaticPool):
     ```python
     def get_pool_stats():
         pool = db.engine.pool
         return {
             "size": pool.size(),
             "checked_in": pool.checkedin(),
             "checked_out": pool.checkedout(),
             "overflow": pool.overflow(),
         }
     ```
  </action>
  <verify>
Run `cd Z:/CC/Sublarr/backend && python -c "from database_backup import create_backup; print('Backup importable')"`.
Run `cd Z:/CC/Sublarr/backend && python -c "from database_health import get_health_report; print('Health importable')"`.
  </verify>
  <done>Database backup supports both SQLite (backup API) and PostgreSQL (pg_dump). Health checks are dialect-aware with pool metrics for PostgreSQL. Both maintain identical return shapes.</done>
</task>

<task type="auto">
  <name>Task 2: Docker configuration for PostgreSQL + Redis</name>
  <files>
    docker-compose.postgres.yml
    Dockerfile
  </files>
  <action>
1. Create docker-compose.postgres.yml (new file, example for advanced deployment):
   ```yaml
   # Sublarr with optional PostgreSQL and Redis
   # Usage: docker compose -f docker-compose.yml -f docker-compose.postgres.yml up -d
   version: "3.8"
   services:
     sublarr:
       environment:
         - SUBLARR_DATABASE_URL=postgresql://sublarr:sublarr_secret@db:5432/sublarr
         - SUBLARR_REDIS_URL=redis://redis:6379/0
       depends_on:
         db:
           condition: service_healthy
         redis:
           condition: service_healthy

     db:
       image: postgres:16-alpine
       environment:
         POSTGRES_DB: sublarr
         POSTGRES_USER: sublarr
         POSTGRES_PASSWORD: sublarr_secret
       volumes:
         - pgdata:/var/lib/postgresql/data
       healthcheck:
         test: ["CMD-SHELL", "pg_isready -U sublarr"]
         interval: 5s
         timeout: 5s
         retries: 5
       restart: unless-stopped

     redis:
       image: redis:7-alpine
       command: redis-server --appendonly yes
       volumes:
         - redisdata:/data
       healthcheck:
         test: ["CMD", "redis-cli", "ping"]
         interval: 5s
         timeout: 5s
         retries: 5
       restart: unless-stopped

   volumes:
     pgdata:
     redisdata:
   ```
   - This is a SEPARATE compose file meant to EXTEND the main docker-compose.yml using Docker Compose's merge feature. It does NOT duplicate the full sublarr service definition.

2. Update Dockerfile:
   - Add PostgreSQL client tools in the runtime stage (needed for pg_dump backup):
     ```dockerfile
     RUN apk add --no-cache postgresql16-client
     ```
     (Or for Debian-based: `apt-get install -y postgresql-client`)
   - The Python packages (psycopg2-binary, redis, rq) are already in requirements.txt from Plan 01 and will be installed during `pip install -r requirements.txt`.
   - Add a comment near the pip install line noting optional PostgreSQL/Redis support.
   - Do NOT change the CMD or entrypoint -- the Flask app auto-detects backend on startup.

IMPORTANT: Do NOT modify the main docker-compose.yml. It should remain the simple zero-config default (SQLite, no Redis). The postgres compose file is a separate overlay.
  </action>
  <verify>
Verify Dockerfile syntax: `cd Z:/CC/Sublarr && docker build --check .` (if supported) or just verify the file is valid YAML/Dockerfile.
Verify docker-compose.postgres.yml is valid: `cd Z:/CC/Sublarr && docker compose -f docker-compose.yml -f docker-compose.postgres.yml config --quiet` (should exit 0).
  </verify>
  <done>Docker infrastructure ready for PostgreSQL + Redis deployment. Dockerfile includes pg client tools. Compose overlay file provides PostgreSQL and Redis services with health checks. Main docker-compose.yml unchanged (zero-config default preserved).</done>
</task>

</tasks>

<verification>
1. database_backup.py detects dialect and dispatches appropriately
2. database_health.py returns consistent shape for both SQLite and PostgreSQL
3. docker-compose.postgres.yml is valid and extends main compose file
4. Dockerfile includes postgresql-client for pg_dump
5. Main docker-compose.yml unchanged
</verification>

<success_criteria>
- Backup/restore works for both SQLite and PostgreSQL
- Health checks are dialect-aware with pool metrics for PostgreSQL
- Docker compose example enables easy PostgreSQL + Redis deployment
- Zero-config default (SQLite) unchanged in main compose file
</success_criteria>

<output>
After completion, create `.planning/phases/10-performance-scalability/10-06-SUMMARY.md`
</output>
